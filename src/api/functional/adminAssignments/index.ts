import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAdminAssignment } from "../../structures/IAdminAssignment";

/**
 * Create new admin assignment (admin_assignments table).
 *
 * POST /adminAssignments creates a new admin assignment, assigning a role or
 * permission to a target admin. Request body must include required references
 * (admin_id, role_id or permission_id, assigned_at, and optionally expiry).
 * Assignments are validated for unique admin-role-permission combinations and
 * must be conflict-free (no duplicate or invalid role assignments).
 *
 * Caller must have privilege to assign roles/permissions, all creation actions
 * are logged for compliance. If parameters fail validation (e.g.,
 * role/permission combination not allowed), returns 400 with error details.
 * Created assignment is returned with references to assigned admin, role,
 * and/or permission.
 *
 * @param props.body Information required to create a new admin assignment
 *   (admin_id, role_id or permission_id, assigned_at, etc.).
 * @path /adminAssignments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Information required to create a new admin assignment (admin_id,
     * role_id or permission_id, assigned_at, etc.).
     */
    body: IAdminAssignment.ICreate;
  };
  export type Body = IAdminAssignment.ICreate;
  export type Response = IAdminAssignment;

  export const METADATA = {
    method: "POST",
    path: "/adminAssignments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/adminAssignments";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAdminAssignment => typia.random<IAdminAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a single admin assignment (admin_assignments table) by ID.
 *
 * GET /adminAssignments/{id} fetches details about a single admin assignment
 * row, including assignment metadata and references to admin, role, or
 * permission. This is used to review or audit a specific admin assignment,
 * check its validity, and display its full configuration.
 *
 * The returned object includes assignment status, actor, context, expiration
 * (if any), and relationships to linked admin and role/permission. This
 * endpoint is typically used by admin privilege escalation review features.
 *
 * Security: Access is limited to authorized users with RBAC rights to view
 * assignments. All accesses are audit-logged. If the assignment does not exist
 * or is deleted, returns 404. Related endpoints: adminRoles, adminPermissions,
 * admins.
 *
 * @param props.id Target admin assignment's ID
 * @path /adminAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target admin assignment's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAdminAssignment;

  export const METADATA = {
    method: "GET",
    path: "/adminAssignments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/adminAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAdminAssignment => typia.random<IAdminAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update admin assignment (admin_assignments table) by ID.
 *
 * PUT /adminAssignments/{id} updates the details (role, permission, expiry
 * time) for an existing admin assignment, used for privilege modification,
 * escalation, or revocation scenarios. The input body must include the
 * updatable assignment fields, and conflicts or forbidden updates are validated
 * before acceptance.
 *
 * On success, the updated assignment is returned. All changes are logged for
 * compliance/audit trace. Attempting to update a non-existent or deleted
 * assignment returns 404. Related endpoints: GET for verification, DELETE for
 * soft-revocation.
 *
 * @param props.id Target admin assignment's ID
 * @param props.body Fields for updating an admin assignment (role_id,
 *   permission_id, expires_at, etc.).
 * @path /adminAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target admin assignment's ID */
    id: string & tags.Format<"uuid">;

    /**
     * Fields for updating an admin assignment (role_id, permission_id,
     * expires_at, etc.).
     */
    body: IAdminAssignment.IUpdate;
  };
  export type Body = IAdminAssignment.IUpdate;
  export type Response = IAdminAssignment;

  export const METADATA = {
    method: "PUT",
    path: "/adminAssignments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/adminAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAdminAssignment => typia.random<IAdminAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete (soft delete) admin assignment (admin_assignments table) by ID.
 *
 * DELETE /adminAssignments/{id} performs a soft delete on an RBAC assignment
 * record, removing its effect but preserving audit/history. Used for
 * revocation, removal of rights, or compliance deletion workflow. The deleted
 * timestamp is set, and the affected assignment is excluded from active RBAC
 * queries but retained for audit review purposes.
 *
 * Deleting a non-existent or already-deleted assignment returns 404. All
 * DELETEs are checked for permission, logged as critical audit events, and may
 * trigger notifications. Related endpoints: PATCH for list/search, POST for
 * creation, and PUT for updates.
 *
 * @param props.id Target admin assignment's ID
 * @path /adminAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target admin assignment's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAdminAssignment;

  export const METADATA = {
    method: "DELETE",
    path: "/adminAssignments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/adminAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAdminAssignment => typia.random<IAdminAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAIFraudCheck } from "../../structures/IAIFraudCheck";
import { IPageIAIFraudCheck } from "../../structures/IPageIAIFraudCheck";

/**
 * Create a new AI fraud check event (ai_fraud_checks table).
 *
 * This operation records a new fraud risk evaluation event on an order, storing
 * full explainability output, AI score, model name, decision, and underlying
 * context as required by compliance and analytics.
 *
 * Normally invoked by order processing flows or as part of manual fraud review.
 * Strict input validation is enforced, and once recorded, the event is
 * immutable. Access is typically system, admin, or privileged fraud team only;
 * actions are fully logged for transparency.
 *
 * Integrates with downstream compliance analytics, AI dashboarding, and export
 * workflows. Errors for invalid data or authorization failure are
 * well-defined.
 *
 * @param props.body AI fraud check event creation parameters
 * @path /aiFraudChecks
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** AI fraud check event creation parameters */
    body: IAIFraudCheck.ICreate;
  };
  export type Body = IAIFraudCheck.ICreate;
  export type Response = IAIFraudCheck;

  export const METADATA = {
    method: "POST",
    path: "/aiFraudChecks",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiFraudChecks";
  export const random = (g?: Partial<typia.IRandomGenerator>): IAIFraudCheck =>
    typia.random<IAIFraudCheck>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search AI fraud check events (ai_fraud_checks table).
 *
 * Returns a paginated, filterable list of AI-powered fraud check events
 * performed on orders (or attempted orders). Searchable by order ID, user ID,
 * model name, or risk decision. Input parameters support page, filter, sort,
 * and time range specification.
 *
 * Access is permitted for back-office compliance staff and auditors, respecting
 * RBAC and data privacy rules. Pagination and sorting use standard parameters.
 * Results allow tracking and audit of fraud management workflows. Soft-deleted
 * records are not included unless privileged.
 *
 * Related to order and payment compliance analytics. Errors include invalid
 * filters or access denied. Often used to support AI explainability exports.
 *
 * @param props.body Search/filter criteria for AI fraud check events
 * @path /aiFraudChecks
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filter criteria for AI fraud check events */
    body: IAIFraudCheck.IRequest;
  };
  export type Body = IAIFraudCheck.IRequest;
  export type Response = IPageIAIFraudCheck;

  export const METADATA = {
    method: "PATCH",
    path: "/aiFraudChecks",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiFraudChecks";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAIFraudCheck => typia.random<IPageIAIFraudCheck>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a single AI fraud check event by ID (ai_fraud_checks table).
 *
 * Retrieve the details of a single AI-driven fraud check performed during order
 * processing. Returns model, score, decision, explanation, and relevant links
 * to order/user. Access is RBAC restricted (admin, compliance staff).
 *
 * This supports compliance, fraud monitoring, and audit trails. Non-existent or
 * deleted checks result in clear error codes and messages. Integrates with
 * order, payment, and audit log endpoints for holistic review.
 *
 * @param props.id Unique identifier for the AI fraud check event
 * @path /aiFraudChecks/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier for the AI fraud check event */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAIFraudCheck;

  export const METADATA = {
    method: "GET",
    path: "/aiFraudChecks/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiFraudChecks/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IAIFraudCheck =>
    typia.random<IAIFraudCheck>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an AI fraud check record by id (ai_fraud_checks table).
 *
 * This API endpoint allows authorized staff or designated compliance systems to
 * update an existing AI fraud check record in the ai_fraud_checks database
 * table. The operation is performed on a single fraud check instance identified
 * by its unique UUID.
 *
 * The endpoint supports updating specific fields related to the fraud check
 * such as score, decision, human-read explanation, or reason for model score
 * adjustment. All changes must be strictly logged and adhere to immutable audit
 * log practicesâ€”older values are retained in the audit system for compliance
 * and risk management. Soft update is enforced: the fraud check record remains
 * for compliance.
 *
 * Validation includes ensuring the new score is within allowed thresholds, that
 * the decision/status is one of {Pass, Review, Fail}, and that only designated
 * fields are modifiable as per business and regulatory requirements (PCI-DSS,
 * AML, etc).
 *
 * Error responses include: NotFound for invalid ids, Forbidden for insufficient
 * permissions, and ValidationError for out-of-range/unsupported fields. All
 * changes trigger an audit log entry recording the actor and operation
 * (GDPR/PCI compliance).
 *
 * This endpoint should be used in conjunction with GET /aiFraudChecks/{id} for
 * retrieving the original record, and DELETE /aiFraudChecks/{id} for soft
 * deletion/audit needs. It is recommended (per compliance) that update
 * privileges are RBAC controlled and restricted to compliance or infosec
 * staff.
 *
 * @param props.id The UUID of the AI fraud check record to update.
 * @param props.body Fields to update in the AI fraud check record. Must conform
 *   to compliance/audit policies for fraud scoring.
 * @path /aiFraudChecks/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The UUID of the AI fraud check record to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Fields to update in the AI fraud check record. Must conform to
     * compliance/audit policies for fraud scoring.
     */
    body: IAIFraudCheck.IUpdate;
  };
  export type Body = IAIFraudCheck.IUpdate;
  export type Response = IAIFraudCheck;

  export const METADATA = {
    method: "PUT",
    path: "/aiFraudChecks/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiFraudChecks/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IAIFraudCheck =>
    typia.random<IAIFraudCheck>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete an AI fraud check record by id.
 *
 * This endpoint performs a soft-deletion of a specified AI fraud check record
 * in the ai_fraud_checks table. The deletion is performed by updating the
 * deleted_at field with the current timestamp, rather than a hard database
 * removal, to preserve immutable audit history as required for legal,
 * regulatory, and compliance (e.g., PCI DSS, GDPR, AML) purposes.
 *
 * The operation is only available to users with appropriate permissions (RBAC
 * enforced), typically restricted to admins, compliance staff, or designated
 * system processes. Any soft-delete action is strictly logged, including the
 * deleting actor, reason (if provided), and timestamp.
 *
 * Attempting to delete a non-existent or already deleted fraud check returns a
 * NotFound error. Deleting a fraud check with active/completed status may
 * require additional justification or override privilege.
 *
 * Related endpoints include PUT /aiFraudChecks/{id} for record
 * corrections/updates and GET /aiFraudChecks/{id} for retrieval. Deletion
 * should not break historical audit chains or downstream audit/export reports.
 *
 * @param props.id The UUID of the AI fraud check record to soft-delete.
 * @path /aiFraudChecks/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** The UUID of the AI fraud check record to soft-delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAIFraudCheck;

  export const METADATA = {
    method: "DELETE",
    path: "/aiFraudChecks/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiFraudChecks/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IAIFraudCheck =>
    typia.random<IAIFraudCheck>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

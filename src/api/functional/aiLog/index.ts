import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAnalyticsAiLog } from "../../structures/IAnalyticsAiLog";
import { IPageIAnalyticsAiLog } from "../../structures/IPageIAnalyticsAiLog";

/**
 * Creates a new AI log event (AnalyticsAI.ai_log table).
 *
 * Creates a new AI log record in the AnalyticsAI.ai_log table. This endpoint
 * supports system-wide audit/compliance by recording every AI/ML interaction
 * (input, output, error) with full traces, provider/user references, and
 * payload (optionally masked). Request body follows IAnalyticsAiLog.ICreate,
 * including all required details for traceability and future analytics.
 *
 * RBAC enforced: Only allowed for system actors, analytics, or compliance
 * officers. Each log is immutable after insert, except via PUT
 * (override/correction) or DELETE (soft-delete). Insert must trigger audit
 * notification/log per section 9 (Compliance/Auditability). Edge error: missing
 * required fields or duplicate log handling. Use with PATCH (list), GET (read),
 * PUT (edit), DELETE (soft-delete).
 *
 * @param props.body All event details to create an AI log entry.
 * @path /aiLog
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** All event details to create an AI log entry. */
    body: IAnalyticsAiLog.ICreate;
  };
  export type Body = IAnalyticsAiLog.ICreate;
  export type Response = IAnalyticsAiLog;

  export const METADATA = {
    method: "POST",
    path: "/aiLog",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiLog";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsAiLog => typia.random<IAnalyticsAiLog>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Paginated/search AI log records (AnalyticsAI.ai_log table).
 *
 * Returns a paginated list of ai_log records, each representing a logged
 * inbound/outbound event or interaction with an AI/ML microservice or provider.
 * As required by sections 10 (AI/ML, Analytics) and 9 (Compliance), this
 * endpoint powers analytics and audit dashboards with search/filter/page
 * capabilities.
 *
 * Filtering allows querying on user, provider, event_type (input/output/error),
 * time window, status, etc. Advanced queries are provided via
 * IAnalyticsAiLog.IRequest, supporting compliance audit and root-cause
 * analysis. Returns IPageIAnalyticsAiLog containing hit summaries. RBAC: access
 * restricted to analytics staff and admins only.
 *
 * Related: Use with POST (log new AI event), GET (log detail view), PUT (manual
 * update/correction, compliance), DELETE (soft-delete) for log lifecycle. Edge
 * cases: malformed filters, excessive page sizes/errors, unauthorized access
 * are returned as errors per API policy.
 *
 * @param props.body Query, filter, sorting, and paging information for AI logs.
 * @path /aiLog
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Query, filter, sorting, and paging information for AI logs. */
    body: IAnalyticsAiLog.IRequest;
  };
  export type Body = IAnalyticsAiLog.IRequest;
  export type Response = IPageIAnalyticsAiLog;

  export const METADATA = {
    method: "PATCH",
    path: "/aiLog",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiLog";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAnalyticsAiLog => typia.random<IPageIAnalyticsAiLog>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetches a detailed AI log record by ID (AnalyticsAI.ai_log table).
 *
 * Retrieves a single ai_log event record from AnalyticsAI for a given log
 * event's unique ID. This log provides compliance, troubleshooting, and
 * explainability for any system or business actor (admin, analytics, devops)
 * permitted to access event details.
 *
 * Returned event details include timestamp, AI provider ref, event_type, user
 * (actor), status, and any (potentially masked) request/response payloads as
 * required for regulatory audit and root-cause investigation.
 *
 * RBAC: Only analytics-admin/devops/superadmin can retrieve. Deleted or
 * non-existent log IDs trigger 404/not found. Used along with PATCH (search),
 * POST (append new event), PUT (update/fix event for compliance), DELETE
 * (soft-delete) for full traceability and log management.
 *
 * @param props.id AI log's unique ID (UUID).
 * @path /aiLog/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** AI log's unique ID (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAnalyticsAiLog;

  export const METADATA = {
    method: "GET",
    path: "/aiLog/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiLog/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsAiLog => typia.random<IAnalyticsAiLog>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates/corrects an AI log record by ID (AnalyticsAI.ai_log table).
 *
 * Updates/corrects an existing AI log entry in AnalyticsAI.ai_log using
 * IAnalyticsAiLog.IUpdate request body, as allowed for compliance/admin
 * auditing (e.g., unmask/correct payload, adjust event_type, or status post
 * factum).
 *
 * Only RBAC-permitted users (analytics-admin, compliance officer) may execute
 * modification; all edits are audit-logged and prior record state is
 * preserved/referenced for compliance traceability, as per requirement 9.
 * Returns the corrected event as confirmation. Invalid/missing ID, unauthorized
 * attempt, or soft-deleted events result in error per API policy. Use with
 * PATCH (search), GET (read), POST (write), DELETE (soft-delete) for complete
 * lifecycle management.
 *
 * @param props.id Target AI log ID (UUID) for update/correction.
 * @param props.body Fields to update/correct in AI log entry.
 * @path /aiLog/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target AI log ID (UUID) for update/correction. */
    id: string & tags.Format<"uuid">;

    /** Fields to update/correct in AI log entry. */
    body: IAnalyticsAiLog.IUpdate;
  };
  export type Body = IAnalyticsAiLog.IUpdate;
  export type Response = IAnalyticsAiLog;

  export const METADATA = {
    method: "PUT",
    path: "/aiLog/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiLog/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsAiLog => typia.random<IAnalyticsAiLog>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-deletes an AI log record by ID (AnalyticsAI.ai_log table).
 *
 * Marks an AI log entry (AnalyticsAI.ai_log) as deleted (soft-deletion via
 * deleted_at timestamp). This fulfills compliance and auditability needs,
 * ensuring that log data is never truly erased, enabling legal proof and
 * rollbacks as per section 9 (Business/Compliance/Security).
 *
 * Accessible only to compliance, analytics-admin, or similar RBAC-approved
 * actors. All deletes logged for later audit/export. Edge: Not found or already
 * deleted results in error response. Required partner operation for log
 * lifecycle, with PATCH (search), GET (read), POST (write), PUT (edit).
 *
 * @param props.id Target AI log ID (UUID) for soft-deletion/compliance.
 * @path /aiLog/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target AI log ID (UUID) for soft-deletion/compliance. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiLog/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiLog/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

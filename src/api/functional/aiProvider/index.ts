import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAnalyticsAiProvider } from "../../structures/IAnalyticsAiProvider";
import { IPageIAnalyticsAiProvider } from "../../structures/IPageIAnalyticsAiProvider";

/**
 * Registers a new AI provider record (AnalyticsAI.ai_provider table).
 *
 * Registers a new AI provider record in the ai_provider table (AnalyticsAI).
 * This enables system administrators or analytics DevOps to plug in modular AI,
 * ML, or microservice providers for recommendation, fraud detection, analytics,
 * or other future-ready logic.
 *
 * All provider details (name, provider_type, endpoint, configuration) are
 * supplied via the IAnalyticsAiProvider.ICreate request body. Successful
 * creation returns full detail with managed UUID and persisted state. RBAC
 * permission: analytics-admin or superadmin only. Each creation should trigger
 * an audit log for compliance (as per Policy & Compliance requirements).
 *
 * Edge handling: Duplicate names result in conflict error. Required fields must
 * be strictly validated. Related use-cases: POST (register), PATCH (search),
 * GET (details), PUT (update), DELETE (soft-delete).
 *
 * @param props.body Registration payload for new AI provider configuration.
 * @path /aiProvider
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Registration payload for new AI provider configuration. */
    body: IAnalyticsAiProvider.ICreate;
  };
  export type Body = IAnalyticsAiProvider.ICreate;
  export type Response = IAnalyticsAiProvider;

  export const METADATA = {
    method: "POST",
    path: "/aiProvider",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiProvider";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsAiProvider => typia.random<IAnalyticsAiProvider>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Lists/searches AI provider records with filtering and pagination
 * (AnalyticsAI.ai_provider table).
 *
 * Retrieves a filtered and paginated collection of AI provider configurations,
 * supporting advanced search and sorting required for analytics, compliance,
 * and extensibility. Based on the ai_provider table (AnalyticsAI), it exposes
 * detailed querying of registered AI microservices/automation endpoints such as
 * recommendations, fraud, or analytics engines as per requirement 10 (AI/ML,
 * Analytics & Future-readiness).
 *
 * Supports filtering (by provider_type, status, etc.), paging, and sorting via
 * request body parameters specified in IAnalyticsAiProvider.IRequest. Includes
 * details necessary for dashboard display, health monitoring, and modular
 * plug-in management. Results are wrapped in IPageIAnalyticsAiProvider for
 * consumer convenience.
 *
 * Security: Only authorized analytics-admin/superadmin roles are allowed
 * access. API consumers may combine this with POST (register), GET (detail),
 * PUT (update), and DELETE (soft-delete) endpoints for end-to-end provider
 * lifecycle control.
 *
 * Error handling: Malformed filters, excessive page sizes, or unauthorized
 * access result in error responses per OpenAPI/REST standards.
 *
 * @param props.body Query, filter, sorting, and paging parameters for AI
 *   provider search.
 * @path /aiProvider
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Query, filter, sorting, and paging parameters for AI provider search. */
    body: IAnalyticsAiProvider.IRequest;
  };
  export type Body = IAnalyticsAiProvider.IRequest;
  export type Response = IPageIAnalyticsAiProvider;

  export const METADATA = {
    method: "PATCH",
    path: "/aiProvider",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiProvider";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAnalyticsAiProvider => typia.random<IPageIAnalyticsAiProvider>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Gets metadata/config for a single AI provider by ID (AnalyticsAI.ai_provider
 * table).
 *
 * Retrieves all persisted information for a specific entry in the ai_provider
 * table (AnalyticsAI). The API returns detailed configuration, endpoint data,
 * provider_type, activation status, and any modular metadata tied to that AI
 * integration. This is essential for admin and technical analysts when
 * reviewing, diagnosing, or exporting current system AI/ML capabilities.
 *
 * RBAC enforcement is mandatory: only users with analytics-admin or higher
 * permission may access this endpoint. Returned data should be fully consistent
 * with current provider state, including soft-deletion flags where relevant
 * (deleted_at not null). Edge cases: non-existent ID returns a 404;
 * deleted/provider not found must result in clear error code.
 *
 * Consume in dashboards, health checks, AI provider setup, and log/audit
 * reporting. Pair with /aiProvider (PATCH: search; POST: add; PUT: update;
 * DELETE: soft-delete) for complete lifecycle control.
 *
 * @param props.id Target AI provider's unique ID (UUID).
 * @path /aiProvider/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target AI provider's unique ID (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAnalyticsAiProvider;

  export const METADATA = {
    method: "GET",
    path: "/aiProvider/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiProvider/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsAiProvider => typia.random<IAnalyticsAiProvider>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates (patch) the configuration of an AI provider record by ID
 * (AnalyticsAI.ai_provider table).
 *
 * Edits an existing AI provider's configuration, endpoint/url, provider_type,
 * status (enabled/inactive), and modular metadata in the ai_provider table.
 * Only authorized analytics admin/superadmin users are allowed to invoke
 * changes, and all edits are forced through RBAC rules and audit logging as per
 * compliance policy 9.
 *
 * Request body must follow the structure of IAnalyticsAiProvider.IUpdate, with
 * validations for required and optional fields. Upon success, the endpoint
 * returns the full updated provider record, including all modifications and
 * maintained referential consistency.
 *
 * Edge cases: Invalid IDs, missing RBAC, or immutable provider (locked for
 * compliance) return error codes. Use with PATCH (search), POST (add), GET
 * (detail), DELETE (soft-delete) for complete provider management.
 *
 * @param props.id Target AI provider's unique ID (UUID) to update.
 * @param props.body Change parameters to apply to AI provider configuration.
 * @path /aiProvider/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target AI provider's unique ID (UUID) to update. */
    id: string & tags.Format<"uuid">;

    /** Change parameters to apply to AI provider configuration. */
    body: IAnalyticsAiProvider.IUpdate;
  };
  export type Body = IAnalyticsAiProvider.IUpdate;
  export type Response = IAnalyticsAiProvider;

  export const METADATA = {
    method: "PUT",
    path: "/aiProvider/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiProvider/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsAiProvider => typia.random<IAnalyticsAiProvider>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-deletes (compliance correct) an AI provider by ID
 * (AnalyticsAI.ai_provider table).
 *
 * Marks an AI provider as deleted (soft-deleted), setting deleted_at to current
 * timestamp in the ai_provider table (AnalyticsAI). This deactivates the
 * provider from all AI/ML dispatches, but retains the full compliance/audit
 * record. Under no circumstance should physical deletion be permitted. Only
 * analytics-admin or superadmin role may invoke this endpoint, and all such
 * actions should be fully logged (with actor, timestamp, reason).
 *
 * Edge cases: Attempt to delete a non-existent ID or provider already marked as
 * deleted yields a detailed error (404 or conflict). This is used for
 * compliance, lifecycle, and modular plug-in removal, and should be paired with
 * add/edit/list endpoints.
 *
 * @param props.id Target AI provider's unique ID (UUID) to soft-delete.
 * @path /aiProvider/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target AI provider's unique ID (UUID) to soft-delete. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiProvider/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiProvider/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

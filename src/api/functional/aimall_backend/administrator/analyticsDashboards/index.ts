import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendAnalyticsDashboard } from "../../../../structures/IPageIAimallBackendAnalyticsDashboard";
import { IAimallBackendAnalyticsDashboard } from "../../../../structures/IAimallBackendAnalyticsDashboard";

/**
 * Fetch paginated analytics dashboard configuration list from
 * aimall_backend_analytics_dashboards.
 *
 * Retrieve a paginated list of analytics dashboard configuration records from
 * the analytics subsystem. Each dashboard represents a customizable UI layout,
 * holding metadata such as dashboard code, title, description, configuration
 * JSON, creation time, and last update time. Utilized by administrators and
 * system operators to manage, select, or audit available dashboards.
 *
 * Access to this endpoint should be limited to users with administrative
 * privileges, as analytics dashboards may encapsulate sensitive configuration
 * or monitoring capabilities. Frequent use cases include loading available
 * dashboards for configuration management, UX design, and monitoring updates.
 *
 * Returned data includes no aggregate or calculated results, only dashboard
 * configuration/metadata from the underlying Prisma table
 * aimall_backend_analytics_dashboards. Errors may occur if no dashboards are
 * found or if the requesting user lacks sufficient privileges.
 *
 * @param props.connection
 * @path /aimall-backend/administrator/analyticsDashboards
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIAimallBackendAnalyticsDashboard;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/analyticsDashboards",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/analyticsDashboards";
  export const random = (): IPageIAimallBackendAnalyticsDashboard =>
    typia.random<IPageIAimallBackendAnalyticsDashboard>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new analytics dashboard configuration record.
 *
 * Creates a new analytics dashboard configuration within the analytics
 * subsystem. The input payload must specify all required configurational and
 * descriptive properties—including dashboard code (unique), title, description,
 * and config JSON—compliant with the aimall_backend_analytics_dashboards
 * schema.
 *
 * Only users with administrative privileges should perform this operation,
 * reflecting the business need to restrict dashboard setup to trusted roles.
 * Uniqueness of the dashboard code is enforced, and creation triggers audit
 * logging for compliance. On success, the system returns the created dashboard
 * entity. Violations of the uniqueness or required-field constraints cause an
 * error response.
 *
 * @param props.connection
 * @param props.body Definition of the analytics dashboard to create.
 * @path /aimall-backend/administrator/analyticsDashboards
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Definition of the analytics dashboard to create. */
    body: IAimallBackendAnalyticsDashboard.ICreate;
  };
  export type Body = IAimallBackendAnalyticsDashboard.ICreate;
  export type Response = IAimallBackendAnalyticsDashboard;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/analyticsDashboards",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/analyticsDashboards";
  export const random = (): IAimallBackendAnalyticsDashboard =>
    typia.random<IAimallBackendAnalyticsDashboard>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Advanced search for analytics dashboards with pagination and filtering.
 *
 * Search and retrieve a filtered, paginated list of analytics dashboards from
 * the analytics configuration table. Supports advanced filtering, searching by
 * fields such as code, title, description, and configurable sorting and
 * pagination. Designed for backend administration tools, this operation
 * provides administrators fine-grained browsing and management of available
 * analytics dashboards, including historical and live dashboards.
 *
 * Requires admin-level authorization. The response structure contains only
 * configuration metadata, as actual dashboard analytics data resides elsewhere.
 * Input validation ensures only safe, allowable fields are filtered/sorted.
 *
 * @param props.connection
 * @param props.body Parameters for filtering and paginating analytics dashboard
 *   configurations.
 * @path /aimall-backend/administrator/analyticsDashboards
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Parameters for filtering and paginating analytics dashboard
     * configurations.
     */
    body: IAimallBackendAnalyticsDashboard.IRequest;
  };
  export type Body = IAimallBackendAnalyticsDashboard.IRequest;
  export type Response = IPageIAimallBackendAnalyticsDashboard;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/analyticsDashboards",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/analyticsDashboards";
  export const random = (): IPageIAimallBackendAnalyticsDashboard =>
    typia.random<IPageIAimallBackendAnalyticsDashboard>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific analytics dashboard configuration by ID.
 *
 * Retrieve the full configuration details for a specific analytics dashboard by
 * its unique identifier. The response includes all atomic properties from the
 * aimall_backend_analytics_dashboards schema: dashboard code, title,
 * description, serialized configuration JSON, creation, and last update
 * timestamps.
 *
 * Administrators use this operation to view, audit, or modify dashboard
 * configurations within the analytics management panel. Security constraints
 * restrict this endpoint to admin-role users due to potential
 * business/operational sensitivity. Errors are returned if the dashboard does
 * not exist or the user does not have access rights.
 *
 * @param props.connection
 * @param props.analyticsDashboardId Unique identifier of the target analytics
 *   dashboard.
 * @path /aimall-backend/administrator/analyticsDashboards/:analyticsDashboardId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target analytics dashboard. */
    analyticsDashboardId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendAnalyticsDashboard;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/analyticsDashboards/:analyticsDashboardId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/analyticsDashboards/${encodeURIComponent(props.analyticsDashboardId ?? "null")}`;
  export const random = (): IAimallBackendAnalyticsDashboard =>
    typia.random<IAimallBackendAnalyticsDashboard>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("analyticsDashboardId")(() =>
        typia.assert(props.analyticsDashboardId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing analytics dashboard configuration by ID.
 *
 * Allows administrative users to update a specific analytics dashboard
 * configuration by its unique ID. The request body includes any updatable
 * fields compliant with the aimall_backend_analytics_dashboards schema:
 * dashboard code (unique), title, description, and config JSON. On successful
 * update, the modified entity is returned.
 *
 * Security logic ensures only admin-role users may access this operation.
 * Uniqueness constraints on the code field and audit trail logging are
 * rigorously enforced. Error responses result if attempting to update a
 * non-existent or immutable dashboard, or violating unique code constraints.
 * Partial updates should be handled in implementation if allowed.
 *
 * @param props.connection
 * @param props.analyticsDashboardId Unique identifier of the target analytics
 *   dashboard.
 * @param props.body Analytics dashboard fields to update (full or partial).
 * @path /aimall-backend/administrator/analyticsDashboards/:analyticsDashboardId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target analytics dashboard. */
    analyticsDashboardId: string & tags.Format<"uuid">;

    /** Analytics dashboard fields to update (full or partial). */
    body: IAimallBackendAnalyticsDashboard.IUpdate;
  };
  export type Body = IAimallBackendAnalyticsDashboard.IUpdate;
  export type Response = IAimallBackendAnalyticsDashboard;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/analyticsDashboards/:analyticsDashboardId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/analyticsDashboards/${encodeURIComponent(props.analyticsDashboardId ?? "null")}`;
  export const random = (): IAimallBackendAnalyticsDashboard =>
    typia.random<IAimallBackendAnalyticsDashboard>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("analyticsDashboardId")(() =>
        typia.assert(props.analyticsDashboardId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an analytics dashboard configuration by unique ID (hard delete).
 *
 * Delete a specific analytics dashboard configuration by its unique identifier.
 * This operation removes the configuration from the analytics system,
 * performing a hard delete as the associated schema contains no soft delete
 * field. Only users with administrator role may execute this action, and all
 * deletions are logged for compliance.
 *
 * This operation is irreversible; once executed, the configuration record is
 * permanently removed with no ability to restore via backend API. Access
 * controls prevent unauthorized users from deleting dashboards. Errors are
 * returned if the target dashboard does not exist or if the user lacks
 * sufficient permissions.
 *
 * @param props.connection
 * @param props.analyticsDashboardId Unique identifier of the analytics
 *   dashboard to delete.
 * @path /aimall-backend/administrator/analyticsDashboards/:analyticsDashboardId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the analytics dashboard to delete. */
    analyticsDashboardId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/analyticsDashboards/:analyticsDashboardId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/analyticsDashboards/${encodeURIComponent(props.analyticsDashboardId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("analyticsDashboardId")(() =>
        typia.assert(props.analyticsDashboardId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

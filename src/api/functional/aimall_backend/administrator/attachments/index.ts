import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendAttachment } from "../../../../structures/IPageIAimallBackendAttachment";
import { IAimallBackendAttachment } from "../../../../structures/IAimallBackendAttachment";

/**
 * Retrieve a paginated list of all community attachments
 * (aimall_backend_attachments table).
 *
 * Retrieve a paginated list of all attachments stored in the AIMall Community
 * system. Attachments are records linked to posts, comments, or reviews, and
 * represent uploaded media (e.g., images, videos, documents) as persistent
 * references in the aimall_backend_attachments schema.
 *
 * This operation is designed to support file browser UI, system moderation, or
 * analytics tools interested in stored attachments. Access is typically
 * restricted to authenticated users (e.g., administrators, moderators) due to
 * privacy/sensitivity concerns about media content.
 *
 * Results present atomic file details only, with no bulk file contents. Clients
 * are responsible for paginating results and performing further filtering.
 * Attachments returned reference their linked post, comment, or review by ID.
 *
 * @param props.connection
 * @path /aimall-backend/administrator/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIAimallBackendAttachment;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/attachments",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/attachments";
  export const random = (): IPageIAimallBackendAttachment =>
    typia.random<IPageIAimallBackendAttachment>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new attachment record representing a completed file or media upload.
 *
 * Creates a new attachment entry in the aimall_backend_attachments table based
 * on provided metadata (file URI, file type, file size, and linkage to post,
 * comment, or review). File uploads themselves happen out-of-band; only
 * metadata/reference is stored in this call.
 *
 * Appropriate for use by client-side applications or admin tools that need to
 * store references to user-uploaded materials. Ensures policy compliance by
 * associating attachments only to allowed entities. Requires authentication and
 * write permissions.
 *
 * @param props.connection
 * @param props.body Attachment data for file/media to register (file URI,
 *   metadata, and linkage).
 * @path /aimall-backend/administrator/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Attachment data for file/media to register (file URI, metadata, and
     * linkage).
     */
    body: IAimallBackendAttachment.ICreate;
  };
  export type Body = IAimallBackendAttachment.ICreate;
  export type Response = IAimallBackendAttachment;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/attachments";
  export const random = (): IAimallBackendAttachment =>
    typia.random<IAimallBackendAttachment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Perform advanced search and filtering over community attachments for
 * moderation or analytics.
 *
 * Allows searching, filtering, and sorting of community attachment records
 * using flexible queries. Uses IAimallBackendAttachment.IRequest to capture
 * advanced filter conditions (e.g., linked post, comment, review, file type,
 * upload date ranges, or partial filename matches).
 *
 * This API supports admin and moderation dashboards that require advanced
 * filtering of attachments for audit, compliance, or bulk actions. Only
 * attributes defined in the aimall_backend_attachments table may be used as
 * criteria. Results are delivered in paginated form with additional metadata
 * for UI display.
 *
 * @param props.connection
 * @param props.body Filter conditions and pagination/sorting parameters for
 *   attachment search.
 * @path /aimall-backend/administrator/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Filter conditions and pagination/sorting parameters for attachment
     * search.
     */
    body: IAimallBackendAttachment.IRequest;
  };
  export type Body = IAimallBackendAttachment.IRequest;
  export type Response = IPageIAimallBackendAttachment;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/attachments";
  export const random = (): IPageIAimallBackendAttachment =>
    typia.random<IPageIAimallBackendAttachment>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific attachment's metadata by attachmentId from the
 * aimall_backend_attachments table.
 *
 * Fetch a single attachment record from the aimall_backend_attachments table by
 * its unique attachmentId. The operation exposes the file's URI, type, size,
 * creation time, and references to linked post, comment, or review, as defined
 * by the Prisma schema.
 *
 * This method enables direct access to metadata for display, moderation, or
 * policy enforcement. Access should be restricted to roles with explicit
 * permissions given the privacy of user-uploaded files. The file's actual
 * content is not returned; only metadata is provided.
 *
 * @param props.connection
 * @param props.attachmentId Unique identifier of the target attachment (UUID,
 *   matches id field in schema).
 * @path /aimall-backend/administrator/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the target attachment (UUID, matches id field in
     * schema).
     */
    attachmentId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendAttachment;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/attachments/:attachmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): IAimallBackendAttachment =>
    typia.random<IAimallBackendAttachment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update metadata or linkage for an existing attachment record by attachmentId.
 *
 * Performs a full update on attachment metadata for a specified attachmentId
 * using provided attributes (file URI, type, size, and linkage), in accordance
 * with the aimall_backend_attachments schema.
 *
 * This is suitable for correcting incorrect references, updating file type, or
 * modifying linkage to posts, comments, or reviews after moderation. May not be
 * used to update file content itself; file lifecycle is managed externally.
 * Requires administrative or moderation privileges.
 *
 * @param props.connection
 * @param props.attachmentId Unique identifier of the attachment to update
 *   (UUID, primary key in table).
 * @param props.body Fields to update for the specified attachment (file URI,
 *   metadata, and new linkage when required).
 * @path /aimall-backend/administrator/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the attachment to update (UUID, primary key in
     * table).
     */
    attachmentId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the specified attachment (file URI, metadata,
     * and new linkage when required).
     */
    body: IAimallBackendAttachment.IUpdate;
  };
  export type Body = IAimallBackendAttachment.IUpdate;
  export type Response = IAimallBackendAttachment;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/attachments/:attachmentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): IAimallBackendAttachment =>
    typia.random<IAimallBackendAttachment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete an attachment record by attachmentId (no soft delete).
 *
 * Removes a specified attachment record from the aimall_backend_attachments
 * table by attachmentId (UUID). As there is no deleted_at field, this is a hard
 * delete.
 *
 * Typical uses include compliance deletion in response to DMCA, Terms of
 * Service violations, or by explicit admin request. Access is strictly limited
 * to authorized roles due to the permanent nature of deletion. Actual file
 * removal from storage must be coordinated externally.
 *
 * @param props.connection
 * @param props.attachmentId UUID of the attachment to delete.
 * @path /aimall-backend/administrator/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the attachment to delete. */
    attachmentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/attachments/:attachmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendAuditLog } from "../../../../structures/IPageIAimallBackendAuditLog";
import { IAimallBackendAuditLog } from "../../../../structures/IAimallBackendAuditLog";

/**
 * Get a paginated list of system audit log entries from
 * aimall_backend_audit_logs.
 *
 * Fetch a paginated list of audit log entries from the platform's analytics
 * subsystem. Each entry includes detailed metadata regarding system,
 * administrator, or automated actions—for instance, login events, permission
 * changes, dashboard edits, and their associated outcome statuses. Audit log
 * retrieval is critical for compliance, incident investigation, and
 * administrator oversight.
 *
 * This endpoint is strictly limited to administrators due to the potential
 * sensitivity of recorded actions and user information contained within audit
 * logs. Data returned is atomic, directly reflecting the core schema without
 * any aggregation or join. Security measures are in place to prevent
 * unprivileged access. If no logs are found, an empty page is returned;
 * insufficient privileges generate an error response.
 *
 * @param props.connection
 * @path /aimall-backend/administrator/auditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIAimallBackendAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/auditLogs",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/auditLogs";
  export const random = (): IPageIAimallBackendAuditLog =>
    typia.random<IPageIAimallBackendAuditLog>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Advanced search of audit log entries with filtering and pagination.
 *
 * Search for and retrieve a filtered, paginated audit trail of log records from
 * the analytics subsystem. Supports field-level querying (event_type, actor_id,
 * event_target, outcome, timestamp, etc), as well as advanced sorting and
 * pagination options. Used by administrators during investigations, compliance
 * checks, and behavioral analysis of system actions.
 *
 * The returned log data includes only atomic properties from the
 * aimall_backend_audit_logs schema for transparency and full auditability.
 * Endpoint access is restricted to administrators, in line with system security
 * and privacy policies. Inputs are validated for allowable search fields and
 * query ranges. Errors occur on validation failure or insufficient privileges.
 *
 * @param props.connection
 * @param props.body Parameters for filtering and paginating audit log entries.
 * @path /aimall-backend/administrator/auditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Parameters for filtering and paginating audit log entries. */
    body: IAimallBackendAuditLog.IRequest;
  };
  export type Body = IAimallBackendAuditLog.IRequest;
  export type Response = IPageIAimallBackendAuditLog;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/auditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/auditLogs";
  export const random = (): IPageIAimallBackendAuditLog =>
    typia.random<IPageIAimallBackendAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific audit log entry by unique ID.
 *
 * Retrieve details for a single audit log event by its unique identifier. The
 * returned fields include actor reference, event type, event target, IP
 * address, outcome, detail JSON, and creation timestamp. Supports auditing,
 * forensics, and operational transparency in line with regulatory
 * requirements.
 *
 * The endpoint strictly restricts access to administration personnel, as audit
 * log entries may expose sensitive system structure or personal data. If the
 * record does not exist or the user lacks permissions, an error is returned.
 *
 * @param props.connection
 * @param props.auditLogId Unique identifier of the audit log record.
 * @path /aimall-backend/administrator/auditLogs/:auditLogId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the audit log record. */
    auditLogId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/auditLogs/:auditLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/auditLogs/${encodeURIComponent(props.auditLogId ?? "null")}`;
  export const random = (): IAimallBackendAuditLog =>
    typia.random<IAimallBackendAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("auditLogId")(() => typia.assert(props.auditLogId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific audit log entry by unique ID (hard delete).
 *
 * Delete a specific audit log entry from the analytics system by unique
 * identifier. This operation irreversibly removes the audit log from the
 * aimall_backend_audit_logs records (hard delete) since there is no soft delete
 * field, and is intended only for seldom, administratively authorized
 * use-cases. All deletions are performed under strict auditing and
 * authorization to prevent compliance violations.
 *
 * Executions of this operation cannot be undone—the audit log is fully removed
 * and cannot be recovered by any backend API. Suitable only for super-admin
 * roles or compliance-driven manual deletions with full consent. If the ID does
 * not exist or the caller lacks permission, an error occurs.
 *
 * @param props.connection
 * @param props.auditLogId Unique identifier of the audit log record to be
 *   deleted.
 * @path /aimall-backend/administrator/auditLogs/:auditLogId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the audit log record to be deleted. */
    auditLogId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/auditLogs/:auditLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/auditLogs/${encodeURIComponent(props.auditLogId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("auditLogId")(() => typia.assert(props.auditLogId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendChannel } from "../../../../structures/IPageIAimallBackendChannel";
import { IAimallBackendChannel } from "../../../../structures/IAimallBackendChannel";
export * as sections from "./sections";

/**
 * Retrieve all platform channels (aimall_backend_channels) for administrative
 * use.
 *
 * Retrieve all defined channels from the platform for management and
 * presentation purposes. This operation exposes the current state of every
 * channel in the system, including unique identifiers, channel codes, display
 * names, enabled flags, and audit timestamps. It closely aligns with the
 * channel governance requirements of the system, preserving strict
 * normalization and avoiding denormalized or computed values.
 *
 * Security-wise, this endpoint is typically reserved for administrators, as
 * channels directly affect content delivery and routing within the system.
 * However, other elevated roles involved in configuration or reporting may also
 * be granted access based on the business’s access control policy. The response
 * will present the channel entity structure as defined in the Prisma schema,
 * enabling the administrator to view all necessary fields for each channel, and
 * can be used in conjunction with creation, update, and section management APIs
 * for a complete channel administration workflow.
 *
 * Error scenarios include unauthorized access, database connectivity issues, or
 * inconsistent/incomplete entities. Validation is unnecessary for this
 * operation as no parameters are involved.
 *
 * @param props.connection
 * @path /aimall-backend/administrator/channels
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIAimallBackendChannel;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/channels",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/channels";
  export const random = (): IPageIAimallBackendChannel =>
    typia.random<IPageIAimallBackendChannel>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Provision (create) a new platform channel in aimall_backend_channels.
 *
 * Create a new channel for the platform, providing unique code, display name,
 * enabled flag, and all other required properties as per the schema. This
 * operation ensures that new channels comply with all normalization and
 * uniqueness constraints—especially for code.
 *
 * The endpoint supports channel provisioning workflows (e.g., onboarding a new
 * sales portal or device app association). Security rules must restrict access
 * to administrators and ensure validation of request payload. The creation
 * process includes audit field assignments (timestamps), and may return
 * validation errors for uniqueness, format, or completeness.
 *
 * Upon success, the response includes the fully populated entity representing
 * the new channel for immediate use or further configuration (e.g., adding
 * sections, assigning products). Related operations include channel listing,
 * update, and section APIs.
 *
 * @param props.connection
 * @param props.body Channel creation data (all required fields for
 *   aimall_backend_channels).
 * @path /aimall-backend/administrator/channels
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Channel creation data (all required fields for
     * aimall_backend_channels).
     */
    body: IAimallBackendChannel.ICreate;
  };
  export type Body = IAimallBackendChannel.ICreate;
  export type Response = IAimallBackendChannel;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/channels",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/channels";
  export const random = (): IAimallBackendChannel =>
    typia.random<IAimallBackendChannel>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Advanced search/filter with pagination for platform channels
 * (aimall_backend_channels).
 *
 * Search and filter channels stored in the AIMall backend, providing advanced
 * capabilities for pagination, sorting, and multi-condition queries. This
 * supports administrators or other privileged users in quickly locating
 * channels of interest for further actions (e.g., activation, configuration,
 * section assignment).
 *
 * This operation improves on the basic list operation by providing flexibility
 * for frontend interfaces with large/complex channel datasets, supporting
 * search forms, autocomplete, keyword filtering, and status-based filtering.
 * Security considerations include limiting access to roles responsible for
 * channel configuration. The operation's request body accepts a structured
 * search/filter request following the conventions for index/search endpoints.
 * The interaction is closely tied to the underlying aimall_backend_channels
 * schema, and surfaces only normalized, persisted properties. API clients must
 * expect pagination and sort metadata, and validate that only permitted roles
 * may conduct arbitrary queries on this resource.
 *
 * @param props.connection
 * @param props.body Search and pagination/filter criteria for channels.
 * @path /aimall-backend/administrator/channels
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Search and pagination/filter criteria for channels. */
    body: IAimallBackendChannel.IRequest;
  };
  export type Body = IAimallBackendChannel.IRequest;
  export type Response = IPageIAimallBackendChannel;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/channels",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/channels";
  export const random = (): IPageIAimallBackendChannel =>
    typia.random<IPageIAimallBackendChannel>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detail of a single platform channel by UUID (aimall_backend_channels).
 *
 * Get full detail of a particular channel from the AIMall platform by its UUID.
 * All relevant properties—such as code, name, enabled flag, and timestamps—are
 * included as defined in the Prisma schema.
 *
 * This operation is primarily used in administrative interfaces for auditing or
 * editing a specific channel. Because channel details can impact routing,
 * product visibility, and multi-store operations, this endpoint should require
 * strong authorization. Only users with admin or channel-management permission
 * can invoke it. The operation validates the channelId as a UUID and ensures
 * that it matches an existing record. Related endpoints are the general channel
 * list, create, update, or section management APIs.
 *
 * Validation logic should confirm correct UUID syntax, and business logic
 * should prevent unauthorized lookup of confidential channel settings.
 *
 * @param props.connection
 * @param props.channelId Unique identifier of the channel to retrieve.
 * @path /aimall-backend/administrator/channels/:channelId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the channel to retrieve. */
    channelId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendChannel;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/channels/:channelId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/channels/${encodeURIComponent(props.channelId ?? "null")}`;
  export const random = (): IAimallBackendChannel =>
    typia.random<IAimallBackendChannel>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific channel (aimall_backend_channels) by UUID.
 *
 * Update a channel's configuration by its UUID, providing the required change
 * set as defined in the Prisma schema and system business rules. Typical fields
 * to modify include code, name, or enabled status, but not immutable audit
 * fields.
 *
 * Role-based access control is critical: only channel administrators or
 * platform managers must be allowed to perform this update operation. Request
 * body must validate against update request DTO. Upon success, the endpoint
 * returns the updated entity for display or further workflows.
 *
 * Validation scenarios: unchanged or duplicate code/name are rejected; only
 * valid fields from the schema are accepted. This endpoint relates directly to
 * channel read, section management, and assignment APIs, forming part of the
 * full channel lifecycle management.
 *
 * @param props.connection
 * @param props.channelId Unique identifier of the channel to update.
 * @param props.body Fields to update for the channel.
 * @path /aimall-backend/administrator/channels/:channelId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the channel to update. */
    channelId: string & tags.Format<"uuid">;

    /** Fields to update for the channel. */
    body: IAimallBackendChannel.IUpdate;
  };
  export type Body = IAimallBackendChannel.IUpdate;
  export type Response = IAimallBackendChannel;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/channels/:channelId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/channels/${encodeURIComponent(props.channelId ?? "null")}`;
  export const random = (): IAimallBackendChannel =>
    typia.random<IAimallBackendChannel>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Hard-delete a channel (aimall_backend_channels) by UUID. Irreversible.
 *
 * Permanently remove a channel entity by its unique identifier (UUID). Because
 * the underlying schema does not specify any soft deletion (such as a
 * deleted_at column), deletion is performed as a hard delete—completely erasing
 * the record from the system.
 *
 * This operation is strictly limited to platform administrators or users with
 * explicit deletion rights. Deleting a channel may affect related records (such
 * as section assignments) through cascading orphans as defined by foreign key
 * constraints.
 *
 * Prior to invocation, business logic should validate non-existence of
 * dependent assignments or enforce cascade rules as appropriate. Error or
 * warning should be returned if the target channel does not exist. Event
 * logging is required to trace deletion events for compliance and recovery use
 * cases.
 *
 * @param props.connection
 * @param props.channelId Unique identifier of the channel to delete.
 * @path /aimall-backend/administrator/channels/:channelId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the channel to delete. */
    channelId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/channels/:channelId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/channels/${encodeURIComponent(props.channelId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

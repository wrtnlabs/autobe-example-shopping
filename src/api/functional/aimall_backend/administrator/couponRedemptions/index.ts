import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendCouponRedemption } from "../../../../structures/IPageIAimallBackendCouponRedemption";
import { IAimallBackendCouponRedemption } from "../../../../structures/IAimallBackendCouponRedemption";

/**
 * Lists all coupon redemption records, paginated.
 *
 * Fetch an unfiltered, paginated list of all coupon redemption records from the
 * database. This provides detailed logs (success/failure, date, redemption
 * target, outcome) for analytics review and operational monitoring.
 *
 * Access is restricted to administrators as redemption data may include
 * sensitive user/order information.
 *
 * For volume efficiency and consistent database performance, returns paged
 * lists. Admins can review summary stats by fetching across page boundaries.
 * See PATCH for advanced search; GET by ID for individual redemption details.
 *
 * @param props.connection
 * @path /aimall-backend/administrator/couponRedemptions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIAimallBackendCouponRedemption;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/couponRedemptions",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/couponRedemptions";
  export const random = (): IPageIAimallBackendCouponRedemption =>
    typia.random<IPageIAimallBackendCouponRedemption>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new coupon redemption (use) record.
 *
 * Creates a record for a coupon redemption event, typically triggered by the
 * checkout process or by admin action. Request body must provide all necessary
 * redemption context (coupon ID, customer ID, campaign ID if known, time,
 * status, order/product, and result).
 *
 * All field values are strictly validated against current business rulesâ€”coupon
 * eligibility, campaign active period, no redundant redeemed coupons, and
 * user-level redemption limits. Records are audit-logged for compliance.
 * Success returns full created entity, or input-rejection error if validation
 * fails.
 *
 * @param props.connection
 * @param props.body Details of redemption attempt to be created as a new log
 *   row.
 * @path /aimall-backend/administrator/couponRedemptions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Details of redemption attempt to be created as a new log row. */
    body: IAimallBackendCouponRedemption.ICreate;
  };
  export type Body = IAimallBackendCouponRedemption.ICreate;
  export type Response = IAimallBackendCouponRedemption;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/couponRedemptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/couponRedemptions";
  export const random = (): IAimallBackendCouponRedemption =>
    typia.random<IAimallBackendCouponRedemption>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search, filter, and paginate coupon redemption records by various criteria.
 *
 * Retrieves coupon redemption records by advanced filters, including customer
 * ID, campaign ID, redemption status (success, failed, invalid), date/time
 * range, or by target order/product IDs. Supports pagination and sort order.
 *
 * This endpoint is vital for support teams, fraud detection, and for resolving
 * disputed or abnormal coupon attempts. Restricted to administrators, with
 * appropriate compliance and audit logging. Validation ensures only permitted
 * filter values and paging are accepted.
 *
 * Consumers may use GET by ID API to inspect individual redemption details as
 * required.
 *
 * @param props.connection
 * @param props.body Advanced search and filtering fields for coupon
 *   redemptions.
 * @path /aimall-backend/administrator/couponRedemptions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Advanced search and filtering fields for coupon redemptions. */
    body: IAimallBackendCouponRedemption.IRequest;
  };
  export type Body = IAimallBackendCouponRedemption.IRequest;
  export type Response = IPageIAimallBackendCouponRedemption;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/couponRedemptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/couponRedemptions";
  export const random = (): IPageIAimallBackendCouponRedemption =>
    typia.random<IPageIAimallBackendCouponRedemption>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detail for a specific coupon redemption by ID.
 *
 * Fetches a single coupon redemption record by its unique ID, including all
 * detail fields such as coupon/campaign association, status, customer,
 * order/product target, timestamp, and outcome. Used in backoffice, support and
 * fraud investigation UIs.
 *
 * Admins or designated support staff must use this endpoint to obtain the
 * definitive record for a redemption. Invalid IDs result in a not-found error.
 *
 * No request body; path parameter must be included.
 *
 * @param props.connection
 * @param props.couponRedemptionId Unique identifier for the coupon redemption
 *   record.
 * @path /aimall-backend/administrator/couponRedemptions/:couponRedemptionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the coupon redemption record. */
    couponRedemptionId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendCouponRedemption;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/couponRedemptions/:couponRedemptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/couponRedemptions/${encodeURIComponent(props.couponRedemptionId ?? "null")}`;
  export const random = (): IAimallBackendCouponRedemption =>
    typia.random<IAimallBackendCouponRedemption>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponRedemptionId")(() =>
        typia.assert(props.couponRedemptionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a coupon redemption record by ID.
 *
 * Update the business or analytical details of a specific coupon redemption
 * record by ID. All main fields are updatable (except immutable audit keys such
 * as ID and initial redemption timestamp). Allows correction of misclassified
 * outcomes, addition of missing data (order/product IDs) or other
 * support-driven edits.
 *
 * Validation is enforced: status changes must conform to business rules,
 * campaign associations must be valid, and all audit rules (change history,
 * traceability) are satisfied. Success returns the updated entity; not found
 * error if record is missing.
 *
 * Admins and designated analytic staff only; all changes are tracked in audit
 * trail for compliance.
 *
 * @param props.connection
 * @param props.couponRedemptionId ID of the coupon redemption record to update.
 * @param props.body Fields to update for the redemption record.
 * @path /aimall-backend/administrator/couponRedemptions/:couponRedemptionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** ID of the coupon redemption record to update. */
    couponRedemptionId: string & tags.Format<"uuid">;

    /** Fields to update for the redemption record. */
    body: IAimallBackendCouponRedemption.IUpdate;
  };
  export type Body = IAimallBackendCouponRedemption.IUpdate;
  export type Response = IAimallBackendCouponRedemption;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/couponRedemptions/:couponRedemptionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/couponRedemptions/${encodeURIComponent(props.couponRedemptionId ?? "null")}`;
  export const random = (): IAimallBackendCouponRedemption =>
    typia.random<IAimallBackendCouponRedemption>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponRedemptionId")(() =>
        typia.assert(props.couponRedemptionId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Hard delete a coupon redemption log record by ID.
 *
 * Permanently deletes a coupon redemption log from the system. Use only for
 * compliance or operational cleanup, as all analytics or history for that
 * record are permanently lost.
 *
 * Requires admin privileges; all deletions are audit logged. If the provided ID
 * is invalid or does not exist, returns not found. No soft-delete field is
 * present so operation is irreversible. Related business implications: may
 * impact analytics or open investigations.
 *
 * @param props.connection
 * @param props.couponRedemptionId UUID for the coupon redemption log to be
 *   deleted.
 * @path /aimall-backend/administrator/couponRedemptions/:couponRedemptionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID for the coupon redemption log to be deleted. */
    couponRedemptionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/couponRedemptions/:couponRedemptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/couponRedemptions/${encodeURIComponent(props.couponRedemptionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponRedemptionId")(() =>
        typia.assert(props.couponRedemptionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

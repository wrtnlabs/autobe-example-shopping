import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendAddress } from "../../../../../structures/IPageIAimallBackendAddress";
import { IAimallBackendAddress } from "../../../../../structures/IAimallBackendAddress";

/**
 * Retrieve all delivery addresses for a customer (aimall_backend_addresses).
 *
 * Fetch all delivery addresses for a given customer as stored in the
 * aimall_backend_addresses table. Each address includes details such as alias,
 * recipient name, phone, address lines, city, postal code, country, is_default
 * flag, and update timestamp.
 *
 * This operation is restricted to authenticated usersâ€”customers can only view
 * their own addresses; administrators may view all addresses for
 * service/support. Security checks must verify ownership/role before allowing
 * access.
 *
 * The operation enables seamless checkout flows and address selectors by
 * providing the full address book for a customer. Any errors such as
 * non-existent customerId or unauthorized access will return appropriate
 * errors.
 *
 * @param props.connection
 * @param props.customerId The unique identifier (UUID) of the customer whose
 *   addresses are requested.
 * @path /aimall-backend/administrator/customers/:customerId/addresses
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /**
     * The unique identifier (UUID) of the customer whose addresses are
     * requested.
     */
    customerId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIAimallBackendAddress;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/customers/:customerId/addresses",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/addresses`;
  export const random = (): IPageIAimallBackendAddress =>
    typia.random<IPageIAimallBackendAddress>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Add a new address for a customer (aimall_backend_addresses).
 *
 * Register a new delivery address for the specified customer by customerId. The
 * operation inserts a normalized address record into aimall_backend_addresses,
 * enforcing referential integrity and uniqueness constraints as defined in the
 * schema.
 *
 * Only the account owner (customer) or administrative actors may use this
 * endpoint. The implementation must ensure the new address is strictly
 * associated with the user in path parameter. If is_default is specified, the
 * API ensures it's the only default for the customer.
 *
 * Related endpoints: PUT for address updates, GET for address retrieval. Errors
 * include invalid input, exceeding allowed addresses, or access violations.
 *
 * @param props.connection
 * @param props.customerId The unique identifier (UUID) of the customer for whom
 *   the address is being added.
 * @param props.body Address creation details conforming to
 *   aimall_backend_addresses model.
 * @path /aimall-backend/administrator/customers/:customerId/addresses
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * The unique identifier (UUID) of the customer for whom the address is
     * being added.
     */
    customerId: string & tags.Format<"uuid">;

    /**
     * Address creation details conforming to aimall_backend_addresses
     * model.
     */
    body: IAimallBackendAddress.ICreate;
  };
  export type Body = IAimallBackendAddress.ICreate;
  export type Response = IAimallBackendAddress;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/customers/:customerId/addresses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/addresses`;
  export const random = (): IAimallBackendAddress =>
    typia.random<IAimallBackendAddress>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Advanced search/filter of a customer's addresses (aimall_backend_addresses).
 *
 * Perform advanced search and pagination over the addresses of a specific
 * customer using the aimall_backend_addresses table. Supports filtering by
 * various fields such as recipient_name, alias, city, or default status, as
 * well as sorting and pagination.
 *
 * Permissions ensure that only the customer or authorized administrators can
 * use this endpoint. Search results return only addresses directly associated
 * with the customerId provided.
 *
 * Related API: GET /customers/{customerId}/addresses returns all addresses,
 * while this endpoint enables filtered and paginated queries. Error handling
 * covers invalid customerId, out-of-bound paging parameters, and access
 * violations.
 *
 * @param props.connection
 * @param props.customerId The unique identifier (UUID) of the customer whose
 *   addresses are to be searched.
 * @param props.body Filter, sort, and pagination options for searching customer
 *   addresses.
 * @path /aimall-backend/administrator/customers/:customerId/addresses
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * The unique identifier (UUID) of the customer whose addresses are to
     * be searched.
     */
    customerId: string & tags.Format<"uuid">;

    /**
     * Filter, sort, and pagination options for searching customer
     * addresses.
     */
    body: IAimallBackendAddress.IRequest;
  };
  export type Body = IAimallBackendAddress.IRequest;
  export type Response = IPageIAimallBackendAddress;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/customers/:customerId/addresses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/addresses`;
  export const random = (): IPageIAimallBackendAddress =>
    typia.random<IPageIAimallBackendAddress>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch one address for customer by addressId (aimall_backend_addresses).
 *
 * Fetch details of a specific delivery address, identified by addressId, for a
 * customer specified by customerId as stored in aimall_backend_addresses.
 * Fields returned include all address components, flags, and updated_at.
 *
 * Security ensures that only the owner customer or an admin can fetch private
 * address data. Cross-account access is denied unless elevated permissions are
 * present.
 *
 * This is used in detailed address edit screens or address selection for
 * orders. Errors for non-existent or unauthorized access are managed
 * appropriately.
 *
 * @param props.connection
 * @param props.customerId The unique identifier (UUID) of the customer
 *   associated with the address.
 * @param props.addressId The unique identifier (UUID) of the desired address
 *   record.
 * @path /aimall-backend/administrator/customers/:customerId/addresses/:addressId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * The unique identifier (UUID) of the customer associated with the
     * address.
     */
    customerId: string & tags.Format<"uuid">;

    /** The unique identifier (UUID) of the desired address record. */
    addressId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendAddress;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/customers/:customerId/addresses/:addressId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/addresses/${encodeURIComponent(props.addressId ?? "null")}`;
  export const random = (): IAimallBackendAddress =>
    typia.random<IAimallBackendAddress>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("addressId")(() => typia.assert(props.addressId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing address for a customer (aimall_backend_addresses).
 *
 * Update an existing address entry for a customer, identified by customerId and
 * addressId, using data from IAimallBackendAddress.IUpdate.
 *
 * The operation performs partial/full update on aimall_backend_addresses fields
 * such as alias, recipient_name, phone, address details, and is_default,
 * keeping referential and business constraints enforced (e.g., only one default
 * address per customer).
 *
 * Can only be used by the address owner or admin. Related endpoints: GET for
 * detail view, DELETE for removal.
 *
 * Error cases: trying to update another customer's address, invalid addressId,
 * or business rule conflicts (e.g., attempting to set multiple addresses as
 * default).
 *
 * @param props.connection
 * @param props.customerId The unique identifier (UUID) of the customer whose
 *   address is being updated.
 * @param props.addressId The unique identifier (UUID) of the address record to
 *   update.
 * @param props.body Fields for updating the address record per
 *   aimall_backend_addresses.
 * @path /aimall-backend/administrator/customers/:customerId/addresses/:addressId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * The unique identifier (UUID) of the customer whose address is being
     * updated.
     */
    customerId: string & tags.Format<"uuid">;

    /** The unique identifier (UUID) of the address record to update. */
    addressId: string & tags.Format<"uuid">;

    /** Fields for updating the address record per aimall_backend_addresses. */
    body: IAimallBackendAddress.IUpdate;
  };
  export type Body = IAimallBackendAddress.IUpdate;
  export type Response = IAimallBackendAddress;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/customers/:customerId/addresses/:addressId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/addresses/${encodeURIComponent(props.addressId ?? "null")}`;
  export const random = (): IAimallBackendAddress =>
    typia.random<IAimallBackendAddress>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("addressId")(() => typia.assert(props.addressId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (hard) an address for a customer (aimall_backend_addresses).
 *
 * Delete an address for a customer using customerId and addressId according to
 * the schema for aimall_backend_addresses. Since there are no soft delete
 * fields in the model, this performs a permanent removal from the database.
 *
 * Only the address owner or an authorized admin may execute the deletion.
 * Errors include trying to delete someone else's address or a non-existent
 * address.
 *
 * After deletion, related data (e.g., orders) should handle address references
 * according to platform policy.
 *
 * @param props.connection
 * @param props.customerId The unique identifier (UUID) of the customer whose
 *   address is to be deleted.
 * @param props.addressId The unique identifier (UUID) of the address to be
 *   deleted.
 * @path /aimall-backend/administrator/customers/:customerId/addresses/:addressId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * The unique identifier (UUID) of the customer whose address is to be
     * deleted.
     */
    customerId: string & tags.Format<"uuid">;

    /** The unique identifier (UUID) of the address to be deleted. */
    addressId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/customers/:customerId/addresses/:addressId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/addresses/${encodeURIComponent(props.addressId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("addressId")(() => typia.assert(props.addressId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

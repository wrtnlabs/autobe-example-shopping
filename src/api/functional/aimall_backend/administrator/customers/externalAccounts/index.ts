import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAIMallBackendExternalAccount } from "../../../../../structures/IPageIAIMallBackendExternalAccount";
import { IAIMallBackendExternalAccount } from "../../../../../structures/IAIMallBackendExternalAccount";

/**
 * Retrieve all external accounts linked to a customer (Actors DB).
 *
 * Fetch all external accounts linked to the specified customer. This endpoint
 * returns each external account (such as Google, Kakao, or Apple) currently
 * associated with the customer account, as defined in the
 * aimall_backend_external_accounts table.
 *
 * This operation is important for providing customers with awareness and
 * control over their linked login credentials. Only authenticated customers (or
 * platform administrators) should have access, and privacy must be maintained
 * so that only the account owner (or an admin) can retrieve these
 * associations.
 *
 * If there are no external accounts registered, an empty list will be returned.
 * The response adheres to auditability and data minimization requirements
 * outlined in system documentation.
 *
 * All access is logged for compliance. This endpoint is often paired with
 * linking new external accounts or removing old ones for account ownership and
 * management flows.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the target customer whose
 *   external accounts are being retrieved
 * @path /aimall-backend/administrator/customers/:customerId/externalAccounts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the target customer whose external accounts are
     * being retrieved
     */
    customerId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIAIMallBackendExternalAccount;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/customers/:customerId/externalAccounts",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/externalAccounts`;
  export const random = (): IPageIAIMallBackendExternalAccount =>
    typia.random<IPageIAIMallBackendExternalAccount>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Link a new external account to the customer (Actors DB).
 *
 * Link a new external (federated) account for the target customer. Used by
 * sign-in, social login onboarding, or account linking settings. Requires
 * validation that the external account is not already linked elsewhere and that
 * proper OAuth token verification has occurred upstream.
 *
 * On success, creates a new external account record with provider info,
 * external user ID, and linkage time. Only the authenticated customer or
 * delegated admin may perform this action.
 *
 * All actions are fully audited for compliance and security. Returns the newly
 * created external account entity on success.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the target customer who is
 *   linking a new external account
 * @param props.body Payload specifying provider and external identity
 *   information to link
 * @path /aimall-backend/administrator/customers/:customerId/externalAccounts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the target customer who is linking a new
     * external account
     */
    customerId: string & tags.Format<"uuid">;

    /** Payload specifying provider and external identity information to link */
    body: IAIMallBackendExternalAccount.ICreate;
  };
  export type Body = IAIMallBackendExternalAccount.ICreate;
  export type Response = IAIMallBackendExternalAccount;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/customers/:customerId/externalAccounts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/externalAccounts`;
  export const random = (): IAIMallBackendExternalAccount =>
    typia.random<IAIMallBackendExternalAccount>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and filter external accounts for a customer (Actors DB).
 *
 * Search and retrieve a paginated, filtered list of external accounts for a
 * customer. This enables filtering on providers, dates, or external user ID and
 * allows admins or the customer to audit all federated logins associated with
 * their account.
 *
 * Request body controls advanced query logic (e.g., provider filtering, date
 * range, sorting, pagination limits). Only authorized users can execute
 * filtered searches; the operation must enforce resource-level permissions and
 * log all access.
 *
 * Pairs with get (simple list) endpoint, but adds full search and filter
 * capabilities for compliance or user self-management tools.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the target customer whose
 *   external accounts are being searched
 * @param props.body Advanced query criteria for external accounts (filter,
 *   pagination, etc)
 * @path /aimall-backend/administrator/customers/:customerId/externalAccounts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Unique identifier of the target customer whose external accounts are
     * being searched
     */
    customerId: string & tags.Format<"uuid">;

    /**
     * Advanced query criteria for external accounts (filter, pagination,
     * etc)
     */
    body: IAIMallBackendExternalAccount.IRequest;
  };
  export type Body = IAIMallBackendExternalAccount.IRequest;
  export type Response = IPageIAIMallBackendExternalAccount;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/customers/:customerId/externalAccounts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/externalAccounts`;
  export const random = (): IPageIAIMallBackendExternalAccount =>
    typia.random<IPageIAIMallBackendExternalAccount>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific external account for a customer (Actors DB).
 *
 * Get the details of a particular external account associated with a customer.
 * This operation fetches comprehensive data about the federated login provider,
 * external user ID, and linkage time for auditing and user transparency.
 *
 * Access is permitted only to the account owner (customer) or privileged
 * (admin) staff. Non-existent or mismatched records return a clear error.
 *
 * Useful in account security review, federated login visibility UIs, or
 * federated account unlinking flows. All operations are logged for audit.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the target customer
 * @param props.externalAccountId Unique identifier of the external account
 *   (federated login) to retrieve
 * @path /aimall-backend/administrator/customers/:customerId/externalAccounts/:externalAccountId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target customer */
    customerId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the external account (federated login) to
     * retrieve
     */
    externalAccountId: string & tags.Format<"uuid">;
  };
  export type Response = IAIMallBackendExternalAccount;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/customers/:customerId/externalAccounts/:externalAccountId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/externalAccounts/${encodeURIComponent(props.externalAccountId ?? "null")}`;
  export const random = (): IAIMallBackendExternalAccount =>
    typia.random<IAIMallBackendExternalAccount>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("externalAccountId")(() =>
        typia.assert(props.externalAccountId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update external account linkage for a customer (Actors DB).
 *
 * Update an existing external account record for a customer. Used to correct or
 * re-link federated login info. Operation enforces permission so that only the
 * customer or privileged admin can update, and checks that the new linkage
 * won't conflict with an already-linked account.
 *
 * If update is not allowed (e.g., immutable provider), will reject with error.
 * All update attempts are audited.
 *
 * Returns updated external account info on success.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the target customer
 * @param props.externalAccountId Unique identifier of the external account
 *   linkage being updated
 * @param props.body Information for updating the external account linkage
 * @path /aimall-backend/administrator/customers/:customerId/externalAccounts/:externalAccountId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target customer */
    customerId: string & tags.Format<"uuid">;

    /** Unique identifier of the external account linkage being updated */
    externalAccountId: string & tags.Format<"uuid">;

    /** Information for updating the external account linkage */
    body: IAIMallBackendExternalAccount.IUpdate;
  };
  export type Body = IAIMallBackendExternalAccount.IUpdate;
  export type Response = IAIMallBackendExternalAccount;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/customers/:customerId/externalAccounts/:externalAccountId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/externalAccounts/${encodeURIComponent(props.externalAccountId ?? "null")}`;
  export const random = (): IAIMallBackendExternalAccount =>
    typia.random<IAIMallBackendExternalAccount>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("externalAccountId")(() =>
        typia.assert(props.externalAccountId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (unlink) an external account linkage for a customer (Actors DB).
 *
 * Delete the linkage between a customer's account and a specific external
 * (federated) account. This is used for de-linking OAuth/OpenID logins, account
 * unlinking UI, or in response to a federated identity compromise request.
 *
 * As no soft delete field exists, this operation performs a hard delete of the
 * external account record. Only the customer or a privileged admin may perform
 * this delete. All operations are fully audited for compliance.
 *
 * Related login tokens via the provider may be invalidated after removal, and
 * re-linking would require fresh OAuth verification.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer whose external
 *   account link is being deleted
 * @param props.externalAccountId Unique identifier of the external account
 *   linkage being deleted
 * @path /aimall-backend/administrator/customers/:customerId/externalAccounts/:externalAccountId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the customer whose external account link is
     * being deleted
     */
    customerId: string & tags.Format<"uuid">;

    /** Unique identifier of the external account linkage being deleted */
    externalAccountId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/customers/:customerId/externalAccounts/:externalAccountId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}/externalAccounts/${encodeURIComponent(props.externalAccountId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("externalAccountId")(() =>
        typia.assert(props.externalAccountId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAimallBackendCustomer } from "../../../../structures/IAimallBackendCustomer";
import { IPageIAimallBackendCustomer } from "../../../../structures/IPageIAimallBackendCustomer";
export * as externalAccounts from "./externalAccounts";
export * as behaviorTrackings from "./behaviorTrackings";
export * as addresses from "./addresses";

/**
 * List all customer accounts in summary form (aimall_backend_customers table).
 *
 * Retrieve a flat list of customer records from the system, returning summary
 * fields only. This operation covers basic customer account properties for each
 * registered user, including unique id, email, phone, current status, and audit
 * fields such as created_at and updated_at.
 *
 * For data privacy reasons, only authorized administrator users should use this
 * endpoint—ensuring that PII access is strictly controlled. The operation
 * excludes related/linked models like addresses, behavior tracking, or external
 * accounts; those can be loaded via dedicated endpoints as needed.
 *
 * Use cases include admin dashboard lists, compliance reports, or system
 * analytics overviews.
 *
 * @param props.connection
 * @path /aimall-backend/administrator/customers
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IAimallBackendCustomer.ISummary;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/customers",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/customers";
  export const random = (): IAimallBackendCustomer.ISummary =>
    typia.random<IAimallBackendCustomer.ISummary>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Advanced search and paginate customers (aimall_backend_customers table).
 *
 * Search and paginate over customer account records in the backend system. This
 * endpoint is designed for admin or compliance UI dashboards, where advanced
 * filtering is needed—such as querying by email, phone, or status, or reviewing
 * customers created within a certain date range.
 *
 * All query parameters are specified in the IAimallBackendCustomer.IRequest
 * request body, which defines fields like email, phone, status, creation/update
 * date ranges, as well as limit and offset for pagination. The operation
 * returns a page of IAimallBackendCustomer.ISummary responses with total count,
 * page number, and data items.
 *
 * Access control is strictly administrator-only, reflecting the sensitivity of
 * customer PII. For batch partner sync, auditing, or data exports, use this
 * endpoint.
 *
 * @param props.connection
 * @param props.body Advanced filter, search, and pagination parameters defined
 *   in IAimallBackendCustomer.IRequest DTO.
 * @path /aimall-backend/administrator/customers
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Advanced filter, search, and pagination parameters defined in
     * IAimallBackendCustomer.IRequest DTO.
     */
    body: IAimallBackendCustomer.IRequest;
  };
  export type Body = IAimallBackendCustomer.IRequest;
  export type Response = IPageIAimallBackendCustomer.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/customers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/customers";
  export const random = (): IPageIAimallBackendCustomer.ISummary =>
    typia.random<IPageIAimallBackendCustomer.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get all details of a customer (aimall_backend_customers table).
 *
 * Retrieve full detail of a specific customer account by customerId. This
 * operation loads all atomic fields from the aimall_backend_customers entity,
 * such as id, email, phone, password_hash (nullable), status, created_at, and
 * updated_at.
 *
 * The endpoint supports authorized administrator users for account management,
 * audit, or data correction workflows. Related tables (e.g., addresses,
 * behavior) are not included but can be loaded through other APIs. Exposes all
 * fields for compliance and editing but should be protected against
 * unauthorized access due to PII risk.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer to retrieve.
 * @path /aimall-backend/administrator/customers/:customerId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the customer to retrieve. */
    customerId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendCustomer;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/customers/:customerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IAimallBackendCustomer =>
    typia.random<IAimallBackendCustomer>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a given customer account by customerId (aimall_backend_customers
 * table).
 *
 * Update the fields of an existing customer account identified by customerId.
 * The request body follows the IAimallBackendCustomer.IUpdate DTO, supporting
 * mutation of fields such as email, phone, password_hash, and status depending
 * on permissions and business rules.
 *
 * Only administrator or account owner may perform updates, with tight
 * uniqueness checks for email/phone. Upon successful validation and update, the
 * endpoint returns a full customer entity reflecting all changes and current
 * audit trail. It is protected as a privileged operation, with strict logging
 * and compliance required.
 *
 * @param props.connection
 * @param props.customerId The unique identifier of the customer to update.
 * @param props.body Fields to update for the customer account by
 *   IAimallBackendCustomer.IUpdate DTO.
 * @path /aimall-backend/administrator/customers/:customerId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The unique identifier of the customer to update. */
    customerId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the customer account by
     * IAimallBackendCustomer.IUpdate DTO.
     */
    body: IAimallBackendCustomer.IUpdate;
  };
  export type Body = IAimallBackendCustomer.IUpdate;
  export type Response = IAimallBackendCustomer;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/customers/:customerId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IAimallBackendCustomer =>
    typia.random<IAimallBackendCustomer>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (hard) a customer account by id (aimall_backend_customers table).
 *
 * Permanently remove a customer account using customerId as the unique
 * identifier. Since aimall_backend_customers has no soft-delete or deleted_at
 * column, this is an immediate, irreversible delete—removing the record from
 * the system.
 *
 * Only administrator users should have access, and due diligence is required to
 * anonymize any related records containing PII prior to delete to meet
 * compliance. Audit logging is required for all destructive operations.
 * Non-existent customerId returns 404. No content is returned on success.
 *
 * @param props.connection
 * @param props.customerId Unique id of the customer account to delete.
 * @path /aimall-backend/administrator/customers/:customerId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique id of the customer account to delete. */
    customerId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/customers/:customerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendDiscountCampaign } from "../../../../structures/IPageIAimallBackendDiscountCampaign";
import { IAimallBackendDiscountCampaign } from "../../../../structures/IAimallBackendDiscountCampaign";
export * as coupons from "./coupons";

/**
 * Retrieves all discount campaigns from the campaign table.
 *
 * Fetch a complete list of discount campaigns from the
 * aimall_backend_discount_campaigns table. This endpoint provides all campaigns
 * with their configuration fields such as code, name, type, active date range,
 * stacking rules, and business status.
 *
 * Security: Only users with administrator privileges may access this endpoint,
 * as discount campaign data is sensitive and often managed by platform staff.
 *
 * No parameters are needed for this endpoint and no sophisticated filtering or
 * searching is applied. Consumers are expected to use this data to build
 * campaign selection UIs or for administrative batch analytics/reporting.
 * Campaigns returned include full metadata and linkage to related
 * coupons/redemptions for downstream use.
 *
 * @param props.connection
 * @path /aimall-backend/administrator/discountCampaigns
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIAimallBackendDiscountCampaign;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/discountCampaigns",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/discountCampaigns";
  export const random = (): IPageIAimallBackendDiscountCampaign =>
    typia.random<IPageIAimallBackendDiscountCampaign>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new discount campaign record.
 *
 * Allows administrators to create and configure a new discount campaign. The
 * request body should contain all essential campaign fields, such as campaign
 * code, name, type (order, product), stackability, priority, start/end
 * timestamps, max uses per user, and an optional description.
 *
 * Required fields are validated for uniqueness (e.g., campaign code), and
 * business constraints (e.g., date range logic, nonnegative max use, etc)
 * enforced. Success response returns the full campaign object as added.
 * Appropriate audit logging of campaign creation is maintained for compliance
 * and operational integrity.
 *
 * @param props.connection
 * @param props.body Information required to create a new discount campaign
 *   entity.
 * @path /aimall-backend/administrator/discountCampaigns
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Information required to create a new discount campaign entity. */
    body: IAimallBackendDiscountCampaign.ICreate;
  };
  export type Body = IAimallBackendDiscountCampaign.ICreate;
  export type Response = IAimallBackendDiscountCampaign;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/discountCampaigns",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/discountCampaigns";
  export const random = (): IAimallBackendDiscountCampaign =>
    typia.random<IAimallBackendDiscountCampaign>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Advanced search & filter for discount campaigns with pagination and sorting.
 *
 * Searches for discount campaigns using flexible, multi-parameter filters.
 * Users can filter by campaign type, status (active, inactive, ended), date
 * ranges, stackability, and campaign code/name. Supports pagination and sorting
 * by any main field.
 *
 * Security: Only administrators can utilize search against the campaign
 * dataset; filtering by inactive or ended campaigns is essential for
 * operational workflows and analytics review. Proper results paging prevents
 * data overload for large datasets.
 *
 * Related APIs: Use GET /discountCampaigns/{id} to fetch campaign details; use
 * POST to create or PUT to update campaigns.
 *
 * @param props.connection
 * @param props.body Filtering, sorting, and pagination parameters for searching
 *   discount campaigns.
 * @path /aimall-backend/administrator/discountCampaigns
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Filtering, sorting, and pagination parameters for searching discount
     * campaigns.
     */
    body: IAimallBackendDiscountCampaign.IRequest;
  };
  export type Body = IAimallBackendDiscountCampaign.IRequest;
  export type Response = IPageIAimallBackendDiscountCampaign;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/discountCampaigns",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/discountCampaigns";
  export const random = (): IPageIAimallBackendDiscountCampaign =>
    typia.random<IPageIAimallBackendDiscountCampaign>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information on a specific discount campaign by ID.
 *
 * Fetch a detailed discount campaign entity using the campaign ID. Includes all
 * campaign attributes, relationships, and description. Useful for displaying
 * details in admin UIs, preparing for campaign edits, or for auditing
 * historical campaigns.
 *
 * Only users with administrative privileges may access individual campaign
 * records, as these may contain sensitive configuration and analytics links.
 * Validation ensures the campaign exists, and returns errors if not found. No
 * request body, but path parameter is required.
 *
 * If the ID refers to a non-existent campaign, a not-found error is returned.
 *
 * @param props.connection
 * @param props.discountCampaignId Unique identifier of the target discount
 *   campaign.
 * @path /aimall-backend/administrator/discountCampaigns/:discountCampaignId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target discount campaign. */
    discountCampaignId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendDiscountCampaign;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/discountCampaigns/:discountCampaignId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/discountCampaigns/${encodeURIComponent(props.discountCampaignId ?? "null")}`;
  export const random = (): IAimallBackendDiscountCampaign =>
    typia.random<IAimallBackendDiscountCampaign>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("discountCampaignId")(() =>
        typia.assert(props.discountCampaignId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a discount campaign by its ID.
 *
 * Update a specific discount campaign's settings, based on campaign ID. Permits
 * changes to type, stacking, activity period, maximum uses, priority,
 * description, and other core fields. Enforces field validation, uniqueness of
 * code, and permitted status transitions.
 *
 * Access is restricted to administrative users; all updates are audit-logged.
 * Path parameter is required; request body provides fields to update. If the
 * campaign ID does not exist, returns not found error.
 *
 * Change validation: Ensures active campaigns do not violate business rules
 * regarding period, stacking, or usage limits. On success, returns the updated
 * object.
 *
 * @param props.connection
 * @param props.discountCampaignId Identifier of the discount campaign to
 *   update.
 * @param props.body Updated data for the discount campaign entity.
 * @path /aimall-backend/administrator/discountCampaigns/:discountCampaignId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Identifier of the discount campaign to update. */
    discountCampaignId: string & tags.Format<"uuid">;

    /** Updated data for the discount campaign entity. */
    body: IAimallBackendDiscountCampaign.IUpdate;
  };
  export type Body = IAimallBackendDiscountCampaign.IUpdate;
  export type Response = IAimallBackendDiscountCampaign;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/discountCampaigns/:discountCampaignId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/discountCampaigns/${encodeURIComponent(props.discountCampaignId ?? "null")}`;
  export const random = (): IAimallBackendDiscountCampaign =>
    typia.random<IAimallBackendDiscountCampaign>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("discountCampaignId")(() =>
        typia.assert(props.discountCampaignId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (hard) a discount campaign by ID.
 *
 * Remove a discount campaign from the system by its ID (UUID). This operation
 * irreversibly deletes the campaign record and all direct relationships, as
 * there is no soft-deletion mechanism defined in the schema.
 *
 * Only administrative users may invoke this operation. Audit trails record all
 * deletion events for compliance. Validation: If the campaign ID does not
 * correspond to a campaign, a not-found error is returned.
 *
 * Warning: This operation cannot be reversed, and all associated coupons and
 * analytics history may be orphaned or impacted.
 *
 * @param props.connection
 * @param props.discountCampaignId Identifier (UUID) of the campaign to delete.
 * @path /aimall-backend/administrator/discountCampaigns/:discountCampaignId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Identifier (UUID) of the campaign to delete. */
    discountCampaignId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/discountCampaigns/:discountCampaignId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/discountCampaigns/${encodeURIComponent(props.discountCampaignId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("discountCampaignId")(() =>
        typia.assert(props.discountCampaignId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

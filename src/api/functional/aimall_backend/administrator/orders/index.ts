import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendOrder } from "../../../../structures/IPageIAimallBackendOrder";
import { IAimallBackendOrder } from "../../../../structures/IAimallBackendOrder";
export * as orderItems from "./orderItems";
export * as payments from "./payments";
export * as shipments from "./shipments";
export * as orderSnapshots from "./orderSnapshots";

/**
 * Retrieve a paginated summary list of all orders (Orders table).
 *
 * Fetches a paginated listing of all order records in the platform for
 * administrative or seller operational use. Results include summary-level
 * details directly mapped from the 'aimall_backend_orders' table, such as order
 * numbers, customer and seller references, status, total amount, and
 * creation/update timestamps.
 *
 * Access to this endpoint is permissioned for administrators and sellers only,
 * due to the sensitivity of customer, fulfillment, and financial data. Data
 * returned is strictly limited to what is available from the database and does
 * not incorporate any calculated fields or denormalized aggregates.
 *
 * Related endpoints include search/filter endpoints, order item detail queries,
 * and order mutation APIs. Security audits and error handling ensure all
 * accesses and failures (such as overreaching permissions or record not found)
 * are logged for compliance. The response data structure mirrors the Prisma
 * order table definition and is intended for list view or dashboard
 * consumption.
 *
 * @param props.connection
 * @path /aimall-backend/administrator/orders
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIAimallBackendOrder;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/orders",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/orders";
  export const random = (): IPageIAimallBackendOrder =>
    typia.random<IPageIAimallBackendOrder>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new order (Orders table).
 *
 * Creates a new order in the database, initializing required business
 * attributes as specified in the 'aimall_backend_orders' Prisma schema. Order
 * creation involves providing customer, seller, address, order_number (business
 * ID), and the core order content (status, total_amount, currency).
 *
 * Business logic may auto-generate order_number if not supplied. Security
 * checks are performed to ensure valid foreign keys (customer, seller,
 * address), and only allowed users (authenticated customers, sellers,
 * administrators) can submit new orders. Validation errors and role violations
 * are handled with appropriate responses. Related APIs allow follow-up
 * management of items, payments, and shipments.
 *
 * @param props.connection
 * @param props.body All business fields required to create a new order.
 * @path /aimall-backend/administrator/orders
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** All business fields required to create a new order. */
    body: IAimallBackendOrder.ICreate;
  };
  export type Body = IAimallBackendOrder.ICreate;
  export type Response = IAimallBackendOrder;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/orders";
  export const random = (): IAimallBackendOrder =>
    typia.random<IAimallBackendOrder>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Advanced order search with filtering and pagination (Orders table).
 *
 * Provides granular searching and filtering the order records across the
 * platform. Enables complex operations such as querying by order status,
 * seller/customer, creation/update timestamps, and supports sorting and
 * paginated data retrieval.
 *
 * Security: Access restricted to administrator and seller roles due to
 * business-sensitive order data. Only fields explicitly present in the
 * underlying Prisma model are filterable or sortable; custom aggregates or
 * derived fields are not included.
 *
 * Best used in analytic reporting, case management back office, or sales review
 * workflows. Errors are handled for invalid filter syntax or unauthorized
 * access. Related APIs allow detail lookup by order ID, order update and
 * cancellation, and order item management.
 *
 * @param props.connection
 * @param props.body Order search/filter and pagination parameters.
 * @path /aimall-backend/administrator/orders
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Order search/filter and pagination parameters. */
    body: IAimallBackendOrder.IRequest;
  };
  export type Body = IAimallBackendOrder.IRequest;
  export type Response = IPageIAimallBackendOrder;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/orders";
  export const random = (): IPageIAimallBackendOrder =>
    typia.random<IPageIAimallBackendOrder>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch a single order's full details by ID (Orders table).
 *
 * Retrieves the complete record for a single order as described by the
 * 'aimall_backend_orders' schema table. Returns all atomic order details
 * including references to customer and address, financial data, and status.
 * Used by seller operations, administrators, or advanced customer service desks
 * to view order details or handle escalations.
 *
 * Access is controlled to prevent unauthorized reads. The API validates the
 * provided orderId format and existence; not found or denied attempts are
 * logged securely. Additional related data (items, payments, shipment) are
 * available in separate, linked endpoints as per normalization best practice.
 *
 * @param props.connection
 * @param props.orderId Unique identifier (UUID) for the order.
 * @path /aimall-backend/administrator/orders/:orderId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) for the order. */
    orderId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendOrder;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IAimallBackendOrder =>
    typia.random<IAimallBackendOrder>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update order details by ID (Orders table).
 *
 * Updates the details of an existing order referred to by the provided UUID,
 * with field-level changes as per the Prisma schema. Only updatable properties
 * (e.g., status, address, total) can be modified. Immutable fields
 * post-archival or fulfillment are enforced by business logic/application.
 *
 * Authorization ensures only the order's owning seller or relevant
 * administrator may update order data. The API validates mutation payloads
 * against business constraints, logs all changes for audit, and rejects
 * disallowed field updates or attempts to modify archived records.
 *
 * @param props.connection
 * @param props.orderId Unique identifier (UUID) for the order to update.
 * @param props.body Order fields to update.
 * @path /aimall-backend/administrator/orders/:orderId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) for the order to update. */
    orderId: string & tags.Format<"uuid">;

    /** Order fields to update. */
    body: IAimallBackendOrder.IUpdate;
  };
  export type Body = IAimallBackendOrder.IUpdate;
  export type Response = IAimallBackendOrder;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/orders/:orderId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IAimallBackendOrder =>
    typia.random<IAimallBackendOrder>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete/archive an order by ID (Orders table).
 *
 * Deletes or archives an existing order based on the provided UUID. If the
 * schema supports soft-delete via 'archived_at', the operation performs a
 * logical deletion by updating this timestamp. Otherwise (if no such field), it
 * removes the record entirely. Deletion is only possible by platform
 * administrators, not by regular customers or sellers, and is prevented on
 * orders already archived or outside allowed deletion windows (e.g., fulfilled
 * orders).
 *
 * Business and security rules enforce detailed audits of all deletions. The
 * operation never removes related records like order items, payments, or
 * shipments, which must be handled by linked processes.
 *
 * @param props.connection
 * @param props.orderId UUID of the order to delete or archive.
 * @path /aimall-backend/administrator/orders/:orderId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the order to delete or archive. */
    orderId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

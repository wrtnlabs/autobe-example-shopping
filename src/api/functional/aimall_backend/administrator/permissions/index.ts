import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAimallBackendPermission } from "../../../../structures/IAimallBackendPermission";
import { IPageIAimallBackendPermission } from "../../../../structures/IPageIAimallBackendPermission";

/**
 * Get full list of RBAC permission role definitions.
 *
 * List all available permission definitions and RBAC roles for platform
 * administrators and sellers, referencing the aimall_backend_permissions table.
 * Each record includes a code (unique), display name, and description. Results
 * may be used in admin UX for role assignment, auditing, or platform policy
 * review.
 *
 * This endpoint is typically accessed by administrators with role/permission
 * management authority. Permissions here can be assigned to new or existing
 * admin accounts (see administrators endpoints for usage). No sensitive data is
 * returned; data is suitable for overview and assignment screens.
 *
 * @param props.connection
 * @path /aimall-backend/administrator/permissions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IAimallBackendPermission.ISummary;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/permissions",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/permissions";
  export const random = (): IAimallBackendPermission.ISummary =>
    typia.random<IAimallBackendPermission.ISummary>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new RBAC permission or role definition.
 *
 * Create a new RBAC permission/role in the platform by supplying a unique code,
 * display_name, and full description as required by the
 * aimall_backend_permissions table. The operation can only be invoked by
 * administrators with sufficient authority (typically super administrator or
 * compliance manager).
 *
 * On success, the full role definition is returned with assigned ID for further
 * use. Role definitions are then available for assignment to administrator or
 * seller accounts via their respective endpoints. Audit logs capture this event
 * for compliance. No direct assignment occurs here—use admin endpoints to
 * assign roles.
 *
 * @param props.connection
 * @param props.body Full detail required for defining new permission: unique
 *   code, display_name, description.
 * @path /aimall-backend/administrator/permissions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Full detail required for defining new permission: unique code,
     * display_name, description.
     */
    body: IAimallBackendPermission.ICreate;
  };
  export type Body = IAimallBackendPermission.ICreate;
  export type Response = IAimallBackendPermission;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/permissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/permissions";
  export const random = (): IAimallBackendPermission =>
    typia.random<IAimallBackendPermission>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and filter RBAC roles and permissions with flexible criteria.
 *
 * Search, filter, and paginate the list of platform RBAC permission
 * definitions, using request body criteria as supported by columns in
 * aimall_backend_permissions. Filters include permission code strings,
 * display/display_name searches, or audit timestamp ranges. This supports
 * compliance and multi-tenant system management where granularity of role
 * definition and assignment is critical.
 *
 * Only available to staff with permission management authority (see
 * administrators endpoints). Typically used by UX components that enable admins
 * to find/create/assign roles efficiently.
 *
 * @param props.connection
 * @param props.body Filter and pagination parameters for RBAC permission and
 *   role definitions.
 * @path /aimall-backend/administrator/permissions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Filter and pagination parameters for RBAC permission and role
     * definitions.
     */
    body: IAimallBackendPermission.IRequest;
  };
  export type Body = IAimallBackendPermission.IRequest;
  export type Response = IPageIAimallBackendPermission.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/permissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/permissions";
  export const random = (): IPageIAimallBackendPermission.ISummary =>
    typia.random<IPageIAimallBackendPermission.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get RBAC role/permission detail by id (Actors domain).
 *
 * Get full configuration for a single RBAC permission/role, identified by
 * permissionId path parameter, from aimall_backend_permissions. This model
 * exposes all fields for compliance auditing and UX display. Used in admin
 * dashboards for editing or reviewing role definitions. PermissionId must be a
 * valid UUID; error if not found. Only authorized staff may invoke this
 * endpoint.
 *
 * No assignment information is included here—join against the admins table if
 * needed for current assignments.
 *
 * @param props.connection
 * @param props.permissionId Unique identifier of the permission/role record
 *   (UUID).
 * @path /aimall-backend/administrator/permissions/:permissionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the permission/role record (UUID). */
    permissionId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendPermission;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/permissions/:permissionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/permissions/${encodeURIComponent(props.permissionId ?? "null")}`;
  export const random = (): IAimallBackendPermission =>
    typia.random<IAimallBackendPermission>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("permissionId")(() => typia.assert(props.permissionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update RBAC role/permission definition (Actors domain).
 *
 * Update metadata for an RBAC permission or role definition, by permissionId
 * (UUID) in the aimall_backend_permissions table. Allows modifications to
 * display_name and description, and optionally to code for cases of role
 * renaming (subject to business constraints). All changes are strictly logged
 * for compliance.
 *
 * Invoke this when refining system roles, updating compliance documentation, or
 * extending the platform’s permission model. Result returns the modified
 * role/permission for UX update or further assignment decisions.
 *
 * @param props.connection
 * @param props.permissionId Unique identifier of the permission/role to update
 *   (UUID).
 * @param props.body Fields to update for this RBAC permission definition: code
 *   (if needed), display_name, description.
 * @path /aimall-backend/administrator/permissions/:permissionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the permission/role to update (UUID). */
    permissionId: string & tags.Format<"uuid">;

    /**
     * Fields to update for this RBAC permission definition: code (if
     * needed), display_name, description.
     */
    body: IAimallBackendPermission.IUpdate;
  };
  export type Body = IAimallBackendPermission.IUpdate;
  export type Response = IAimallBackendPermission;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/permissions/:permissionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/permissions/${encodeURIComponent(props.permissionId ?? "null")}`;
  export const random = (): IAimallBackendPermission =>
    typia.random<IAimallBackendPermission>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("permissionId")(() => typia.assert(props.permissionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an RBAC permission or role (hard delete, irreversible).
 *
 * Permanently delete a RBAC permission or role definition from the platform by
 * permissionId (UUID), as there is no soft-delete or is_deleted field in the
 * aimall_backend_permissions schema. Use with extreme caution—removal will
 * result in unassigned state for any accounts currently mapped to this
 * permission. This action cannot be reversed. All actions are fully logged by
 * the audit mechanism.
 *
 * Do not use this endpoint for temporary suspension/blocking—modify assignments
 * on accounts instead. Confirmation is expected prior to irreversible
 * operations.
 *
 * @param props.connection
 * @param props.permissionId Unique identifier of the permission/role to delete
 *   (UUID).
 * @path /aimall-backend/administrator/permissions/:permissionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the permission/role to delete (UUID). */
    permissionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/permissions/:permissionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/permissions/${encodeURIComponent(props.permissionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("permissionId")(() => typia.assert(props.permissionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

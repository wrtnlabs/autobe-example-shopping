import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendChannelAssignment } from "../../../../../structures/IPageIAimallBackendChannelAssignment";
import { IAimallBackendChannelAssignment } from "../../../../../structures/IAimallBackendChannelAssignment";

/**
 * List all channel assignments for a specified product
 * (aimall_backend_channel_assignments).
 *
 * This API returns a complete list of all channel assignments for the specified
 * product, as recorded in the aimall_backend_channel_assignments table. Each
 * record fully details the relationship between the product and its configured
 * channels, including assignment timestamps and associated channel metadata.
 *
 * Role-based access ensures only authenticated sellers and administrators can
 * view this distribution mapping. Sellers will only access their own product
 * assignments. The operation is integral for maintaining and troubleshooting
 * product visibility across sales channels. Error responses will occur if the
 * product does not exist or if access permissions are insufficient.
 *
 * This endpoint is usually paired with the POST operation for assignment
 * creation and the GET with channelAssignmentId for detail views.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the target product.
 * @path /aimall-backend/administrator/products/:productId/channelAssignments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the target product. */
    productId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIAimallBackendChannelAssignment;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/products/:productId/channelAssignments",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/products/${encodeURIComponent(props.productId ?? "null")}/channelAssignments`;
  export const random = (): IPageIAimallBackendChannelAssignment =>
    typia.random<IPageIAimallBackendChannelAssignment>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a channel assignment for a product (register product to channel).
 *
 * This endpoint allows sellers or administrators to assign a product to a new
 * channel, registering it for listing or management purposes on that platform.
 * It creates a new aimall_backend_channel_assignments record linking the
 * specified product to the desired channel and records the assignment
 * timestamp.
 *
 * Input validation ensures that the referenced product and channel are valid
 * and not already assigned together. Access control restricts creation to
 * sellers (for their own products) and administrators. Duplicate assignment is
 * prevented by the unique constraint in the schema.
 *
 * Upon successful creation, the full assignment record is returned. Errors are
 * thrown for invalid or duplicate requests, or on insufficient permission.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the target product for the
 *   assignment.
 * @param props.body Input data defining the new channel assignment (channelId,
 *   assigned_at, etc).
 * @path /aimall-backend/administrator/products/:productId/channelAssignments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the target product for the assignment. */
    productId: string & tags.Format<"uuid">;

    /**
     * Input data defining the new channel assignment (channelId,
     * assigned_at, etc).
     */
    body: IAimallBackendChannelAssignment.ICreate;
  };
  export type Body = IAimallBackendChannelAssignment.ICreate;
  export type Response = IAimallBackendChannelAssignment;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/products/:productId/channelAssignments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/products/${encodeURIComponent(props.productId ?? "null")}/channelAssignments`;
  export const random = (): IAimallBackendChannelAssignment =>
    typia.random<IAimallBackendChannelAssignment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Advanced search for paginated channel assignments for a specified product.
 *
 * Retrieve a paginated, filtered list of channel assignments associated with a
 * specific product. Powered by the aimall_backend_channel_assignments model,
 * this endpoint supports advanced queries—such as filtering by channel ID, date
 * assigned, or channel code/name—as well as sorting and pagination.
 *
 * Sellers and administrators can efficiently search and audit channel exposure
 * history for a product. Search criteria and pagination details are provided in
 * the request body. Appropriate access control ensures sellers can see only
 * their own products. Error responses may occur if the product does not exist
 * or due to insufficient permissions.
 *
 * Pair with the GET endpoint for full listings or use to drill down by search
 * parameters before accessing detail or modification endpoints.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the target product.
 * @param props.body Search criteria and pagination/filtering parameters for
 *   querying product channel assignments.
 * @path /aimall-backend/administrator/products/:productId/channelAssignments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Unique identifier of the target product. */
    productId: string & tags.Format<"uuid">;

    /**
     * Search criteria and pagination/filtering parameters for querying
     * product channel assignments.
     */
    body: IAimallBackendChannelAssignment.IRequest;
  };
  export type Body = IAimallBackendChannelAssignment.IRequest;
  export type Response = IPageIAimallBackendChannelAssignment;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/products/:productId/channelAssignments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/products/${encodeURIComponent(props.productId ?? "null")}/channelAssignments`;
  export const random = (): IPageIAimallBackendChannelAssignment =>
    typia.random<IPageIAimallBackendChannelAssignment>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch single channel assignment detail for a product by channelAssignmentId.
 *
 * Fetches the full detail of a single channel assignment for a product,
 * uniquely identified by channelAssignmentId. The information includes all
 * atomic fields within the aimall_backend_channel_assignments schema, such as
 * timestamps and the reference links to the associated product and channel.
 *
 * This endpoint should be accessed by sellers and administrators with access to
 * the product. Useful for assignment audits, compliance validation, or
 * troubleshooting issues when products are not visible on expected channels.
 * Enforces role-based security and validates ownership/permissions.
 *
 * Related endpoints are the list and search endpoints for channel assignments,
 * and the modification endpoints for edit or deletion.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product the assignment
 *   belongs to.
 * @param props.channelAssignmentId Unique identifier of the target channel
 *   assignment record.
 * @path /aimall-backend/administrator/products/:productId/channelAssignments/:channelAssignmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the product the assignment belongs to. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the target channel assignment record. */
    channelAssignmentId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendChannelAssignment;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/products/:productId/channelAssignments/:channelAssignmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/products/${encodeURIComponent(props.productId ?? "null")}/channelAssignments/${encodeURIComponent(props.channelAssignmentId ?? "null")}`;
  export const random = (): IAimallBackendChannelAssignment =>
    typia.random<IAimallBackendChannelAssignment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("channelAssignmentId")(() =>
        typia.assert(props.channelAssignmentId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a channel assignment for a product; by channelAssignmentId.
 *
 * This endpoint updates an existing channel assignment for the given product,
 * modifying one or more of the assignment's attributes (such as assignment
 * timestamp or, in future schema versions, other metadata fields). The targeted
 * record is located by channelAssignmentId, and access is controlled by
 * seller/administrator role and product ownership.
 *
 * Allows correction of errors, audit adjustments, or operational reassignment
 * when business requirements change. The updated record is returned upon
 * success. Validation includes verifying product and assignment existence,
 * assignment relationship, and access rights. Errors cover
 * non-existent/unauthorized edits or validation failures.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the target product.
 * @param props.channelAssignmentId Unique identifier of the channel assignment
 *   to update.
 * @param props.body Fields to update in the channel assignment record.
 * @path /aimall-backend/administrator/products/:productId/channelAssignments/:channelAssignmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target product. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the channel assignment to update. */
    channelAssignmentId: string & tags.Format<"uuid">;

    /** Fields to update in the channel assignment record. */
    body: IAimallBackendChannelAssignment.IUpdate;
  };
  export type Body = IAimallBackendChannelAssignment.IUpdate;
  export type Response = IAimallBackendChannelAssignment;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/products/:productId/channelAssignments/:channelAssignmentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/products/${encodeURIComponent(props.productId ?? "null")}/channelAssignments/${encodeURIComponent(props.channelAssignmentId ?? "null")}`;
  export const random = (): IAimallBackendChannelAssignment =>
    typia.random<IAimallBackendChannelAssignment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("channelAssignmentId")(() =>
        typia.assert(props.channelAssignmentId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (hard remove) a channel assignment for a product by
 * channelAssignmentId.
 *
 * This operation permanently deletes a channel assignment for a product,
 * breaking the link between the product and the specified sales/distribution
 * channel. This operates as a hard delete, in accordance with the
 * aimall_backend_channel_assignments schema, which does not include any
 * soft-delete fields (such as deleted_at).
 *
 * Sellers are restricted to deleting assignments for their own products and
 * channels. Administrators may delete any assignment. Deletion is irreversible
 * and should be done with caution. Errors will be returned if the record
 * doesn’t exist or the user lacks permissions.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product involved in the
 *   assignment.
 * @param props.channelAssignmentId Unique identifier of the assignment to
 *   delete.
 * @path /aimall-backend/administrator/products/:productId/channelAssignments/:channelAssignmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the product involved in the assignment. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the assignment to delete. */
    channelAssignmentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/products/:productId/channelAssignments/:channelAssignmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/products/${encodeURIComponent(props.productId ?? "null")}/channelAssignments/${encodeURIComponent(props.channelAssignmentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("channelAssignmentId")(() =>
        typia.assert(props.channelAssignmentId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

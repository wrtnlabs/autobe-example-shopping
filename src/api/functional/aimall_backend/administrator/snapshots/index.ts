import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendSnapshot } from "../../../../structures/IPageIAimallBackendSnapshot";
import { IAimallBackendSnapshot } from "../../../../structures/IAimallBackendSnapshot";

/**
 * Get a paginated list of all community snapshots (aimall_backend_snapshots
 * table).
 *
 * Lists all snapshot media entries stored in the community context, such as
 * images or videos tagged to posts or products. Returns paginated snapshot
 * metadata only (e.g., media URI, caption, associated product/post/customer,
 * and timestamps).
 *
 * This operation serves admin dashboards and analytics views that require
 * enumerating social moments but not necessarily retrieving the media itself.
 * Result set is paginated and can be sorted. Only authorized users may retrieve
 * society media records due to privacy concerns.
 *
 * @param props.connection
 * @path /aimall-backend/administrator/snapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIAimallBackendSnapshot;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/snapshots",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/snapshots";
  export const random = (): IPageIAimallBackendSnapshot =>
    typia.random<IPageIAimallBackendSnapshot>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new community snapshot record (registering image/video to social
 * context).
 *
 * Creates a new snapshot entry for the community context with provided media
 * URI, caption, and linkage fields (e.g., product_id, post_id, customer_id).
 * Uses the IAimallBackendSnapshot.ICreate DTO shape for atomic properties, as
 * defined by the schema.
 *
 * After the file is uploaded and reference created, the system persists the
 * logical connection between the snapshot and associated entities. This
 * facilitates timeline feeds and social features. Only metadata, not media, is
 * handled.
 *
 * @param props.connection
 * @param props.body Snapshot creation data: media URI reference, optional
 *   caption, associations.
 * @path /aimall-backend/administrator/snapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Snapshot creation data: media URI reference, optional caption,
     * associations.
     */
    body: IAimallBackendSnapshot.ICreate;
  };
  export type Body = IAimallBackendSnapshot.ICreate;
  export type Response = IAimallBackendSnapshot;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/snapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/snapshots";
  export const random = (): IAimallBackendSnapshot =>
    typia.random<IAimallBackendSnapshot>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and filter community snapshots by metadata for moderation/analytics.
 *
 * Search and retrieve filtered/paginated snapshot (media) records matching
 * advanced search parameters. Uses the request DTO
 * IAimallBackendSnapshot.IRequest for flexible filter criteria (by media_uri,
 * caption, product_id, post_id, customer_id, or date interval).
 *
 * This endpoint supports analytic dashboards, content moderation workflows, and
 * compliance-friendly record lookups. Only defined atomic fields in the
 * aimall_backend_snapshots schema may be used as criteria.
 *
 * @param props.connection
 * @param props.body Snapshot filter/search and pagination/sorting options per
 *   request DTO.
 * @path /aimall-backend/administrator/snapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Snapshot filter/search and pagination/sorting options per request
     * DTO.
     */
    body: IAimallBackendSnapshot.IRequest;
  };
  export type Body = IAimallBackendSnapshot.IRequest;
  export type Response = IPageIAimallBackendSnapshot;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/snapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/snapshots";
  export const random = (): IPageIAimallBackendSnapshot =>
    typia.random<IPageIAimallBackendSnapshot>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get metadata for a specific snapshot by snapshotId from
 * aimall_backend_snapshots.
 *
 * Fetch the media snapshot record for a single snapshotId from
 * aimall_backend_snapshots. Returns metadata such as media URI, caption,
 * relationships, and timestamps as defined in the schema.
 *
 * This is frequently used in moderation workflows, audit logs, and analytic
 * deep-dives. Media content is not returned; only metadata is delivered.
 * Role-based access enforcement applies.
 *
 * @param props.connection
 * @param props.snapshotId UUID of the snapshot record to retrieve (primary
 *   key).
 * @path /aimall-backend/administrator/snapshots/:snapshotId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the snapshot record to retrieve (primary key). */
    snapshotId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendSnapshot;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/snapshots/:snapshotId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/snapshots/${encodeURIComponent(props.snapshotId ?? "null")}`;
  export const random = (): IAimallBackendSnapshot =>
    typia.random<IAimallBackendSnapshot>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("snapshotId")(() => typia.assert(props.snapshotId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update mutable metadata for a specific snapshot record by snapshotId.
 *
 * Fully update metadata for a specified community snapshot given by snapshotId,
 * using new values from IAimallBackendSnapshot.IUpdate (i.e., media URI,
 * caption, and entity references).
 *
 * This is used to correct or reassign social moments, moderate captions, or
 * relink a snapshot to another community entity. Media files themselves are not
 * changed by this call. Administrative privileges are required for such
 * updates.
 *
 * @param props.connection
 * @param props.snapshotId UUID of the snapshot to update.
 * @param props.body DTO containing updated snapshot metadata and link
 *   references.
 * @path /aimall-backend/administrator/snapshots/:snapshotId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the snapshot to update. */
    snapshotId: string & tags.Format<"uuid">;

    /** DTO containing updated snapshot metadata and link references. */
    body: IAimallBackendSnapshot.IUpdate;
  };
  export type Body = IAimallBackendSnapshot.IUpdate;
  export type Response = IAimallBackendSnapshot;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/snapshots/:snapshotId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/snapshots/${encodeURIComponent(props.snapshotId ?? "null")}`;
  export const random = (): IAimallBackendSnapshot =>
    typia.random<IAimallBackendSnapshot>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("snapshotId")(() => typia.assert(props.snapshotId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Hard delete a community snapshot record by snapshotId (no soft delete
 * present).
 *
 * Permanently removes a snapshot metadata record from aimall_backend_snapshots
 * by snapshotId (UUID). Use cases include removing inappropriate or requested
 * content, compliance-related deletions, or moderation. Access control is
 * strict, and the operation is irreversible from the API perspective.
 *
 * Actual media content deletion must be handled via file management system
 * separately. Use is expected to be rare and heavily logged.
 *
 * @param props.connection
 * @param props.snapshotId UUID of the snapshot to be deleted.
 * @path /aimall-backend/administrator/snapshots/:snapshotId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the snapshot to be deleted. */
    snapshotId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/snapshots/:snapshotId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/snapshots/${encodeURIComponent(props.snapshotId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("snapshotId")(() => typia.assert(props.snapshotId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

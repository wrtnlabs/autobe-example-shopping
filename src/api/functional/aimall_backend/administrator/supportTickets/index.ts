import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendSupportTicket } from "../../../../structures/IPageIAimallBackendSupportTicket";
import { IAimallBackendSupportTicket } from "../../../../structures/IAimallBackendSupportTicket";

/**
 * List or paginate support tickets for authorized viewer, using normalized
 * schema fields.
 *
 * Retrieve a paginated, optionally filtered list of all support tickets in the
 * system, as defined in the aimall_backend_support_tickets model. This
 * operation enables general ticket queue views, backlog analysis, and listing
 * personal or platform-incoming support queries.
 *
 * Access is role-controlled. Customers only see their own tickets. Sellers
 * might view ones they opened, administrators can list and search all tickets
 * for triage, reporting, and assignment. Ticket data includes subject, body,
 * priority, status, requester (with minimal user details), assignee,
 * timestamps, and category.
 *
 * The listing supports pagination and sorting via query params (not reflected
 * as path parameters here, but in implementation via request/query body or
 * OpenAPI). Backend logic should ensure result size limits and rate limiting.
 * The endpoint also allows for auditor queries and compliance review but never
 * exposes hidden ticket content out of scope for user role.
 *
 * Related operations: PATCH for advanced filtering, GET by ID for details.
 *
 * @param props.connection
 * @path /aimall-backend/administrator/supportTickets
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIAimallBackendSupportTicket;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/supportTickets",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/supportTickets";
  export const random = (): IPageIAimallBackendSupportTicket =>
    typia.random<IPageIAimallBackendSupportTicket>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create and submit a new support ticket.
 *
 * Initiate a new support ticket entry in the system. This creates a record
 * according to the aimall_backend_support_tickets schema with validated
 * requester, subject, detailed body, status, priority, category, and assignment
 * (if any).
 *
 * The endpoint enforces role-based checks: customers may open tickets about
 * their own issues; sellers and administrators can report business/system
 * incidents. Audit logging and full field validation ensures traceability for
 * support and compliance.
 *
 * The returned record includes the full ticket after creation, including
 * server-generated timestamps and unique ID.
 *
 * @param props.connection
 * @param props.body All required fields for support ticket creation, with
 *   validation as per schema.
 * @path /aimall-backend/administrator/supportTickets
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * All required fields for support ticket creation, with validation as
     * per schema.
     */
    body: IAimallBackendSupportTicket.ICreate;
  };
  export type Body = IAimallBackendSupportTicket.ICreate;
  export type Response = IAimallBackendSupportTicket;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/administrator/supportTickets",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/supportTickets";
  export const random = (): IAimallBackendSupportTicket =>
    typia.random<IAimallBackendSupportTicket>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Complex search/filter for support tickets with advanced criteria support.
 *
 * Advanced search operation for support tickets with filtering, keyword search,
 * pagination, and sorting. Allows querying on status (open, pending, resolved,
 * closed), priorities, requester, assigned administrator, categories, and time
 * intervals. Implementation leverages Prisma schema fields with zero
 * denormalization, ensuring search relates to atomic record data only.
 *
 * Customers may search their own history; administrators and support staff can
 * filter entire system's queue. The response is strictly limited to data the
 * requester is permitted to view per their role and ticket ownership, enforcing
 * ABAC at all times.
 *
 * Business logic includes full access logging for compliance and throttling to
 * avoid denial-of-service patterns.
 *
 * @param props.connection
 * @param props.body Support ticket search and filtering parameters (status,
 *   priority, requestor, date).
 * @path /aimall-backend/administrator/supportTickets
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Support ticket search and filtering parameters (status, priority,
     * requestor, date).
     */
    body: IAimallBackendSupportTicket.IRequest;
  };
  export type Body = IAimallBackendSupportTicket.IRequest;
  export type Response = IPageIAimallBackendSupportTicket;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/administrator/supportTickets",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/administrator/supportTickets";
  export const random = (): IPageIAimallBackendSupportTicket =>
    typia.random<IPageIAimallBackendSupportTicket>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a specific support ticket by ID with all schema properties.
 *
 * Retrieve detailed information for an individual support ticket using its
 * UUID. This exposes all schema-compliant ticket record attributes, including
 * subject, body, status, priority, requester, assignee, category, audit
 * timestamps, and current workflow state.
 *
 * Access is restricted to the requester (who opened the ticket), the assigned
 * administrator, or platform administrators with appropriate permissions. No
 * ticket data outside user roles is disclosed. Role-based content filtering
 * protects sensitive information.
 *
 * Related: use POST for creation, PUT for update, DELETE for closing/removing
 * tickets.
 *
 * @param props.connection
 * @param props.supportTicketId Unique identifier (UUID) for the support ticket
 *   to retrieve.
 * @path /aimall-backend/administrator/supportTickets/:supportTicketId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) for the support ticket to retrieve. */
    supportTicketId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendSupportTicket;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/administrator/supportTickets/:supportTicketId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/supportTickets/${encodeURIComponent(props.supportTicketId ?? "null")}`;
  export const random = (): IAimallBackendSupportTicket =>
    typia.random<IAimallBackendSupportTicket>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("supportTicketId")(() =>
        typia.assert(props.supportTicketId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Edit/update a support ticket's fields and workflow assignments.
 *
 * Edit the details of a support ticket, including subject, body, status,
 * priority, category, and assigned administrator. Strict field validation is
 * enforced per aimall_backend_support_tickets schema. Ticket owner (customer)
 * can update issue description; administrators/support agents can update
 * status, assignment, and internal notes as allowed by business rules.
 *
 * Operation is fully audit-logged for compliance, and role-based masking is
 * applied where ticket fields are inappropriate for the actor (e.g., assignment
 * only by administrators).
 *
 * Returns the complete ticket data after update for confirmation and
 * transparency.
 *
 * @param props.connection
 * @param props.supportTicketId Target support ticket's UUID.
 * @param props.body Ticket fields allowed for update (may be partial per
 *   business rules).
 * @path /aimall-backend/administrator/supportTickets/:supportTicketId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target support ticket's UUID. */
    supportTicketId: string & tags.Format<"uuid">;

    /** Ticket fields allowed for update (may be partial per business rules). */
    body: IAimallBackendSupportTicket.IUpdate;
  };
  export type Body = IAimallBackendSupportTicket.IUpdate;
  export type Response = IAimallBackendSupportTicket;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/administrator/supportTickets/:supportTicketId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/administrator/supportTickets/${encodeURIComponent(props.supportTicketId ?? "null")}`;
  export const random = (): IAimallBackendSupportTicket =>
    typia.random<IAimallBackendSupportTicket>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("supportTicketId")(() =>
        typia.assert(props.supportTicketId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a support ticket by ID (hard delete, no soft deletion).
 *
 * Delete a support ticket by its UUID. This is a hard deletion due to absence
 * of soft-delete field in Prisma schema - once removed, the record cannot be
 * restored. Operation is allowed for ticket owners or administrators per
 * platform policy.
 *
 * Audit log is created for traceability. Business logic may block deletion of
 * tickets still pending action or escalated for compliance reasons. Role
 * verification is mandatory before execution.
 *
 * @param props.connection
 * @param props.supportTicketId UUID for the ticket to be deleted.
 * @path /aimall-backend/administrator/supportTickets/:supportTicketId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID for the ticket to be deleted. */
    supportTicketId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/administrator/supportTickets/:supportTicketId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/administrator/supportTickets/${encodeURIComponent(props.supportTicketId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("supportTicketId")(() =>
        typia.assert(props.supportTicketId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

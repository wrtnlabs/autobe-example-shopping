import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendComment } from "../../../../../structures/IPageIAimallBackendComment";
import { IAimallBackendComment } from "../../../../../structures/IAimallBackendComment";

/**
 * Get all child comments under a parent comment (thread expansion).
 *
 * This endpoint retrieves the direct replies (child comments) to a specific
 * parent comment as identified by 'commentId' in the aimall_backend_comments
 * schema. Each returned comment includes relevant atomic properties such as id,
 * body, customer_id, created_at, updated_at, is_private, and parent_id. The
 * system filters out any comments with non-null deleted_at, ensuring only
 * active/visible comments are listed.
 *
 * Access to replies may depend on thread privacy (is_private field) and the
 * authorization role of the requesting user. Customers can see their own
 * comments and public threads; administrators may review hidden/private
 * comments for moderation purposes. The endpoint builds fully on the
 * 'parent_id' foreign key to allow recursive thread expansion in community
 * features.
 *
 * Sorting and pagination are implementation-dependent (e.g., page/limit/query
 * params) and expected to be supported for UX scalability. Errors such as
 * comment not found, access denied, or invalid UUID are handled gracefully with
 * informative messages. Behavior aligns with audit, compliance, and privacy
 * logic described in the community requirements.
 *
 * @param props.connection
 * @param props.commentId The UUID of the parent comment whose child comments
 *   are to be retrieved.
 * @path /aimall-backend/customer/comments/:commentId/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /**
     * The UUID of the parent comment whose child comments are to be
     * retrieved.
     */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIAimallBackendComment;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/customer/comments/:commentId/comments",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/customer/comments/${encodeURIComponent(props.commentId ?? "null")}/comments`;
  export const random = (): IPageIAimallBackendComment =>
    typia.random<IPageIAimallBackendComment>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new reply (child comment) under a parent comment (nested thread).
 *
 * Creates a new comment record as a direct reply to the comment identified by
 * commentId. Input includes body, is_private (privacy control), and implicit
 * authoring based on authentication. The resulting comment record has parent_id
 * set to commentId and populates all standard comment fields as defined in the
 * aimall_backend_comments schema.
 *
 * Soft deletion is not applied on creation. The system ensures correct thread
 * hierarchy for community UX, and only authenticated users may create replies.
 * Error scenarios (parent not found, thread closed) are handled per business
 * rules. Created_at and updated_at are set to current time. On success, returns
 * the created comment object including ID and relevant metadata.
 *
 * @param props.connection
 * @param props.commentId The UUID of the parent comment to which the reply will
 *   be attached.
 * @param props.body Details of the new reply (body, privacy, optional display
 *   info).
 * @path /aimall-backend/customer/comments/:commentId/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** The UUID of the parent comment to which the reply will be attached. */
    commentId: string & tags.Format<"uuid">;

    /** Details of the new reply (body, privacy, optional display info). */
    body: IAimallBackendComment.ICreate;
  };
  export type Body = IAimallBackendComment.ICreate;
  export type Response = IAimallBackendComment;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/customer/comments/:commentId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/customer/comments/${encodeURIComponent(props.commentId ?? "null")}/comments`;
  export const random = (): IAimallBackendComment =>
    typia.random<IAimallBackendComment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Advanced search and filter for child comments under a given parent comment.
 *
 * Enables advanced search and paginated results for comments where 'parent_id'
 * is the given commentId. The request supports filtering by author
 * (customer_id), creation timestamp, privacy (is_private), and free-text in
 * body. Optional input can include sorting preference and pagination controls
 * (page number, page size).
 *
 * This endpoint supports both user-facing and admin-facing scenarios. Customers
 * receive search/filter functions scoped to their own accessible data;
 * administrators can apply broad filters for content moderation or audit
 * purposes. Soft-deleted comments (deleted_at not null) are always excluded
 * from result sets to align with compliance mandates.
 *
 * Error handling includes validation of UUID, inappropriate parameter values,
 * or unauthorized access to private comments. The behavior supports integration
 * into UI comment management and admin dashboards as described in the system
 * requirements.
 *
 * @param props.connection
 * @param props.commentId The UUID of the parent comment whose child comments
 *   are to be searched.
 * @param props.body Search and filter criteria for finding child comments
 *   (author, privacy, date, keyword, pagination).
 * @path /aimall-backend/customer/comments/:commentId/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * The UUID of the parent comment whose child comments are to be
     * searched.
     */
    commentId: string & tags.Format<"uuid">;

    /**
     * Search and filter criteria for finding child comments (author,
     * privacy, date, keyword, pagination).
     */
    body: IAimallBackendComment.IRequest;
  };
  export type Body = IAimallBackendComment.IRequest;
  export type Response = IPageIAimallBackendComment;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/customer/comments/:commentId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/customer/comments/${encodeURIComponent(props.commentId ?? "null")}/comments`;
  export const random = (): IPageIAimallBackendComment =>
    typia.random<IPageIAimallBackendComment>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single specific reply under a parent comment (thread node lookup).
 *
 * Retrieves a single child comment under a given parent comment. The lookup
 * first verifies the existence of the parent comment and then finds the child
 * comment whose id matches the provided childCommentId and whose parent_id
 * matches commentId. Returned fields include id, parent_id, post_id, review_id,
 * customer_id, body, is_private, created_at, updated_at. Soft-deleted comments
 * (deleted_at not null) are excluded from result.
 *
 * Access control ensures only the author (customer), relevant participants, or
 * administrators can see private or restricted comments. This endpoint aligns
 * with business logic requiring strict parent-child thread integrity for all
 * comment retrievals. Error handling includes not found (if either comment does
 * not exist or does not match hierarchy), unauthorized, or soft-deleted
 * return.
 *
 * @param props.connection
 * @param props.commentId The UUID of the parent comment.
 * @param props.childCommentId The UUID of the child comment to retrieve.
 * @path /aimall-backend/customer/comments/:commentId/comments/:childCommentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The UUID of the parent comment. */
    commentId: string & tags.Format<"uuid">;

    /** The UUID of the child comment to retrieve. */
    childCommentId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendComment;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/customer/comments/:commentId/comments/:childCommentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/customer/comments/${encodeURIComponent(props.commentId ?? "null")}/comments/${encodeURIComponent(props.childCommentId ?? "null")}`;
  export const random = (): IAimallBackendComment =>
    typia.random<IAimallBackendComment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("childCommentId")(() => typia.assert(props.childCommentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Edit a reply (child comment) under a parent comment (atomic field update).
 *
 * Allows the author or a privileged moderator (admin) to edit the body or
 * privacy status of a reply (child comment) identified by childCommentId under
 * the specified parent comment. Edits update only atomic (non-relational)
 * comment fields; parent_id and thread integrity cannot be changed here. Only
 * active, non-deleted comments can be edited. The system updates updated_at for
 * each modification.
 *
 * This operation aligns with UX needs for comment editing and transparency, and
 * supports audit-compliance by tracking changes to content. Unauthorized edit
 * attempts or edits to soft-deleted comments return an error. The endpoint does
 * not support creating, deleting, or reparenting comments.
 *
 * @param props.connection
 * @param props.commentId UUID of the parent comment (thread being replied to).
 * @param props.childCommentId UUID of the child comment to update.
 * @param props.body Fields to update on the reply (comment body, privacy, etc).
 * @path /aimall-backend/customer/comments/:commentId/comments/:childCommentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the parent comment (thread being replied to). */
    commentId: string & tags.Format<"uuid">;

    /** UUID of the child comment to update. */
    childCommentId: string & tags.Format<"uuid">;

    /** Fields to update on the reply (comment body, privacy, etc). */
    body: IAimallBackendComment.IUpdate;
  };
  export type Body = IAimallBackendComment.IUpdate;
  export type Response = IAimallBackendComment;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/customer/comments/:commentId/comments/:childCommentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/customer/comments/${encodeURIComponent(props.commentId ?? "null")}/comments/${encodeURIComponent(props.childCommentId ?? "null")}`;
  export const random = (): IAimallBackendComment =>
    typia.random<IAimallBackendComment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("childCommentId")(() => typia.assert(props.childCommentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a reply (child comment) under a thread (set deleted_at).
 *
 * Performs soft deletion of a reply under a parent comment thread, following
 * audit and compliance requirements. The system sets deleted_at for the
 * specified childCommentId (only if its parent_id matches the specified parent
 * commentId), rather than removing the row. Access control ensures only the
 * author or a platform administrator can delete. Soft-deleted comments are
 * hidden in regular query results but persist for audit trace and restoration
 * windows.
 *
 * Error handling includes invalid IDs, non-existent parent/child, or attempts
 * to delete already-deleted comments. No comment body or data is lost, aligning
 * with policy for GDPR compliance and community governance.
 *
 * @param props.connection
 * @param props.commentId UUID of the parent comment thread.
 * @param props.childCommentId UUID of the child comment to be soft-deleted.
 * @path /aimall-backend/customer/comments/:commentId/comments/:childCommentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the parent comment thread. */
    commentId: string & tags.Format<"uuid">;

    /** UUID of the child comment to be soft-deleted. */
    childCommentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/customer/comments/:commentId/comments/:childCommentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/customer/comments/${encodeURIComponent(props.commentId ?? "null")}/comments/${encodeURIComponent(props.childCommentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("childCommentId")(() => typia.assert(props.childCommentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

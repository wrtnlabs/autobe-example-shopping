import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAimallBackendReview } from "../../../../structures/IAimallBackendReview";
import { IPageIAimallBackendReview } from "../../../../structures/IPageIAimallBackendReview";
export * as comments from "./comments";
export * as attachments from "./attachments";
export * as snapshots from "./snapshots";

/**
 * Submit a new product review (customer feedback, rating, UX).
 *
 * Registers a new review entry as defined in the aimall_backend_reviews schema.
 * The creation logic enforces uniqueness on (customer_id, product_id) to block
 * duplicate reviews for the same order/event, and respects rating requirements
 * (integer, 1-5). The required input includes product_id, title, body, rating;
 * the authoring customer is resolved from authentication.
 *
 * The created review will be associated with a product and the logged-in
 * customer. Admin-side, the record can be updated, soft-deleted, or commented
 * on by others where allowed by policy. Timestamps created_at, updated_at
 * filled now. Validation ensures all required schema fields are atomic and
 * present.
 *
 * @param props.connection
 * @param props.body Required data to create a product review (product_id,
 *   title, body, rating).
 * @path /aimall-backend/customer/reviews
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Required data to create a product review (product_id, title, body,
     * rating).
     */
    body: IAimallBackendReview.ICreate;
  };
  export type Body = IAimallBackendReview.ICreate;
  export type Response = IAimallBackendReview;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/customer/reviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/customer/reviews";
  export const random = (): IAimallBackendReview =>
    typia.random<IAimallBackendReview>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Advanced review search/filter for moderation, analytics, or user dashboard.
 *
 * Allows searching for reviews using complex criteria such as reviewer
 * identity, product, rating range, creation or update date ranges, and
 * full-text in title/body, via a request body aligned with
 * IAimallBackendReview.IRequest. The returned list is paginated and sorted per
 * request. Access may be role-dependent: customers are scoped to their own
 * reviews; sellers/admins have wider access as per RBAC. All soft-deleted rows
 * (i.e., deleted_at not null) are excluded from the normal result set.
 *
 * Designed for moderation panels, seller dashboards, and personalized customer
 * review view. Behavior closely follows Prisma schema (atomic only, no
 * denormalized aggregates).
 *
 * @param props.connection
 * @param props.body Search and pagination filter criteria for reviews.
 * @path /aimall-backend/customer/reviews
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Search and pagination filter criteria for reviews. */
    body: IAimallBackendReview.IRequest;
  };
  export type Body = IAimallBackendReview.IRequest;
  export type Response = IPageIAimallBackendReview.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/customer/reviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/customer/reviews";
  export const random = (): IPageIAimallBackendReview.ISummary =>
    typia.random<IPageIAimallBackendReview.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch a single active product review by unique reviewId.
 *
 * Fetches a single non-soft-deleted review by its reviewId. Returns all
 * essential fields from the aimall_backend_reviews schema: id, product_id,
 * customer_id, title, body, rating, created_at, updated_at, and deleted_at
 * (ensuring null for active records). Reviews with deleted_at set
 * (soft-deleted) are not shown to standard users; administrators may have
 * augmented endpoints for deleted retrieval.
 *
 * Access control applies based on user type: customers can see their own
 * reviews, sellers the reviews for their products, admins any review for
 * moderation. Reference integrity and audit compliance are critical to prevent
 * orphaned lookups, and errors for not found/unauthorized/invalid id are
 * handled as per system requirements.
 *
 * @param props.connection
 * @param props.reviewId The UUID of the review to retrieve.
 * @path /aimall-backend/customer/reviews/:reviewId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The UUID of the review to retrieve. */
    reviewId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendReview;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/customer/reviews/:reviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/customer/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): IAimallBackendReview =>
    typia.random<IAimallBackendReview>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update atomic fields (title/body/rating) on an existing product review.
 *
 * Allows an authenticated customer (author) or admin moderator to edit a
 * submitted product review, modifying attributes such as title, body, and
 * rating. The product_id and customer_id cannot be changed after creation,
 * preserving referential integrity. All changes are tracked by an updated_at
 * timestamp update. Soft-deleted reviews (deleted_at not null) cannot be edited
 * unless access is specifically extended for audit or special recovery.
 *
 * This update follows the ux/business requirements from the schema. Any
 * violation (duplicate, unauthorized, bad input) triggers clear error messages
 * and leaves the review unchanged.
 *
 * @param props.connection
 * @param props.reviewId UUID of the review to update.
 * @param props.body Review update model (title, body, rating only).
 * @path /aimall-backend/customer/reviews/:reviewId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the review to update. */
    reviewId: string & tags.Format<"uuid">;

    /** Review update model (title, body, rating only). */
    body: IAimallBackendReview.IUpdate;
  };
  export type Body = IAimallBackendReview.IUpdate;
  export type Response = IAimallBackendReview;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/customer/reviews/:reviewId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/customer/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): IAimallBackendReview =>
    typia.random<IAimallBackendReview>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a product review by reviewId (set deleted_at timestamp).
 *
 * This endpoint marks a product review as deleted by updating the deleted_at
 * column with the current timestamp for the record identified by reviewId. Soft
 * deletion preserves the data for audit and compliance while hiding it from
 * normal user-facing queries. Only the customer who authored the review or an
 * authorized administrator can invoke this deletion; unauthorized attempts are
 * rejected and logged for security compliance.
 *
 * The operation implements full business logic for soft delete: all result sets
 * exclude rows where deleted_at is not null, and restores are only possible via
 * audit/admin special flows. Hard/physical deletion is never performed via this
 * API endpoint to ensure legal and operational defensibility.
 *
 * @param props.connection
 * @param props.reviewId UUID for the review to be soft-deleted.
 * @path /aimall-backend/customer/reviews/:reviewId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID for the review to be soft-deleted. */
    reviewId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/customer/reviews/:reviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/customer/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

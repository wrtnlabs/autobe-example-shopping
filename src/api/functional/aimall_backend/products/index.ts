import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendProduct } from "../../../structures/IPageIAimallBackendProduct";
import { IAimallBackendProduct } from "../../../structures/IAimallBackendProduct";
export * as productOptions from "./productOptions";

/**
 * Retrieve a paginated list of all products from the product catalog
 * (aimall_backend_products).
 *
 * Retrieve a paginated list of product records from the core product catalog.
 * Products represent central entities for e-commerce and are used to power
 * listing, discovery, and selection workflows—each product maintains atomic
 * fields as per the aimall_backend_products schema, including the title,
 * description, main_thumbnail_uri, status, and references to category and
 * seller.
 *
 * This endpoint is publicly accessible, enabling both authenticated and guest
 * users to retrieve products for general browsing and shopping. Internally, the
 * endpoint interacts with the aimall_backend_products table, aggregating all
 * available or active product entries and providing them in summary or detailed
 * formats, as required by the frontend or integrating systems. The endpoint
 * does not return unpublished, inactive, or deleted records unless so
 * configured.
 *
 * No authentication is strictly required for general product catalog browsing,
 * reflecting common marketplace frontend use cases. However, sensitive or
 * restricted product details (such as cost or supplier information) are
 * excluded from the base response. Associated data, such as product options and
 * inventory, are not included directly, but separate endpoints address those
 * associations. The operation is optimized for speed, and API responses are
 * bounded for pagination and scalability, ensuring performance and compliance
 * with rate-limiting policies.
 *
 * @param props.connection
 * @path /aimall-backend/products
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIAimallBackendProduct;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/products",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/products";
  export const random = (): IPageIAimallBackendProduct =>
    typia.random<IPageIAimallBackendProduct>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Advanced search and filter operation for products (aimall_backend_products)
 * by query and paginated.
 *
 * Search and filter products from the platform catalog by leveraging advanced
 * query and pagination features. This endpoint references the
 * aimall_backend_products model and supports multi-faceted queries, such as
 * category, seller, status, and keyword match against the product title and
 * description.
 *
 * The endpoint is available to any requesting party due to its role in powering
 * product search, advanced discovery, and backoffice product management tools.
 * The request body must conform to the expected DTO schema, encapsulating
 * search terms, filter options, pagination controls, and sorting preferences.
 * Results are strictly limited to normalized, non-deleted products per the
 * schema—sensitive details are withheld from the base response. The endpoint is
 * performance-optimized, enabling scalable product discovery as required by
 * frontend web/mobile layers. Output provides both data and necessary
 * pagination metadata, ensuring complete client handling.
 *
 * @param props.connection
 * @param props.body Filtering and search criteria for product catalog advanced
 *   queries.
 * @path /aimall-backend/products
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Filtering and search criteria for product catalog advanced queries. */
    body: IAimallBackendProduct.IRequest;
  };
  export type Body = IAimallBackendProduct.IRequest;
  export type Response = IPageIAimallBackendProduct;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/products",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aimall-backend/products";
  export const random = (): IPageIAimallBackendProduct =>
    typia.random<IPageIAimallBackendProduct>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full details for a single product by UUID (aimall_backend_products).
 *
 * Retrieve a single product's full details by specifying its unique identifier.
 * The endpoint connects directly to the aimall_backend_products table,
 * returning all normalized, public attributes for the requested product,
 * including title, description, main_thumbnail_uri, seller and category
 * references, product status, and timestamps.
 *
 * The operation is public and does not require authentication, supporting
 * product detail views for customers as well as administrative lookup. Security
 * and business logic ensure that only non-sensitive product data is returned,
 * and only for products that are not deleted. Requests for non-existent or
 * unauthorized products return appropriate error codes. Supplementary product
 * data, like options and inventory, can be accessed via related endpoints.
 *
 * Endpoint performance and error handling are robust, ensuring high
 * availability and clear feedback for both success and error responses.
 *
 * @param props.connection
 * @param props.productId UUID of the target product to retrieve.
 * @path /aimall-backend/products/:productId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the target product to retrieve. */
    productId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendProduct;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/products/:productId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): IAimallBackendProduct =>
    typia.random<IAimallBackendProduct>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

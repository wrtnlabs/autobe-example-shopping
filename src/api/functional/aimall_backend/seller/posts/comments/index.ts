import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendComment } from "../../../../../structures/IPageIAimallBackendComment";
import { IAimallBackendComment } from "../../../../../structures/IAimallBackendComment";

/**
 * Get all comments for a given postId from aimall_backend_comments.
 *
 * This endpoint queries all comments for a specific post using the postId path
 * parameter. It leverages the 3NF-compliant aimall_backend_comments table,
 * ensuring each comment is normalized and can be uniquely identified and
 * retrieved.
 *
 * The endpoint supports community moderation and feedback compliance. Only
 * comments on the target post are returned, and API consumers must perform
 * pagination if the list is long. Sensitive/private comments are filtered
 * according to caller’s permissions.
 *
 * Authorization embraces the platform’s community role model: customers,
 * sellers, and administrators may view as allowed. Business logic may include
 * view count increment and audit logging on access. On error (e.g., invalid
 * postId), an appropriate error message is returned.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to retrieve comments for.
 * @path /aimall-backend/seller/posts/:postId/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the post to retrieve comments for. */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIAimallBackendComment;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/seller/posts/:postId/comments",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/posts/${encodeURIComponent(props.postId ?? "null")}/comments`;
  export const random = (): IPageIAimallBackendComment =>
    typia.random<IPageIAimallBackendComment>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new comment under the specified post (Community, Comments).
 *
 * This endpoint allows creation of a comment on a post. Request body must
 * provide required comment fields defined in aimall_backend_comments: postId
 * (derived from path), body, is_private, and other attributes.
 *
 * Authentication is required; the commenter’s role determines further business
 * logic, like private/public status and moderation pipeline. On success, a
 * normalized comment object is returned. Error handling includes invalid input,
 * access denial, or prohibited content (business rule-validated).
 *
 * @param props.connection
 * @param props.postId ID of the post where the comment will be created.
 * @param props.body Comment creation data, following the Community Comments
 *   schema definition.
 * @path /aimall-backend/seller/posts/:postId/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** ID of the post where the comment will be created. */
    postId: string & tags.Format<"uuid">;

    /**
     * Comment creation data, following the Community Comments schema
     * definition.
     */
    body: IAimallBackendComment.ICreate;
  };
  export type Body = IAimallBackendComment.ICreate;
  export type Response = IAimallBackendComment;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/seller/posts/:postId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/posts/${encodeURIComponent(props.postId ?? "null")}/comments`;
  export const random = (): IAimallBackendComment =>
    typia.random<IAimallBackendComment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and filter comments for a post with advanced criteria (Community,
 * Comments).
 *
 * This endpoint enables advanced comment searching for a given post. SEARCH is
 * executed via complex payload, allowing for criteria like visibility,
 * keywords, user, and time window filtering, which is essential for moderation
 * and user experience optimization.
 *
 * Authorization is required; users are only shown comments they have access
 * rights to (public comments, or their own private comments). The request body
 * uses a filtering/search DTO. Expected errors include invalid postId or
 * validation errors in search criteria.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to query comments for.
 * @param props.body Advanced filter/search and pagination options for
 *   retrieving comments.
 * @path /aimall-backend/seller/posts/:postId/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Unique identifier of the post to query comments for. */
    postId: string & tags.Format<"uuid">;

    /**
     * Advanced filter/search and pagination options for retrieving
     * comments.
     */
    body: IAimallBackendComment.IRequest;
  };
  export type Body = IAimallBackendComment.IRequest;
  export type Response = IPageIAimallBackendComment;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/seller/posts/:postId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/posts/${encodeURIComponent(props.postId ?? "null")}/comments`;
  export const random = (): IPageIAimallBackendComment =>
    typia.random<IPageIAimallBackendComment>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single comment for a post by commentId (Community, Comments).
 *
 * This endpoint provides the details of a single comment belonging to a post
 * (identified by postId and commentId). It returns all fields normalized per
 * aimall_backend_comments table, such as body, author, timestamps, and privacy
 * flag.
 *
 * Authorization is enforced so only customers, sellers, or administrators with
 * sufficient rights may view private or sensitive comments. The API properly
 * handles not found (404) and access denied scenarios, with complete error
 * feedback.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target post.
 * @param props.commentId Unique identifier of the comment to retrieve.
 * @path /aimall-backend/seller/posts/:postId/comments/:commentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target post. */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the comment to retrieve. */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendComment;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/seller/posts/:postId/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): IAimallBackendComment =>
    typia.random<IAimallBackendComment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a comment under a post by commentId (Community, Comments).
 *
 * This endpoint updates a comment for a particular post, using both postId and
 * commentId as path parameters. Editable fields are in the request body, e.g.,
 * body, is_private. The comment is updated only if the user has sufficient
 * privileges (author or admin). Audit logging is triggered for edit actions.
 *
 * Errors are raised for not-found, invalid update data, or insufficient
 * privileges when a user tries to modify another user's comment. On success,
 * the updated comment is returned, compliant with normalization rules of
 * aimall_backend_comments.
 *
 * @param props.connection
 * @param props.postId ID of the post holding the comment.
 * @param props.commentId ID of the comment being updated.
 * @param props.body Update payload for the specified comment, matching the
 *   Community Comments update schema.
 * @path /aimall-backend/seller/posts/:postId/comments/:commentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** ID of the post holding the comment. */
    postId: string & tags.Format<"uuid">;

    /** ID of the comment being updated. */
    commentId: string & tags.Format<"uuid">;

    /**
     * Update payload for the specified comment, matching the Community
     * Comments update schema.
     */
    body: IAimallBackendComment.IUpdate;
  };
  export type Body = IAimallBackendComment.IUpdate;
  export type Response = IAimallBackendComment;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/seller/posts/:postId/comments/:commentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): IAimallBackendComment =>
    typia.random<IAimallBackendComment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a comment under a post by commentId (Community, Comments).
 *
 * This endpoint soft deletes a comment as per the aimall_backend_comments
 * schema: the deleted_at timestamp is set rather than the row being removed.
 * Only authorized users (author or moderator/administrator) may perform this
 * operation for compliance and moderation policy. Business rules include
 * possible post/comment audit logging.
 *
 * Error conditions include not found, or unauthorized action. On success,
 * comment is no longer visible in ordinary listings but remains for audit and
 * recovery.
 *
 * @param props.connection
 * @param props.postId ID of the parent post holding the comment.
 * @param props.commentId ID of the comment to delete.
 * @path /aimall-backend/seller/posts/:postId/comments/:commentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** ID of the parent post holding the comment. */
    postId: string & tags.Format<"uuid">;

    /** ID of the comment to delete. */
    commentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/seller/posts/:postId/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

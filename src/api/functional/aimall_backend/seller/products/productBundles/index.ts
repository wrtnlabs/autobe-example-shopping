import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendProductBundle } from "../../../../../structures/IPageIAimallBackendProductBundle";
import { IAimallBackendProductBundle } from "../../../../../structures/IAimallBackendProductBundle";

/**
 * Get all product bundles for a given product from the product bundle table.
 *
 * Retrieve all product bundle relations for a specified product. This operation
 * is essential for sellers, administrators, or the platform to see how a
 * product acts as a bundle master (i.e., is sold as a group with other
 * products) or is included as a bundled component in other bundles. The
 * operation ensures only products with valid references in the
 * 'aimall_backend_product_bundles' table are listed.
 *
 * It supports audit logging and can be combined with PUT/POST endpoints for
 * creation or modification of bundles. Security: available to seller,
 * administrator, or other roles responsible for product catalog management.
 * Error scenarios include non-existent productId (404) or lack of permission
 * (403).
 *
 * @param props.connection
 * @param props.productId Unique identifier of the target product (product
 *   acting as bundle master or as a bundled component).
 * @path /aimall-backend/seller/products/:productId/productBundles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the target product (product acting as bundle
     * master or as a bundled component).
     */
    productId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIAimallBackendProductBundle;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/seller/products/:productId/productBundles",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/productBundles`;
  export const random = (): IPageIAimallBackendProductBundle =>
    typia.random<IPageIAimallBackendProductBundle>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create new product bundle for a specific product (as bundle group).
 *
 * Creates a product bundle associating the specified product (as the bundle
 * master/group) with one or more component products. Input data must provide
 * reference to component product, required-ness, and quantity. Returns the
 * created product bundle record on success. Validation includes checks for
 * existence of all referenced products. Security-wise, only sellers or
 * administrators with catalog privileges are allowed to use this operation. On
 * error, returns 400 or 422 for validation, 403 for permission.
 *
 * @param props.connection
 * @param props.productId ID of the product to act as master (bundle group) in
 *   this bundle relationship.
 * @param props.body Data for creating new product bundle, including required
 *   component, is_required flag, and quantity.
 * @path /aimall-backend/seller/products/:productId/productBundles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * ID of the product to act as master (bundle group) in this bundle
     * relationship.
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Data for creating new product bundle, including required component,
     * is_required flag, and quantity.
     */
    body: IAimallBackendProductBundle.ICreate;
  };
  export type Body = IAimallBackendProductBundle.ICreate;
  export type Response = IAimallBackendProductBundle;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/seller/products/:productId/productBundles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/productBundles`;
  export const random = (): IAimallBackendProductBundle =>
    typia.random<IAimallBackendProductBundle>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search/filter product bundles for a given product with pagination and search
 * options.
 *
 * Performs a filtered, paginated search for product bundles for a given
 * product. Allows advanced UI queries on product bundle relationships, e.g.,
 * filtering by whether a component is required, minimum quantity, or specific
 * component product membership. Returns a paginated response for scalable
 * consumption in admin interfaces.
 *
 * Security: Only accessible to roles capable of inventory and catalog
 * management (seller, administrator). Handles validation of product existence
 * and permission level. Applicable error codes include 403 (permission denied),
 * 404 (not found), or 422 (invalid parameter).
 *
 * @param props.connection
 * @param props.productId Target product's unique identifier (as bundle or
 *   component).
 * @param props.body Query and filter parameters for paginating and searching
 *   product bundles of a product.
 * @path /aimall-backend/seller/products/:productId/productBundles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Target product's unique identifier (as bundle or component). */
    productId: string & tags.Format<"uuid">;

    /**
     * Query and filter parameters for paginating and searching product
     * bundles of a product.
     */
    body: IAimallBackendProductBundle.IRequest;
  };
  export type Body = IAimallBackendProductBundle.IRequest;
  export type Response = IPageIAimallBackendProductBundle;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/seller/products/:productId/productBundles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/productBundles`;
  export const random = (): IPageIAimallBackendProductBundle =>
    typia.random<IPageIAimallBackendProductBundle>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detail for a specific product bundle by its ID (for a given product).
 *
 * Fetches a single product bundle record given a master product and bundle
 * relation ID. Returns all relevant atomic fields including pointers to the
 * bundle product, component product, required-ness, and quantity. Security:
 * Only available to seller/administrator roles. Returns 404 if either ID is
 * invalid or not linked by relationship. Can be used together with PUT for
 * update or DELETE for removal. Requires validation against product ownership
 * and permissions.
 *
 * @param props.connection
 * @param props.productId Product ID of the master product owning the bundle.
 * @param props.productBundleId Product bundle relation ID - uniquely identifies
 *   the bundle-component relationship.
 * @path /aimall-backend/seller/products/:productId/productBundles/:productBundleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Product ID of the master product owning the bundle. */
    productId: string & tags.Format<"uuid">;

    /**
     * Product bundle relation ID - uniquely identifies the bundle-component
     * relationship.
     */
    productBundleId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendProductBundle;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/seller/products/:productId/productBundles/:productBundleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/productBundles/${encodeURIComponent(props.productBundleId ?? "null")}`;
  export const random = (): IAimallBackendProductBundle =>
    typia.random<IAimallBackendProductBundle>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("productBundleId")(() =>
        typia.assert(props.productBundleId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update details of a specific product bundle for a particular product.
 *
 * Updates an existing product bundle relationship (component product, quantity,
 * is_required, etc.) for a given product and relation ID. Used in bundle
 * management UIs/logic. Returns updated entity on success. Security applies
 * (seller/administrator only; must own the product). Errors: 404 if not found,
 * 403 for forbidden, 422 for invalid input. Supports idempotent and partial
 * updates when supported by backend.
 *
 * @param props.connection
 * @param props.productId ID of the bundle master product.
 * @param props.productBundleId ID of the product bundle relation to update.
 * @param props.body Fields for updating a product bundle (component product,
 *   is_required, quantity, etc.)
 * @path /aimall-backend/seller/products/:productId/productBundles/:productBundleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** ID of the bundle master product. */
    productId: string & tags.Format<"uuid">;

    /** ID of the product bundle relation to update. */
    productBundleId: string & tags.Format<"uuid">;

    /**
     * Fields for updating a product bundle (component product, is_required,
     * quantity, etc.)
     */
    body: IAimallBackendProductBundle.IUpdate;
  };
  export type Body = IAimallBackendProductBundle.IUpdate;
  export type Response = IAimallBackendProductBundle;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/seller/products/:productId/productBundles/:productBundleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/productBundles/${encodeURIComponent(props.productBundleId ?? "null")}`;
  export const random = (): IAimallBackendProductBundle =>
    typia.random<IAimallBackendProductBundle>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("productBundleId")(() =>
        typia.assert(props.productBundleId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (hard) a specific product bundle for a given product.
 *
 * Deletes (hard delete) a product bundle relationship, removing the association
 * between the master product and its component product. This operation is only
 * available to authorized sellers/administrators. Ensure correct ownership
 * before invoking. Deletion is permanent as the table lacks soft delete fields
 * like 'deleted_at'. Returns 204 (no content) on success, 404 if not found, 403
 * if forbidden.
 *
 * @param props.connection
 * @param props.productId ID of the product acting as bundle master.
 * @param props.productBundleId ID of the bundle relation to delete.
 * @path /aimall-backend/seller/products/:productId/productBundles/:productBundleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** ID of the product acting as bundle master. */
    productId: string & tags.Format<"uuid">;

    /** ID of the bundle relation to delete. */
    productBundleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/seller/products/:productId/productBundles/:productBundleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/productBundles/${encodeURIComponent(props.productBundleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("productBundleId")(() =>
        typia.assert(props.productBundleId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

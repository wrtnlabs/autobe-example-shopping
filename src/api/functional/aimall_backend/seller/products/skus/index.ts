import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendSku } from "../../../../../structures/IPageIAimallBackendSku";
import { IAimallBackendSku } from "../../../../../structures/IAimallBackendSku";

/**
 * List all SKUs for a given product (aimall_backend_skus table).
 *
 * Retrieve a paginated list of all SKUs (stock keeping units) available for a
 * given product. The aimall_backend_skus table contains the unique variant
 * records for each product, referenced by product_id. Clients such as product
 * detail pages, inventory management UIs, and checkout validation leverage this
 * endpoint to present or manage the selection of SKU options. Each SKU record
 * includes fields like id, product_id, and sku_code.
 *
 * Pagination is applied to handle scenarios where products have a high number
 * of variants. Role-based security may apply if certain SKUs should only be
 * visible to sellers of the product or platform administrators. Invalid
 * productId or unfound products result in appropriate errors.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the product whose SKUs are being
 *   listed.
 * @path /aimall-backend/seller/products/:productId/skus
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier for the product whose SKUs are being listed. */
    productId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIAimallBackendSku;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/seller/products/:productId/skus",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/skus`;
  export const random = (): IPageIAimallBackendSku =>
    typia.random<IPageIAimallBackendSku>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new SKU (variant) for the specified product (aimall_backend_skus).
 *
 * Create a new SKU (variant) under the specified product. This endpoint allows
 * sellers and administrators to upload new SKU configurations to the
 * aimall_backend_skus table. The productId (from the path) is set as the
 * product_id reference. The request body provides the SKU details, such as
 * sku_code.
 *
 * Enforces SKU uniqueness based on sku_code and association with the correct
 * product. Prevents SKU duplication (conflict error), and only users with
 * sufficient authorization can perform this action.
 *
 * Upon successful creation, the full SKU record is returned, including id,
 * product_id, and other relevant fields. If the payload or parentage validation
 * fails, returns appropriate errors to the caller (invalid productId, invalid
 * SKU code, etc.).
 *
 * @param props.connection
 * @param props.productId Product ID that will own the new SKU.
 * @param props.body Data for the new SKU variant (sku_code, etc; productId is
 *   from path param).
 * @path /aimall-backend/seller/products/:productId/skus
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Product ID that will own the new SKU. */
    productId: string & tags.Format<"uuid">;

    /**
     * Data for the new SKU variant (sku_code, etc; productId is from path
     * param).
     */
    body: IAimallBackendSku.ICreate;
  };
  export type Body = IAimallBackendSku.ICreate;
  export type Response = IAimallBackendSku;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/seller/products/:productId/skus",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/skus`;
  export const random = (): IAimallBackendSku =>
    typia.random<IAimallBackendSku>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Advanced SKUs search/filtering for a product, with pagination
 * (aimall_backend_skus).
 *
 * Fetch all SKUs affiliated with a specified product, with support for advanced
 * query features such as search by SKU code, partial code, and pagination. The
 * aimall_backend_skus table supports many-to-product relationships and allows
 * efficient traversal and filtering of SKUs for high-variant products, as used
 * by administrative or seller inventory dashboards.
 *
 * The API enforces product validation, returning only SKUs that are subordinate
 * to the given productId, and applies security constraints as necessary (e.g.,
 * sellers can only see their own products’ SKUs). Malformed filters or invalid
 * productId parameters will trigger errors as appropriate.
 *
 * @param props.connection
 * @param props.productId The product for which to filter/search SKUs.
 * @param props.body Filtering and searching details for querying this product’s
 *   SKUs.
 * @path /aimall-backend/seller/products/:productId/skus
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** The product for which to filter/search SKUs. */
    productId: string & tags.Format<"uuid">;

    /** Filtering and searching details for querying this product’s SKUs. */
    body: IAimallBackendSku.IRequest;
  };
  export type Body = IAimallBackendSku.IRequest;
  export type Response = IPageIAimallBackendSku;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/seller/products/:productId/skus",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/skus`;
  export const random = (): IPageIAimallBackendSku =>
    typia.random<IPageIAimallBackendSku>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a specific SKU for a product (aimall_backend_skus).
 *
 * Retrieve the complete specification of a specific SKU (variant) as a child of
 * a given product. The operation ensures the SKU id (skuId) belongs to the
 * indicated product (productId) by examining the product_id foreign key in the
 * aimall_backend_skus table.
 *
 * The returned SKU includes key fields such as id, product_id, and sku_code,
 * enabling editing, stock management, and detailed option configuration. This
 * endpoint is most relevant for product management dashboards and advanced
 * stock tracking systems. Proper authorization must ensure only administrators
 * or valid product-owners access the resource. Not-found errors are returned if
 * association validation fails, ensuring data integrity.
 *
 * @param props.connection
 * @param props.productId Product ID to which the SKU belongs (verifies
 *   parentage).
 * @param props.skuId SKU (variant) ID to retrieve, must belong to the product.
 * @path /aimall-backend/seller/products/:productId/skus/:skuId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Product ID to which the SKU belongs (verifies parentage). */
    productId: string & tags.Format<"uuid">;

    /** SKU (variant) ID to retrieve, must belong to the product. */
    skuId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendSku;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/seller/products/:productId/skus/:skuId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/skus/${encodeURIComponent(props.skuId ?? "null")}`;
  export const random = (): IAimallBackendSku =>
    typia.random<IAimallBackendSku>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("skuId")(() => typia.assert(props.skuId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update configuration of a specific SKU for a product (aimall_backend_skus).
 *
 * Modify the details of a SKU as a child of a given product. The endpoint uses
 * both productId and skuId to unambiguously locate the record within the
 * aimall_backend_skus table and updates one or more SKU fields (e.g.,
 * sku_code). Validation checks include that the updated code is unique and that
 * the SKU is subordinate to the stated product by product_id.
 *
 * If the validation passes, returns the full updated SKU record; otherwise,
 * errors indicate field conflicts or relationship mismatches. This is a
 * critical operation for catalog management and SKU lifecycle operations in
 * administrator and seller roles.
 *
 * @param props.connection
 * @param props.productId The product whose SKU is being updated (verifies
 *   ownership).
 * @param props.skuId The unique SKU ID to update.
 * @param props.body Update data for the SKU (sku_code, etc.); productId and
 *   skuId from the path.
 * @path /aimall-backend/seller/products/:productId/skus/:skuId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The product whose SKU is being updated (verifies ownership). */
    productId: string & tags.Format<"uuid">;

    /** The unique SKU ID to update. */
    skuId: string & tags.Format<"uuid">;

    /**
     * Update data for the SKU (sku_code, etc.); productId and skuId from
     * the path.
     */
    body: IAimallBackendSku.IUpdate;
  };
  export type Body = IAimallBackendSku.IUpdate;
  export type Response = IAimallBackendSku;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/seller/products/:productId/skus/:skuId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/skus/${encodeURIComponent(props.skuId ?? "null")}`;
  export const random = (): IAimallBackendSku =>
    typia.random<IAimallBackendSku>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("skuId")(() => typia.assert(props.skuId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Hard delete a specific SKU for a product; no soft delete
 * (aimall_backend_skus).
 *
 * Permanently remove a SKU record for a specified product. This API call
 * ensures, using both parent productId and skuId, that the corresponding SKU
 * exists and is subordinate to the product. Since aimall_backend_skus lacks a
 * soft delete (no deleted_at field), records are actually erased from the
 * database.
 *
 * Business logic must ensure this operation does not delete SKUs linked to
 * active order items or inventory snapshots. Attempting to delete a
 * non-existent or mismatched (parent/sku) pair triggers error responses. Role
 * restricted to administrators and authorized sellers for data integrity and
 * compliance reasons.
 *
 * @param props.connection
 * @param props.productId Parent product ID to which the SKU belongs.
 * @param props.skuId SKU (variant) ID to delete (must belong to product).
 * @path /aimall-backend/seller/products/:productId/skus/:skuId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Parent product ID to which the SKU belongs. */
    productId: string & tags.Format<"uuid">;

    /** SKU (variant) ID to delete (must belong to product). */
    skuId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/seller/products/:productId/skus/:skuId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/products/${encodeURIComponent(props.productId ?? "null")}/skus/${encodeURIComponent(props.skuId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("skuId")(() => typia.assert(props.skuId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIAimallBackendAttachment } from "../../../../../structures/IPageIAimallBackendAttachment";
import { IAimallBackendAttachment } from "../../../../../structures/IAimallBackendAttachment";

/**
 * List all file/media attachments for a product review
 * (aimall_backend_attachments).
 *
 * Lists all attachments that are associated with a specific product review
 * using the aimall_backend_attachments schema. Each returned item includes
 * normalized details on file type, storage URI, and size.
 *
 * This supports UGC moderation, review enrichment with media, and enables
 * clients to show all user-uploaded content per review efficiently. Listings
 * are tailored according to role/permissions, so customers only view permitted
 * media, while admin/moderators can see all associated files.
 *
 * If no attachments exist, an empty result is returned. ReviewId must exist.
 *
 * @param props.connection
 * @param props.reviewId UUID reference for the reviewed product whose
 *   attachments should be fetched.
 * @path /aimall-backend/seller/reviews/:reviewId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /**
     * UUID reference for the reviewed product whose attachments should be
     * fetched.
     */
    reviewId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIAimallBackendAttachment.ISummary;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/seller/reviews/:reviewId/attachments",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/reviews/${encodeURIComponent(props.reviewId ?? "null")}/attachments`;
  export const random = (): IPageIAimallBackendAttachment.ISummary =>
    typia.random<IPageIAimallBackendAttachment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a file attachment on a product review entry.
 *
 * Creates a new attachment record for the specified product review. Validates
 * file properties (type/size/uri) according to schema and business rules before
 * saving. On success, returns full details of the attachment.
 *
 * Attachments are subject to moderation and content screening by default; only
 * files fitting compliance and format criteria are accepted.
 *
 * Failure cases: review not found, invalid/corrupt media, storage failure.
 *
 * @param props.connection
 * @param props.reviewId Product review identifier for associating new
 *   attachment.
 * @param props.body Attachment upload info, including URI, type, and metadata
 *   according to IAimallBackendAttachment.ICreate.
 * @path /aimall-backend/seller/reviews/:reviewId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Product review identifier for associating new attachment. */
    reviewId: string & tags.Format<"uuid">;

    /**
     * Attachment upload info, including URI, type, and metadata according
     * to IAimallBackendAttachment.ICreate.
     */
    body: IAimallBackendAttachment.ICreate;
  };
  export type Body = IAimallBackendAttachment.ICreate;
  export type Response = IAimallBackendAttachment;

  export const METADATA = {
    method: "POST",
    path: "/aimall-backend/seller/reviews/:reviewId/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/reviews/${encodeURIComponent(props.reviewId ?? "null")}/attachments`;
  export const random = (): IAimallBackendAttachment =>
    typia.random<IAimallBackendAttachment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate review attachments with advanced filtering.
 *
 * Performs a filtered, paginated search for attachments uploaded to a product
 * review. Fields and options on aimall_backend_attachments can be used for
 * search: file_type (image/video/doc), size, created_at period, etc.
 *
 * Advanced filtering assists customer UIs and admin tools in rapidly
 * enumerating user-submitted content, enforcing business moderation, or
 * handling content overload on popular reviews. Security: Only users authorized
 * for the target review's media can access the listing.
 *
 * This PATCH variant is for complex queries; GET is only for simple full
 * listings.
 *
 * @param props.connection
 * @param props.reviewId UUID identifier for review context, used for attachment
 *   search/filter.
 * @param props.body Search/filter criteria and pagination parameters for review
 *   attachments.
 * @path /aimall-backend/seller/reviews/:reviewId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * UUID identifier for review context, used for attachment
     * search/filter.
     */
    reviewId: string & tags.Format<"uuid">;

    /**
     * Search/filter criteria and pagination parameters for review
     * attachments.
     */
    body: IAimallBackendAttachment.IRequest;
  };
  export type Body = IAimallBackendAttachment.IRequest;
  export type Response = IPageIAimallBackendAttachment;

  export const METADATA = {
    method: "PATCH",
    path: "/aimall-backend/seller/reviews/:reviewId/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/reviews/${encodeURIComponent(props.reviewId ?? "null")}/attachments`;
  export const random = (): IPageIAimallBackendAttachment =>
    typia.random<IPageIAimallBackendAttachment>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific file attachment for a product review by UUID.
 *
 * Provides detailed metadata for a specific media/file attachment linked to a
 * product review. Data is selected from aimall_backend_attachments using unique
 * IDs to retrieve the proper file reference, type, and size fields for display
 * or content moderation workflows.
 *
 * Used for cases like serving a detail attachment modal, direct download, or
 * admin audit. Assumes existence of the attachment for the given review;
 * handles not-found errors as necessary.
 *
 * @param props.connection
 * @param props.reviewId UUID of the product review record.
 * @param props.attachmentId Attachment record's UUID to fetch details for.
 * @path /aimall-backend/seller/reviews/:reviewId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the product review record. */
    reviewId: string & tags.Format<"uuid">;

    /** Attachment record's UUID to fetch details for. */
    attachmentId: string & tags.Format<"uuid">;
  };
  export type Response = IAimallBackendAttachment;

  export const METADATA = {
    method: "GET",
    path: "/aimall-backend/seller/reviews/:reviewId/attachments/:attachmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/reviews/${encodeURIComponent(props.reviewId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): IAimallBackendAttachment =>
    typia.random<IAimallBackendAttachment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update file/media attachment metadata for a review entry.
 *
 * Allows updating metadata (URI, type, caption/label) of an attachment already
 * associated with a product review. Applies only to
 * owned/admin/moderator-permitted updates for UGC moderation, error correction,
 * or compliance annotation.
 *
 * Core constraints: review association is immutable on update; only metadata or
 * file details can be edited. Owner or admin authorization required for
 * changes; audit logs are updated to meet compliance.
 *
 * Returns the updated attachment metadata on success; error scenarios include
 * permission denied, attachment not found, or validation failure.
 *
 * @param props.connection
 * @param props.reviewId Target review UUID for context.
 * @param props.attachmentId UUID for the attachment to update.
 * @param props.body Data for permitted updateable fields in the attachment
 *   record: see IAimallBackendAttachment.IUpdate.
 * @path /aimall-backend/seller/reviews/:reviewId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target review UUID for context. */
    reviewId: string & tags.Format<"uuid">;

    /** UUID for the attachment to update. */
    attachmentId: string & tags.Format<"uuid">;

    /**
     * Data for permitted updateable fields in the attachment record: see
     * IAimallBackendAttachment.IUpdate.
     */
    body: IAimallBackendAttachment.IUpdate;
  };
  export type Body = IAimallBackendAttachment.IUpdate;
  export type Response = IAimallBackendAttachment;

  export const METADATA = {
    method: "PUT",
    path: "/aimall-backend/seller/reviews/:reviewId/attachments/:attachmentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aimall-backend/seller/reviews/${encodeURIComponent(props.reviewId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): IAimallBackendAttachment =>
    typia.random<IAimallBackendAttachment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Completely remove a file/media attachment from a review (hard delete).
 *
 * Removes an attachment from a product review by deleting the row in
 * aimall_backend_attachments using reviewId and attachmentId. Since this table
 * does not support soft deletion (no deleted_at field), this operation performs
 * a hard delete, permanently removing all record metadata from the database.
 * Media file deletion from storage is managed at the application level.
 *
 * Authorization: only the uploading customer, review owner, or admin can
 * delete. Safeguards to block deletion if file in use (e.g., referenced
 * elsewhere) may be employed.
 *
 * Returns no data on success; error if attachment not found or unauthorized.
 *
 * @param props.connection
 * @param props.reviewId UUID for the review whose attachment is to be removed.
 * @param props.attachmentId Attachment UUID to delete.
 * @path /aimall-backend/seller/reviews/:reviewId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID for the review whose attachment is to be removed. */
    reviewId: string & tags.Format<"uuid">;

    /** Attachment UUID to delete. */
    attachmentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aimall-backend/seller/reviews/:reviewId/attachments/:attachmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aimall-backend/seller/reviews/${encodeURIComponent(props.reviewId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

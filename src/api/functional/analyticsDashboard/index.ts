import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAnalyticsDashboard } from "../../structures/IAnalyticsDashboard";
import { IPageIAnalyticsDashboard } from "../../structures/IPageIAnalyticsDashboard";

/**
 * Create an analytics dashboard (atomic record—analytics_dashboard table).
 *
 * Creates a new analytics dashboard by accepting validated POST input—fields
 * match schema: name, description (optional), configuration JSON, owner_type
 * (user/admin/seller), owner_id, etc. Audit fields (timestamps) are set
 * automatically.
 *
 * Only users with adequate permissions may create dashboards for given
 * owner_type/context; operation is RBAC-protected as per compliance
 * requirements. Errors include 403 unauthorized, 400 validation failed, 409
 * duplicate, and 500 internal error.
 *
 * Related operations include PATCH (list), GET (read), PUT (update), DELETE
 * (remove/soft-delete). All created records must be atomic and normalized, as
 * per schema description comments.
 *
 * @param props.body Analytics dashboard data for creation, all atomic fields
 *   required in analytics_dashboard.
 * @path /analyticsDashboard
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Analytics dashboard data for creation, all atomic fields required in
     * analytics_dashboard.
     */
    body: IAnalyticsDashboard.ICreate;
  };
  export type Body = IAnalyticsDashboard.ICreate;
  export type Response = IAnalyticsDashboard;

  export const METADATA = {
    method: "POST",
    path: "/analyticsDashboard",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/analyticsDashboard";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsDashboard => typia.random<IAnalyticsDashboard>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a paginated, searchable list of analytics dashboards from the
 * analytics_dashboard table.
 *
 * This operation retrieves a paginated and filterable list of analytics
 * dashboards, supporting search, sort, and other filters as described in the
 * analytics_dashboard Prisma schema and requirements. Each dashboard record is
 * tied to an owner (user/admin/seller), and displays configuration,
 * description, and audit details. Security: Requires role-based
 * authentication—users only see dashboards they have permissions for, as per
 * requirements for RBAC and compliance audit.
 *
 * Dashboards must be filterable by owner, type, and deletion status. Pagination
 * and sorting are required for performance and UX. If search tokens are
 * present, dashboards are matched via name/description fields using full-text
 * indexes (see schema's GIN index on name).
 *
 * Returned dashboards represent the current active state unless a historical
 * view is requested through additional parameters (not in basic PATCH). Related
 * operations: GET returns specific dashboard info, POST creates, PUT updates,
 * DELETE performs soft delete. Errors include 403 on insufficient permission,
 * 400 on bad input, and 500 on system/internal errors.
 *
 * @param props.body Search, filter, sort, and pagination parameters for listing
 *   analytics dashboards.
 * @path /analyticsDashboard
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Search, filter, sort, and pagination parameters for listing analytics
     * dashboards.
     */
    body: IAnalyticsDashboard.IRequest;
  };
  export type Body = IAnalyticsDashboard.IRequest;
  export type Response = IPageIAnalyticsDashboard;

  export const METADATA = {
    method: "PATCH",
    path: "/analyticsDashboard",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/analyticsDashboard";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAnalyticsDashboard => typia.random<IPageIAnalyticsDashboard>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get details of a single analytics dashboard by ID from analytics_dashboard
 * table.
 *
 * Retrieves full detail for a single analytics dashboard, as defined in the
 * analytics_dashboard schema table. Includes dashboard name, description,
 * configuration blob, owner context (type and ID), and audit information
 * (created/updated/deleted timestamps).
 *
 * Security: Only users with correct permissions/contextual ownership can view
 * specific dashboard details. All accesses are audit logged for compliance.
 *
 * Returns HTTP 404 if dashboard not found, or 403 on unauthorized access.
 * Related PATCH fetches list, PUT updates, DELETE marks deleted. All returned
 * fields are atomic, in line with strict 3NF (see schema).
 *
 * @param props.id ID of the analytics dashboard to retrieve.
 * @path /analyticsDashboard/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** ID of the analytics dashboard to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAnalyticsDashboard;

  export const METADATA = {
    method: "GET",
    path: "/analyticsDashboard/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/analyticsDashboard/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsDashboard => typia.random<IAnalyticsDashboard>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing analytics dashboard by ID (analytics_dashboard table).
 *
 * Updates an existing analytics dashboard, referenced by ID. All input fields
 * (name, description, configuration, owner_type, owner_id) are validated as per
 * analytics_dashboard schema. Only dashboard owner or authorized role can
 * update. Updates audit timestamp for compliance.
 *
 * Operation is atomic: on error, no partial updates. Responds with updated
 * dashboard entity or error (404 if not found, 403 if not authorized, 400
 * validation error). All changes are audit-logged for regulatory compliance.
 *
 * Related API: GET fetches, PATCH lists, DELETE marks deleted. PUT is for full
 * (not partial) update, enforcing business and technical validation of atomic
 * schema fields.
 *
 * @param props.id ID of dashboard to update.
 * @param props.body Dashboard update fields (name, config, owner_type/id, etc),
 *   all atomic as described in schema.
 * @path /analyticsDashboard/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** ID of dashboard to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Dashboard update fields (name, config, owner_type/id, etc), all
     * atomic as described in schema.
     */
    body: IAnalyticsDashboard.IUpdate;
  };
  export type Body = IAnalyticsDashboard.IUpdate;
  export type Response = IAnalyticsDashboard;

  export const METADATA = {
    method: "PUT",
    path: "/analyticsDashboard/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/analyticsDashboard/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsDashboard => typia.random<IAnalyticsDashboard>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete (mark as deleted) an analytics dashboard by ID
 * (analytics_dashboard table).
 *
 * Soft-deletes an analytics dashboard by marking the 'deleted_at' timestamp via
 * the analytics_dashboard table. The dashboard remains in storage for
 * compliance, audit, and restoration purposes, meeting regulatory requirements.
 * Only the owner or authorized role may perform deletion; all actions are
 * audit-logged.
 *
 * Security: RBAC enforced. Errors are 404 if not found, 403 if unauthorized,
 * 500 on system error.
 *
 * Related: PATCH lists dashboards (supports filtering by deletion), GET fetches
 * details (returns 404 for deleted), POST creates, PUT updates. No data is
 * physically deleted—strict soft-delete protocol.
 *
 * @param props.id ID of dashboard to delete (soft-delete).
 * @path /analyticsDashboard/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** ID of dashboard to delete (soft-delete). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAnalyticsDashboard;

  export const METADATA = {
    method: "DELETE",
    path: "/analyticsDashboard/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/analyticsDashboard/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsDashboard => typia.random<IAnalyticsDashboard>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAnalyticsMetric } from "../../structures/IAnalyticsMetric";
import { IPageIAnalyticsMetric } from "../../structures/IPageIAnalyticsMetric";

/**
 * Create a new atomic analytics metric record (analytics_metric table).
 *
 * Adds a new metric definition to analytics_metric table. All fields (name,
 * description, source, data_type) are validated and required according to
 * schema. Only authorized users may add a metric; all adds are audit-logged for
 * explainability and compliance against configuration errors/fraud.
 *
 * Conflict or validation error: 409 or 400. Permissions: 403 if insufficient.
 * 201 with metric data on success. Related: PATCH lists, GET details, PUT
 * update, DELETE remove.
 *
 * @param props.body Metric data fields (all atomic as required for creation per
 *   schema).
 * @path /analyticsMetric
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Metric data fields (all atomic as required for creation per schema). */
    body: IAnalyticsMetric.ICreate;
  };
  export type Body = IAnalyticsMetric.ICreate;
  export type Response = IAnalyticsMetric;

  export const METADATA = {
    method: "POST",
    path: "/analyticsMetric",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/analyticsMetric";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsMetric => typia.random<IAnalyticsMetric>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetch a paginated, searchable list of analytics metrics from analytics_metric
 * table.
 *
 * Retrieves a paginated, filterable list of analytics metrics (from
 * analytics_metric table), supporting keyword search (by GIN index on name),
 * sorting, and other filter/query parameters. Security: Only users with read
 * permission (role-based as per requirements) may access metric lists. Result
 * is a normalized paginated set containing metric name, description, source,
 * and data type fields.
 *
 * Request is auditable. Errors: 400 for bad query, 403 for unauthorized, 500
 * for server errors.
 *
 * Related: GET for details, POST for add, PUT for update, DELETE for remove.
 * PATCH is the canonical list/read entry point for mass browsing/search.
 *
 * @param props.body List/search/sort/pagination params for metrics query.
 * @path /analyticsMetric
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** List/search/sort/pagination params for metrics query. */
    body: IAnalyticsMetric.IRequest;
  };
  export type Body = IAnalyticsMetric.IRequest;
  export type Response = IPageIAnalyticsMetric;

  export const METADATA = {
    method: "PATCH",
    path: "/analyticsMetric",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/analyticsMetric";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAnalyticsMetric => typia.random<IPageIAnalyticsMetric>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get analytics metric details by ID (analytics_metric table).
 *
 * Returns an analytics metric and all atomic fields (name, description,
 * data_type, source, etc) for the requested metric, as specified by the
 * analytics_metric table. Only authenticated users/admins with permission may
 * access the metric.
 *
 * RBAC enforced for viewing; audit logs are required. Errors: 404 if not found,
 * 403 if no permission, 500 for system failure.
 *
 * Metrics returned by GET are strictly atomic and do not include aggregations
 * or references, in keeping with schema and compliance.
 *
 * @param props.id ID of the metric to fetch.
 * @path /analyticsMetric/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** ID of the metric to fetch. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAnalyticsMetric;

  export const METADATA = {
    method: "GET",
    path: "/analyticsMetric/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/analyticsMetric/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsMetric => typia.random<IAnalyticsMetric>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing analytics metric by ID (analytics_metric table).
 *
 * Update (full) analytics metric record by ID, replacing name, description,
 * source, data_type as per schema. Only authorized users may edit. All updates
 * are fully atomic and RBAC protected; audit trails are recorded for every
 * change. On error: 403 forbidden, 404 not found, 400 validation.
 *
 * Returns updated metric entity on success. Related: PATCH lists, GET details,
 * POST creates, DELETE removes.
 *
 * @param props.id Metric ID to update (analytics_metric table).
 * @param props.body Metrics update fields—atomic values as described in
 *   analytics_metric schema.
 * @path /analyticsMetric/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Metric ID to update (analytics_metric table). */
    id: string & tags.Format<"uuid">;

    /**
     * Metrics update fields—atomic values as described in analytics_metric
     * schema.
     */
    body: IAnalyticsMetric.IUpdate;
  };
  export type Body = IAnalyticsMetric.IUpdate;
  export type Response = IAnalyticsMetric;

  export const METADATA = {
    method: "PUT",
    path: "/analyticsMetric/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/analyticsMetric/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsMetric => typia.random<IAnalyticsMetric>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft/delete an analytics metric (analytics_metric table) by ID.
 *
 * Soft deletes (marks as deleted/archived) an analytics metric entry by its ID
 * in the analytics_metric table. Complies with compliance/audit requirements.
 * RBAC and audit logs enforced—only permitted roles may delete a metric. All
 * metrics are kept for reporting; physical deletion is forbidden.
 *
 * Result: deleted metric record with updated deletion timestamp. Related: PATCH
 * for lists, GET for details, POST for add, PUT for update. Error: 404 if not
 * found, 403 could not authorize, 500 system error.
 *
 * @param props.id ID of analytics metric to delete/mark archived.
 * @path /analyticsMetric/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** ID of analytics metric to delete/mark archived. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAnalyticsMetric;

  export const METADATA = {
    method: "DELETE",
    path: "/analyticsMetric/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/analyticsMetric/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAnalyticsMetric => typia.random<IAnalyticsMetric>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

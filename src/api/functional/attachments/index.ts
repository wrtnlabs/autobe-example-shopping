import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttachment } from "../../structures/IAttachment";
import { IPageIAttachment } from "../../structures/IPageIAttachment";

/**
 * Create a new attachment (attachments table).
 *
 * This endpoint is used to register a new attachment file in the system, by
 * creating a new record with file metadata (file name, url, type, size,
 * version, etc.) after a successful upload. It does not store the file binary
 * itself; instead, it registers the CDN/object storage location.
 *
 * Only authorized actors can create new attachment records, and all actions are
 * logged for audit. Validation ensures no duplicate urls or filenames in the
 * applicable context, and required metadata (type, size, version) is checked.
 *
 * On success, the endpoint returns the newly registered attachment with all
 * metadata fields. Related endpoints include PATCH (list), GET (retrieve), PUT
 * (update), and DELETE (soft-delete).
 *
 * @param props.body Attachment file metadata after upload (filename, url, type,
 *   size, version).
 * @path /attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Attachment file metadata after upload (filename, url, type, size,
     * version).
     */
    body: IAttachment.ICreate;
  };
  export type Body = IAttachment.ICreate;
  export type Response = IAttachment;

  export const METADATA = {
    method: "POST",
    path: "/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attachments";
  export const random = (g?: Partial<typia.IRandomGenerator>): IAttachment =>
    typia.random<IAttachment>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Paged/search list of attachments (attachments table).
 *
 * This endpoint returns a paginated, filtered list of attachment file records.
 * It implements the requirement to support search/filter for attachments by
 * filename, MIME type, creation time, size, or other metadata fields. Channel,
 * entity, or user scoping can be supported as query/filter fields.
 *
 * Access to this endpoint is typically permission-controlled, with only
 * authorized users (admins, sellers) able to list all attachments. Pagination
 * parameters (page, perPage), sort, and search fields should be supported.
 * Search results exclude soft-deleted (deleted_at set) attachments by default,
 * unless explicitly requested for audit.
 *
 * Error handling must catch invalid filter/sort criteria. The list operation is
 * typically used before associating attachments with products, boards, or
 * reviews.
 *
 * @param props.body Filter, search, sorting, and pagination info for attachment
 *   listing.
 * @path /attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filter, search, sorting, and pagination info for attachment listing. */
    body: IAttachment.IRequest;
  };
  export type Body = IAttachment.IRequest;
  export type Response = IPageIAttachment;

  export const METADATA = {
    method: "PATCH",
    path: "/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attachments";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAttachment => typia.random<IPageIAttachment>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve attachment details by id (attachments table).
 *
 * This endpoint delivers detailed information about a single attachment, such
 * as file name, type, size, URL, and version metadata, using its unique id.
 * Implements the requirement for file management and audit tracing for images,
 * docs, and board/product media.
 *
 * Users accessing this endpoint must have proper permissions, either as content
 * owners/admins or for compliance. The endpoint returns the file metadata,
 * including access credentials or signed URLs as appropriate. If the attachment
 * does not exist or is soft-deleted, a not-found error is returned.
 *
 * The GET operation is complemented by PATCH (listing), POST (creation), PUT
 * (metadata update), and DELETE (soft-delete) endpoints for full CRUD support
 * on attachments.
 *
 * @param props.id Target attachment's ID
 * @path /attachments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target attachment's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttachment;

  export const METADATA = {
    method: "GET",
    path: "/attachments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attachments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IAttachment =>
    typia.random<IAttachment>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update attachment metadata by id (attachments table).
 *
 * This endpoint allows updates to the metadata for a specific attachment by its
 * id. Typical use cases include correcting file names, types, updating
 * alternate text (for accessibility), or incrementing version info after file
 * updates.
 *
 * Authorization is required, typically for admins or entity/resource owners.
 * Updated metadata is validated for consistency (e.g., duplicate filename/urls
 * are not allowed). All update actions are audit-logged. The endpoint never
 * directly manipulates the file binaryâ€”only its record/metadata.
 *
 * Error responses are generated for nonexistent, soft-deleted or locked
 * attachments. Updatable fields include filename, type, alt text, and version.
 * Related endpoints: POST (create), PATCH (list), GET (retrieve), DELETE
 * (soft-delete).
 *
 * @param props.id Target attachment's ID
 * @param props.body Attachment metadata updates (filename, url, type, size,
 *   version, etc.).
 * @path /attachments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target attachment's ID */
    id: string & tags.Format<"uuid">;

    /**
     * Attachment metadata updates (filename, url, type, size, version,
     * etc.).
     */
    body: IAttachment.IUpdate;
  };
  export type Body = IAttachment.IUpdate;
  export type Response = IAttachment;

  export const METADATA = {
    method: "PUT",
    path: "/attachments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attachments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IAttachment =>
    typia.random<IAttachment>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft delete an attachment by id (attachments table).
 *
 * This endpoint logically deletes (soft-deletes) an attachment file entry by
 * its id. The record's deleted_at timestamp is set, retaining it for compliance
 * but removing it from active listings.
 *
 * Only authorized users such as administrators are permitted to perform this
 * action. All deletion events are logged for audit. Error responses are
 * returned if the id does not exist, is already deleted, or the user lacks
 * permission.
 *
 * Soft-deleted attachments are excluded from PATCH (list/search) results unless
 * explicitly requested. Related endpoints: PATCH (list), GET (retrieve), POST
 * (create), PUT (update).
 *
 * @param props.id Target attachment's ID
 * @path /attachments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target attachment's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttachment;

  export const METADATA = {
    method: "DELETE",
    path: "/attachments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attachments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IAttachment =>
    typia.random<IAttachment>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

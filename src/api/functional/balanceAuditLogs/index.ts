import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IBalanceAuditLog } from "../../structures/IBalanceAuditLog";
import { IPageIBalanceAuditLog } from "../../structures/IPageIBalanceAuditLog";

/**
 * Create a new balance audit log entry (balance_audit_logs table,
 * immutable/atomic).
 *
 * Creates a new audit log entry for user balance changes. Used by system or
 * admin actions when adjustments, credits, debits, or audit-worthy
 * interventions occur with user balances, deposits, or mileage. Request body
 * (see IBalanceAuditLog.ICreate) includes user_id, amount, event_type
 * ('credit', 'debit', 'adjustment', etc.), balance_type, description, and
 * optional reference (event_ref). Status is always completed.
 *
 * Validation rules: user existence, amount sign according to event_type
 * (credit=positive, debit=negative), balance_type required, optional refs must
 * reference active entities. Audit log is immutable. Returns created entity
 * with all audit fields. Errors: 400 (validation), 403 (forbidden), 404
 * (user/balance not found).
 *
 * @param props.body New audit log event data; see IBalanceAuditLog.ICreate.
 * @path /balanceAuditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** New audit log event data; see IBalanceAuditLog.ICreate. */
    body: IBalanceAuditLog.ICreate;
  };
  export type Body = IBalanceAuditLog.ICreate;
  export type Response = IBalanceAuditLog;

  export const METADATA = {
    method: "POST",
    path: "/balanceAuditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/balanceAuditLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBalanceAuditLog => typia.random<IBalanceAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search balance audit logs (balance_audit_logs table, paginated &
 * filtered).
 *
 * This endpoint retrieves a paginated, filterable set of balance audit logs.
 * Audit logs represent immutable, atomic operations/events on user_balances,
 * user_deposits, user_mileages, or related events in the PromotionsBalances
 * schemas. The request body may include pagination meta, filters for
 * user_id/balance_type/event_type/date range, sorting options, and optional
 * free-text description query. Response is a paged result of balance audit log
 * entries with all audit/compliance fields, plus total count, for analytic
 * dashboards or compliance exports.
 *
 * Typical uses: admin review of balance changes, compliance logs for customer
 * demands, internal fraud checks. Access restricted to admin/system roles per
 * RBAC. Error cases: 400 on invalid filter, 401/403 on access error. Data is
 * read-only via this endpoint.
 *
 * @param props.body Paging/filter/sort criteria for audit log query; see
 *   IBalanceAuditLog.IRequest.
 * @path /balanceAuditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Paging/filter/sort criteria for audit log query; see
     * IBalanceAuditLog.IRequest.
     */
    body: IBalanceAuditLog.IRequest;
  };
  export type Body = IBalanceAuditLog.IRequest;
  export type Response = IPageIBalanceAuditLog;

  export const METADATA = {
    method: "PATCH",
    path: "/balanceAuditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/balanceAuditLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIBalanceAuditLog => typia.random<IPageIBalanceAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a single user balance audit log entry (balance_audit_logs table, by ID).
 *
 * This endpoint retrieves one balance_audit_logs row by ID. Audit logs are
 * immutable; each row describes a single atomic event, referencing user,
 * affected balance, type, amount, and description. All fields are returned for
 * compliance reports and internal analysis. Error cases: 404 (not found), 410
 * (gone, if deleted), 403 (access error). No write operations permitted through
 * this endpoint, and RBAC restricts access to RBAC-compliant roles only.
 * Sensitive user details not revealed inline, but user FK is present for
 * reference.
 *
 * @param props.id Target balance_audit_logs row's ID.
 * @path /balanceAuditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target balance_audit_logs row's ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IBalanceAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/balanceAuditLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/balanceAuditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBalanceAuditLog => typia.random<IBalanceAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update audit/context info for a balance audit log entry (balance_audit_logs
 * table).
 *
 * This patch/put endpoint allows updating only allowed metadata fields of a
 * balance audit log record: description or event_ref. Primary context
 * (event_type, user_id, amount, balance_type) are immutable. Used by
 * admins/systems to attach more details or fix/correct free-form memo/context
 * refs after the main event is logged. All changes are tracked for
 * audit/reporting. This supports compliance and error correction after shipping
 * a report or audit. Used rarelyâ€”prefer immutable records.
 *
 * Fails if forbidden, or if trying to mutate immutable columns, returning 403.
 * Returns updated entry including all original and changed fields. Logs
 * meta-updates (never alters balances retroactively).
 *
 * @param props.id Target balance_audit_logs row's ID.
 * @param props.body Meta-update for audit log (description/event_ref only), see
 *   IBalanceAuditLog.IUpdate.
 * @path /balanceAuditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target balance_audit_logs row's ID. */
    id: string & tags.Format<"uuid">;

    /**
     * Meta-update for audit log (description/event_ref only), see
     * IBalanceAuditLog.IUpdate.
     */
    body: IBalanceAuditLog.IUpdate;
  };
  export type Body = IBalanceAuditLog.IUpdate;
  export type Response = IBalanceAuditLog;

  export const METADATA = {
    method: "PUT",
    path: "/balanceAuditLogs/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/balanceAuditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBalanceAuditLog => typia.random<IBalanceAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a balance audit log by ID (balance_audit_logs table).
 *
 * This API endpoint allows authorized users (typically admins or auditors) to
 * soft-delete a specific balance audit log entry by its unique ID. The deletion
 * is non-destructive, meaning the record is marked as deleted via the
 * deleted_at field but remains retrievable for compliance audits, fulfilling
 * the regulatory requirements for immutable history and auditability.
 *
 * Access to this endpoint should be tightly controlled through RBAC, as audit
 * log deletion may impact compliance reporting. The operation updates only the
 * targeted log entry and does not affect related balance records. If the log
 * entry is already marked as deleted or does not exist, an error indicating
 * 'not found' or 'already deleted' is returned.
 *
 * Calling this operation does not delete any user or financial record; its sole
 * purpose is compliance-driven log management. Related APIs include creation
 * and search of balance audit logs for investigation workflows.
 *
 * Error handling includes 404 for nonexistent IDs and 403 for insufficient
 * permissions.
 *
 * @param props.id Unique identifier of the balance audit log to be
 *   soft-deleted.
 * @path /balanceAuditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the balance audit log to be soft-deleted. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IBalanceAuditLog;

  export const METADATA = {
    method: "DELETE",
    path: "/balanceAuditLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/balanceAuditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBalanceAuditLog => typia.random<IBalanceAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

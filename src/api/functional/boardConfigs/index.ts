import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IBoardConfig } from "../../structures/IBoardConfig";
import { IPageIBoardConfig } from "../../structures/IPageIBoardConfig";
import { IEmpty } from "../../structures/IEmpty";

/**
 * Create a board configuration (board_configs table).
 *
 * This endpoint is used to create a board configuration object that defines
 * behavior, policies, and permissions for boards (discussion forums/Q&A/content
 * spaces) throughout the system. The operation allows administrators to specify
 * the configuration's name, a JSON structure of settings (for permissions,
 * moderation rules, etc.), and its version.
 *
 * Security: Only admin or superadmin roles should be able to access this
 * endpoint, as board configurations control business rules and user
 * permissions. All actions are logged for audit, and inputs are validated for
 * JSON schema compliance.
 *
 * Schema: board_configs - atomic fields include id (autogenerated UUID), name
 * (unique for version), settings_json (arbitrary structure, required), version
 * (integer, required), created_at (auto), and relations to boards. Board
 * configs are versioned for audit and rollback, allowing attribute evolution
 * without re-writing all consumer boards. Validation ensures duplicate
 * name+version is blocked.
 *
 * Related: After creating a configuration, a 'board' record may be created or
 * updated to reference this config. To update a configuration, use PUT
 * /boardConfigs/{id}, and to delete a config safely (soft delete), use DELETE
 * /boardConfigs/{id}.
 *
 * @param props.body The payload specifying the name, settings JSON, and version
 *   of the board configuration to create.
 * @path /boardConfigs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * The payload specifying the name, settings JSON, and version of the
     * board configuration to create.
     */
    body: IBoardConfig.ICreate;
  };
  export type Body = IBoardConfig.ICreate;
  export type Response = IBoardConfig;

  export const METADATA = {
    method: "POST",
    path: "/boardConfigs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/boardConfigs";
  export const random = (g?: Partial<typia.IRandomGenerator>): IBoardConfig =>
    typia.random<IBoardConfig>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve paginated, filterable list of board configuration templates from
 * board_configs table.
 *
 * This endpoint delivers a paginated, filterable list of board configuration
 * records as stored in the 'board_configs' table, forming the
 * policy/configuration layer for engagement boards and forums. Each config
 * entry includes version, name, serialized settings (JSON), and
 * timestamp—enabling boards to refer to or share configs for permission,
 * moderation, or AI settings.
 *
 * Clients provide advanced filter, pagination, and sort instructions within the
 * request body, often by searching config name, version, timestamp, or even
 * JSON field presence. The endpoint is typically used for admin configuration
 * dashboards, new board onboarding, and compliance/config audits. All access is
 * role/permission-controlled. Standard errors: 400 (validation), 403 (no
 * privilege), 500 (system fault).
 *
 * @param props.body Filtering, sorting, and pagination options for board config
 *   list retrieval.
 * @path /boardConfigs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filtering, sorting, and pagination options for board config list
     * retrieval.
     */
    body: IBoardConfig.IRequest;
  };
  export type Body = IBoardConfig.IRequest;
  export type Response = IPageIBoardConfig;

  export const METADATA = {
    method: "PATCH",
    path: "/boardConfigs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/boardConfigs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIBoardConfig => typia.random<IPageIBoardConfig>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve detailed metadata/policy for a board configuration by UUID from
 * board_configs table.
 *
 * This endpoint fetches the full atomic detail for a given board configuration
 * (policy/template) by UUID from the 'board_configs' table. Board configs
 * define granular engagement rules, moderation flags, and AI
 * integration/policies—typically referenced polymorphically by many boards. The
 * API validates the UUID, checks for access privilege (admin or engagement
 * config manager), and returns all data fields: name, settings (JSON), version,
 * timestamps. Used for onboarding, admin settings, or analytical dashboard
 * display.
 *
 * Requests for non-existent or deleted records return 404. Validation errors on
 * UUID return 400. Unauthorized users get 403. This operation may be chained
 * with PATCH (list) or PUT (edit).
 *
 * @param props.id UUID of the board config template to retrieve.
 * @path /boardConfigs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of the board config template to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IBoardConfig;

  export const METADATA = {
    method: "GET",
    path: "/boardConfigs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/boardConfigs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IBoardConfig =>
    typia.random<IBoardConfig>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing board configuration by id (board_configs table).
 *
 * This endpoint allows administrators to update an existing board
 * configuration, identified by its unique id. Possible updates include changing
 * the configuration name, modifying the JSON structure that defines
 * permissions/moderation/attachment rules, or incrementing the version.
 *
 * Security: Only admin/superadmin roles are permitted. Update operations are
 * audit-logged and subject to validation (name/version uniqueness, settings
 * JSON schema correctness). Soft delete logic may restrict updating deleted
 * configs.
 *
 * Schema: board_configs entity—fields updated include name, settings_json, and
 * version. Boards referencing this config are not automatically updated to a
 * newer config version by this endpoint.
 *
 * To remove (soft-delete) a config, use DELETE. Creating a new config version
 * should use POST /boardConfigs.
 *
 * @param props.id The id of the board configuration to update.
 * @param props.body The payload with new name, settings, or version.
 * @path /boardConfigs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The id of the board configuration to update. */
    id: string & tags.Format<"uuid">;

    /** The payload with new name, settings, or version. */
    body: IBoardConfig.IUpdate;
  };
  export type Body = IBoardConfig.IUpdate;
  export type Response = IBoardConfig;

  export const METADATA = {
    method: "PUT",
    path: "/boardConfigs/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/boardConfigs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IBoardConfig =>
    typia.random<IBoardConfig>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a board configuration by id (board_configs table).
 *
 * This endpoint marks a board configuration (board_configs row) as deleted. It
 * updates the deleted_at field, making the configuration unavailable for new
 * use but retaining complete audit history and version rollback capability.
 * Boards already using the configuration remain unaffected, but cannot
 * reference the config as 'current' after deletion.
 *
 * Security: Only admin/superadmin can delete. Soft-deletion logic preserves
 * compliance with immutable history requirements.
 *
 * Schema: board_configs - sets deleted_at to the current timestamp for the row
 * identified by id.
 *
 * RESTful: This does NOT cascade to delete boards, threads, or posts.
 *
 * @param props.id The id of the board configuration to delete.
 * @path /boardConfigs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** The id of the board configuration to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IEmpty;

  export const METADATA = {
    method: "DELETE",
    path: "/boardConfigs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/boardConfigs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IEmpty =>
    typia.random<IEmpty>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

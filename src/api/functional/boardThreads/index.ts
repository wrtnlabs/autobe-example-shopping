import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IBoardThread } from "../../structures/IBoardThread";
import { IPageIBoardThread } from "../../structures/IPageIBoardThread";
import { IEmpty } from "../../structures/IEmpty";

/**
 * Create a new board thread (board_threads table).
 *
 * Creates a new board thread attached to a specified board. The operation
 * allows either an admin or permitted member to start a new topic or question
 * within the correct discussion space (as linked to a board).
 *
 * Security: Board configuration and board membership/permission is
 * enforced—users must have rights according to board_config. Action is
 * audit-logged.
 *
 * Schema: board_threads - atomic fields include id (uuid), board_id, title,
 * created_at (server-generated), deleted_at. Thread can be immediately active
 * (not deleted).
 *
 * To update a thread, use PUT. For deletion of a thread, see DELETE. For
 * searching/listing, use PATCH /boardThreads.
 *
 * @param props.body Data for the new board thread, including board_id and
 *   title.
 * @path /boardThreads
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Data for the new board thread, including board_id and title. */
    body: IBoardThread.ICreate;
  };
  export type Body = IBoardThread.ICreate;
  export type Response = IBoardThread;

  export const METADATA = {
    method: "POST",
    path: "/boardThreads",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/boardThreads";
  export const random = (g?: Partial<typia.IRandomGenerator>): IBoardThread =>
    typia.random<IBoardThread>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List, filter, and paginate board threads (board_threads table).
 *
 * This endpoint returns a paged, filterable list of board threads, optionally
 * filtered/searched by board, title, creation date, or soft delete status.
 * Supports pagination (page, pageSize), full-text filtering (e.g. title
 * search), and extensible sorting (created_at descending by default).
 *
 * Security: Any authenticated user (member/admin) can list threads for a board
 * they have access to; permissions are enforced based on board configuration
 * (referenced via board_id/board_configs). Pagination and search parameters
 * prevent overfetch and support moderation workflows.
 *
 * Schema: board_threads - fields include id, board_id, title, created_at,
 * deleted_at. Related data such as board or author name may be joined in
 * service layer but are not guaranteed in base response type. For individual
 * thread get, use GET /boardThreads/{id}. To post a new thread, use POST
 * /boardThreads.
 *
 * @param props.body Paging, search, and filter parameters for listing board
 *   threads.
 * @path /boardThreads
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Paging, search, and filter parameters for listing board threads. */
    body: IBoardThread.IRequest;
  };
  export type Body = IBoardThread.IRequest;
  export type Response = IPageIBoardThread;

  export const METADATA = {
    method: "PATCH",
    path: "/boardThreads",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/boardThreads";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIBoardThread => typia.random<IPageIBoardThread>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve details of a board thread by id (board_threads table).
 *
 * Fetches a single board thread identified by uuid, returning atomic fields
 * (id, board_id, title, created_at, deleted_at if soft-deleted). If the thread
 * is not found or is deleted (and permissions do not allow access), a 404 or
 * permission error is returned as appropriate.
 *
 * Security: Any member (user/admin) with access to the board may view threads.
 * Board configuration (board_config) may further restrict view. Audit logs
 * include access for compliance and moderation review.
 *
 * Related endpoints: for listing, use PATCH /boardThreads; for updating, see
 * PUT /boardThreads/{id}. Deletion uses DELETE /boardThreads/{id}. Posting new
 * threads uses POST /boardThreads.
 *
 * @param props.id The id of the board thread to retrieve.
 * @path /boardThreads/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** The id of the board thread to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IBoardThread;

  export const METADATA = {
    method: "GET",
    path: "/boardThreads/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/boardThreads/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IBoardThread =>
    typia.random<IBoardThread>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a board thread by id (board_threads table).
 *
 * This operation updates an existing board thread; supported updates include
 * changing the thread's title or moving it to another board (changing
 * board_id). The update is restricted to permitted users (typically thread
 * creator or moderators/admins). Permission checks via board_config. All change
 * events are audit-logged.
 *
 * Schema: board_threads - updatable fields are title, board_id. Soft delete not
 * modified by this operation. Thread's posts are NOT updated here; only the
 * thread-level metadata.
 *
 * For single-thread read, use GET. For listing, see PATCH /boardThreads. To
 * soft-delete a thread, use DELETE /boardThreads/{id}.
 *
 * @param props.id The id of the board thread to update.
 * @param props.body Updates to thread properties—title and/or board_id.
 * @path /boardThreads/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The id of the board thread to update. */
    id: string & tags.Format<"uuid">;

    /** Updates to thread properties—title and/or board_id. */
    body: IBoardThread.IUpdate;
  };
  export type Body = IBoardThread.IUpdate;
  export type Response = IBoardThread;

  export const METADATA = {
    method: "PUT",
    path: "/boardThreads/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/boardThreads/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IBoardThread =>
    typia.random<IBoardThread>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a board thread by id (board_threads table).
 *
 * Soft-deletes a specific board thread by marking its deleted_at timestamp,
 * making it hidden from user view (permissions dependent) but preserving audit
 * history for compliance. The operation does not physically remove the thread
 * or its posts from storage.
 *
 * Security: Only moderators/admins (per board_config) can soft-delete.
 * Operation is always audit-logged.
 *
 * Schema: board_threads - sets deleted_at field for given id. Posts in the
 * thread are not directly affected. To restore, a recovery/undodelete endpoint
 * may later be added.
 *
 * @param props.id The id of the board thread to soft-delete.
 * @path /boardThreads/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** The id of the board thread to soft-delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IEmpty;

  export const METADATA = {
    method: "DELETE",
    path: "/boardThreads/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/boardThreads/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IEmpty =>
    typia.random<IEmpty>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

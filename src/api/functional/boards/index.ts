import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IBoard } from "../../structures/IBoard";
import { IPageIBoard } from "../../structures/IPageIBoard";

/**
 * Create a new board/forum in the boards table with supplied settings.
 *
 * The POST /boards endpoint accepts board creation configuration and writes a
 * new record to the boards table in the database. The client must supply all
 * mandatory board fields (name, channel_id, section_id (optional), config id,
 * plus human-readable description). Normalization is strictly maintained, with
 * config references immutable on creation. All input undergoes validation for
 * permissions, field correctness, and integrity: required fields,
 * channel/section must exist, config id must resolve to a live config. Admin,
 * engagement managers, or system integrators may create new boards. Error
 * scenarios include duplicate board name, missing foreign references, or
 * permission issues.
 *
 * Upon success, the endpoint returns the entire created board record (all
 * atomic fields). This operation is typically used when launching a new forum,
 * Q&A board, or notices panel within the Omni-channel backend.
 *
 * @param props.body Settings, configuration, and metadata for new board/forum
 *   creation.
 * @path /boards
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Settings, configuration, and metadata for new board/forum creation. */
    body: IBoard.ICreate;
  };
  export type Body = IBoard.ICreate;
  export type Response = IBoard;

  export const METADATA = {
    method: "POST",
    path: "/boards",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/boards";
  export const random = (g?: Partial<typia.IRandomGenerator>): IBoard =>
    typia.random<IBoard>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List, paginate, filter, and sort board/forum records from boards table.
 *
 * PATCH /boards implements the primary board retrieval interface—paginating,
 * filtering, and sorting the boards table according to flexible query criteria
 * from the request body. Boards define top-level community or discussion spaces
 * (per the Engagement & Board Systems requirements), referenced by admins or
 * system UX for lists, dashboards, or configuration panels. The boards table
 * includes fields for name, description, channel, section, config references,
 * and deletion status.
 *
 * Access is issued to users with engagement management or admin privileges,
 * supporting configurable filter criteria (e.g., channel_id, section_id, name
 * search, active/deleted flag, created_at window). This operation powers board
 * directory listings, admin overviews, and can feed dashboard analytics.
 * Clients specify arbitrary filters and pagination details in the request body.
 * Operational errors: 400 (bad filters), 403 (permission), 500 (internal
 * failure).
 *
 * @param props.body Filters, search fields, sort, and pagination config for
 *   board list retrieval.
 * @path /boards
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filters, search fields, sort, and pagination config for board list
     * retrieval.
     */
    body: IBoard.IRequest;
  };
  export type Body = IBoard.IRequest;
  export type Response = IPageIBoard;

  export const METADATA = {
    method: "PATCH",
    path: "/boards",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/boards";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIBoard =>
    typia.random<IPageIBoard>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve full metadata/configuration for a specific board/forum by UUID from
 * boards table.
 *
 * GET /boards/{id} retrieves the full set of metadata, configuration, and
 * display data for a specific engagement board or forum, as defined by the
 * 'boards' table. Boards represent community, Q&A, notice, or custom content
 * spaces, configured with fields like name, channel_id, section_id, config
 * references (for permissions/moderation), and deletion status. The endpoint
 * returns all atomic board attributes, enabling detailed rendering for admin
 * panels, management operations, or detailed analytics.
 *
 * Access to this endpoint is typically RBAC-protected, ensuring only users or
 * admins with discovery, engagement, or management rights can inspect a board’s
 * data. Upon valid request, the API validates the UUID and returns the complete
 * record; otherwise, 404 (not found), 400 (ID error), or 403 (privilege)
 * errors. Paired with PATCH (listing/filters) or PUT/DELETE for lifecycle
 * management, this completes CRUD for boards.
 *
 * @param props.id UUID of the board/forum to retrieve.
 * @path /boards/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of the board/forum to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IBoard;

  export const METADATA = {
    method: "GET",
    path: "/boards/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/boards/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IBoard =>
    typia.random<IBoard>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Overwrite/reconfigure an existing board/forum record in the boards table by
 * UUID.
 *
 * This endpoint provides write capability for updating or reconfiguring a
 * single board (UUID based), as stored in the engagement boards table. Allowed
 * for admins, engagement managers, or via automated configuration syncs, the
 * operation replaces all fields: name, description, channel/section ID,
 * configuration reference, and metadata. Normalization preserves reference
 * integrity: the request body must include all fields, changing only what is
 * actually present in the payload. Integrity checks enforce existence of
 * referenced config, and channel/section—error if foreign key missing. All
 * updates trigger audit events. Errors: 400 (validation/UUID), 404 (record
 * missing), 403 (permission), 409 (conflict/edit).
 *
 * @param props.id UUID of the board/forum record to update.
 * @param props.body Complete new board/forum configuration—replaces all present
 *   fields in boards table.
 * @path /boards/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of the board/forum record to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Complete new board/forum configuration—replaces all present fields in
     * boards table.
     */
    body: IBoard.IUpdate;
  };
  export type Body = IBoard.IUpdate;
  export type Response = IBoard;

  export const METADATA = {
    method: "PUT",
    path: "/boards/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/boards/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IBoard =>
    typia.random<IBoard>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete (logically remove) a single board/forum record in the boards
 * table by UUID for compliance.
 *
 * DELETE /boards/{id} marks a board or forum as deleted (sets deleted_at
 * timestamp) instead of actually removing it from the database, fulfilling
 * compliance and audit requirements for engagement systems. Soft-deletions
 * allow for audit/history restoration or legal review, never physically erasing
 * content. Privileged users—admins or engagement managers—may call this
 * endpoint. Requests with improper permissions, invalid UUIDs, or
 * already-deleted/absent records return 403/404/400 errors accordingly. The
 * operation returns a status or outcome message; no board data is returned. For
 * complete record removal or restore, additional endpoints/tools exist outside
 * basic CRUD.
 *
 * @param props.id UUID of the board/forum to soft-delete.
 * @path /boards/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the board/forum to soft-delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IBoard.IDeleteResponse;

  export const METADATA = {
    method: "DELETE",
    path: "/boards/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/boards/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBoard.IDeleteResponse => typia.random<IBoard.IDeleteResponse>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

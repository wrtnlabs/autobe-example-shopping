import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICategory } from "../../structures/ICategory";
import { IPageICategory } from "../../structures/IPageICategory";

/**
 * Create a new category (categories table).
 *
 * This endpoint serves to create a new category in the shopping mall backend,
 * implementing the flexible multi-level category tree required for
 * channel-specific product organization. Category creation supports assigning a
 * parent for nesting, a unique code per channel/parent, and descriptive
 * metadata for SEO/search.
 *
 * RBAC and permissions must be checked, typically allowing only administrators
 * or privileged sellers to create categories. Audit logs should capture
 * creation actions, including timestamp and actor. Categories are affiliated to
 * a channel, and validation ensures code uniqueness within context.
 *
 * The operation will reject attempts to create duplicate codes within the same
 * parent or channel, and will return error messages for missing/invalid data or
 * insufficient permissions. Typical related actions are listing categories
 * (/categories PATCH), updating a category (PUT), and soft-deleting (DELETE).
 *
 * @param props.body Category creation data including code, name, parent, and
 *   channel.
 * @path /categories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Category creation data including code, name, parent, and channel. */
    body: ICategory.ICreate;
  };
  export type Body = ICategory.ICreate;
  export type Response = ICategory;

  export const METADATA = {
    method: "POST",
    path: "/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/categories";
  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>
    typia.random<ICategory>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Search/List Category resources from categories table.
 *
 * Lists and searches Category entities using advanced filtering and pagination
 * criteria. Supports queries by channel_id, parent_id, code, display name,
 * display order, and soft-delete status. Returns hierarchy-aware results
 * compliant with category nesting requirements (parent_id).
 *
 * All requests are RBAC-verified for channel/section access. Support for
 * soft-deleted category visibility is optional. Returns all fields from the
 * categories schema including audit and compliance metadata. Designed for use
 * with category management, navigation, and merchandising UIs.
 *
 * @param props.body Category list filter/search/pagination request payload.
 * @path /categories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Category list filter/search/pagination request payload. */
    body: ICategory.IRequest;
  };
  export type Body = ICategory.IRequest;
  export type Response = IPageICategory;

  export const METADATA = {
    method: "PATCH",
    path: "/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/categories";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageICategory =>
    typia.random<IPageICategory>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get Category by ID (categories table).
 *
 * Retrieves full details of one Category resource specified by UUID ID. Returns
 * all schema-defined fields for the target record, including code, names,
 * parent_id, display order, audit metadata (created_at, updated_at,
 * deleted_at). Channel-level RBAC/authorization determines access rights for
 * the lookup.
 *
 * Error handling includes not-found, deleted, or unpermitted resources. Used
 * together with category list, create, update, and delete endpoints for
 * category/master-data management in channel contexts. Audit logs may be
 * produced for trace/compliance.
 *
 * @param props.id Unique ID (UUID) of Category record to retrieve.
 * @path /categories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique ID (UUID) of Category record to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICategory;

  export const METADATA = {
    method: "GET",
    path: "/categories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/categories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>
    typia.random<ICategory>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a category by id (categories table).
 *
 * This endpoint enables updating of a specific category's details, such as its
 * display name, code, parent assignment for hierarchy restructuring, or
 * descriptive properties. It is part of the system's requirement to allow
 * dynamic category management per channel.
 *
 * Only authorized users (typically admins or sellers with appropriate rights)
 * may update categories. All updates are tracked for audit purposes, logging
 * the actor and change details. This endpoint should validate uniqueness of
 * code within channel and parent, and maintain referential integrity for
 * parent-child links.
 *
 * If the requested update would introduce circular category references, an
 * error is returned. Supporting endpoints include POST for creation, DELETE for
 * soft deletion, and PATCH for organized search/listing.
 *
 * @param props.id Target category's ID
 * @param props.body Category update data (name, code, parent, order, or
 *   descriptions).
 * @path /categories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target category's ID */
    id: string & tags.Format<"uuid">;

    /** Category update data (name, code, parent, order, or descriptions). */
    body: ICategory.IUpdate;
  };
  export type Body = ICategory.IUpdate;
  export type Response = ICategory;

  export const METADATA = {
    method: "PUT",
    path: "/categories/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/categories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>
    typia.random<ICategory>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft delete a category by id (categories table).
 *
 * This endpoint implements logical deletion (soft-delete) of a category by ID,
 * in compliance with business and legal requirements for immutable audit
 * trails. On request, the deleted_at column is set, removing the category from
 * active listing but preserving the record for compliance.
 *
 * Soft deletion can only be performed by users with the necessary permissions
 * (typically admins). Attempts to delete a non-existent or already deleted
 * category result in informative error responses. All deletion actions should
 * be audit-logged with actor and timestamp details.
 *
 * Related endpoints are PATCH for searching/listing, POST for creation, and PUT
 * for updates to existing categories.
 *
 * @param props.id Target category's ID
 * @path /categories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target category's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICategory;

  export const METADATA = {
    method: "DELETE",
    path: "/categories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/categories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>
    typia.random<ICategory>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

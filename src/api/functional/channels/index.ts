import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IChannel } from "../../structures/IChannel";
import { IPageIChannel } from "../../structures/IPageIChannel";

/**
 * Create a new Channel resource (channels table).
 *
 * Creates a new Channel entity in the system. The payload must provide all
 * required fields as per the 'channels' table spec (code, name, etc.). The
 * operation checks RBAC policies to ensure the requesting user is authorized to
 * add channels. Field uniqueness (especially code) and normalization are
 * validated, with clear error messages on conflict/validation failure.
 *
 * On successful creation, returns the normalized Channel resource as stored in
 * the database, including metadata fields. The operation is fully auditable,
 * with logs created for later compliance review (created_at, etc.). Used in
 * conjunction with Channel list, get, update, and delete endpoints for complete
 * multi-store implementation.
 *
 * @param props.body Payload for creating a Channel resource.
 * @path /channels
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Payload for creating a Channel resource. */
    body: IChannel.ICreate;
  };
  export type Body = IChannel.ICreate;
  export type Response = IChannel;

  export const METADATA = {
    method: "POST",
    path: "/channels",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/channels";
  export const random = (g?: Partial<typia.IRandomGenerator>): IChannel =>
    typia.random<IChannel>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Search and list Channel resources from the channels table.
 *
 * This operation retrieves a list of Channel entities according to search,
 * filter, pagination, and sorting parameters. It enables users with proper
 * permissions (typically admins) to locate and manage storefront or brand
 * contexts at scale. All Channel data includes metadata, including audit/log
 * fields such as created_at, updated_at, and deleted_at.
 *
 * User permissions are enforced (RBAC); deleted (soft-deleted) channels can be
 * optionally included/excluded for compliance. All search and filter behavior
 * is aligned with the 'channels' Prisma model, with parameters for code, name,
 * date range, and soft delete status. Complex query construction and security
 * rules are supported.
 *
 * This endpoint works in concert with Channel create, update, get and delete
 * APIs, providing an entry point for channel-level configuration and
 * navigation. Validation ensures no security breach or data leakage regarding
 * administrative metadata. Error responses include RBAC violations and invalid
 * filter values.
 *
 * @param props.body List search/filter/pagination criteria for channels.
 * @path /channels
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** List search/filter/pagination criteria for channels. */
    body: IChannel.IRequest;
  };
  export type Body = IChannel.IRequest;
  export type Response = IPageIChannel;

  export const METADATA = {
    method: "PATCH",
    path: "/channels",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/channels";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIChannel =>
    typia.random<IPageIChannel>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get detailed Channel resource by ID from channels table.
 *
 * This endpoint retrieves all details for a specific Channel entity, including
 * its code, name, and various metadata (timestamps, state, etc.). Security
 * validation (RBAC) ensures only authorized users (admins/staff with proper
 * role) may access sensitive or administrative channels. The returned object
 * includes every normalized field from the database, including all
 * audit/compliance fields (created_at, updated_at, deleted_at).
 *
 * The API enforces error handling for missing or deleted channels, and will
 * reject requests for channels the user lacks permissions to view. Works in
 * concert with Channel list, create, update, and delete APIs, forming a
 * complete management suite for storefronts and marketplaces. Tracking and
 * audit logs may be generated upon access, per compliance policy.
 *
 * @param props.id Unique ID (UUID) of the Channel resource to fetch.
 * @path /channels/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique ID (UUID) of the Channel resource to fetch. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IChannel;

  export const METADATA = {
    method: "GET",
    path: "/channels/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/channels/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IChannel =>
    typia.random<IChannel>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update Channel resource by ID (channels table).
 *
 * Updates a Channel resource with the provided data. The endpoint locates the
 * Channel by unique ID (UUID), validates RBAC permissions for update intent,
 * and applies the changes. Fields match the Prisma 'channels' table spec;
 * validation prevents violation of normalization and uniqueness constraints
 * (e.g., code collisions).
 *
 * The operation updates audit fields (updated_at) and preserves full change
 * history for compliance. Used by admins or system integrations as part of
 * storefront/brand management. Returned data is the post-update, normalized
 * resource as stored in the database.
 *
 * @param props.id Unique ID (UUID) of the Channel to update.
 * @param props.body Payload for Channel update operation.
 * @path /channels/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique ID (UUID) of the Channel to update. */
    id: string & tags.Format<"uuid">;

    /** Payload for Channel update operation. */
    body: IChannel.IUpdate;
  };
  export type Body = IChannel.IUpdate;
  export type Response = IChannel;

  export const METADATA = {
    method: "PUT",
    path: "/channels/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/channels/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IChannel =>
    typia.random<IChannel>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a Channel resource by ID (channels table).
 *
 * This endpoint performs a soft-delete of a Channel resource, setting
 * deleted_at to indicate logical removal while keeping all audit and compliance
 * data intact. Security checks (RBAC) validate that only authorized users or
 * systems may perform deletions. In the event of errors (non-existent or
 * already deleted resource, or permission denial), the API returns appropriate
 * errors.
 *
 * No data is physically removed; the resource may be recovered or reviewed for
 * compliance history. This operation is part of the complete channel lifecycle
 * management suite (list, get, create, update, delete). The operation is logged
 * for audit trails.
 *
 * @param props.id Unique ID (UUID) of the Channel target for deletion.
 * @path /channels/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique ID (UUID) of the Channel target for deletion. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IChannel;

  export const METADATA = {
    method: "DELETE",
    path: "/channels/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/channels/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IChannel =>
    typia.random<IChannel>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

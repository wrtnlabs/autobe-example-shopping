import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICouponRedemption } from "../../structures/ICouponRedemption";
import { IPageICouponRedemption } from "../../structures/IPageICouponRedemption";

/**
 * Create a new coupon redemption record in 'coupon_redemptions'.
 *
 * This endpoint allows users (or the system) to record a new coupon redemption
 * event, whether as part of user-initiated claiming, automatic system
 * assignment, or code-based redemption. The operation performs extensive
 * validation, including coupon existence, not exceeding redemption quotas, user
 * eligibility, claim period checks, and optionally, fraud screening. All
 * mutation attempts are logged for compliance. The resulting record includes
 * user/coupon linkage, status, timestamps, and fraud check reference if
 * present. Errors include eligibility failure, duplicate attempts, or business
 * logic/rate limits. RBAC ensures only authorized flows can invoke this.
 * Related endpoints: coupon creation, user assignment APIs. Used by mobile
 * apps, web portals, and admin systems.
 *
 * @param props.body Coupon redemption creation info: user, coupon, claim
 *   timestamp, optional fraud reference.
 * @path /couponRedemptions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Coupon redemption creation info: user, coupon, claim timestamp,
     * optional fraud reference.
     */
    body: ICouponRedemption.ICreate;
  };
  export type Body = ICouponRedemption.ICreate;
  export type Response = ICouponRedemption;

  export const METADATA = {
    method: "POST",
    path: "/couponRedemptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/couponRedemptions";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ICouponRedemption => typia.random<ICouponRedemption>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Returns a filtered and paginated list of coupon redemption records from the
 * 'coupon_redemptions' table.
 *
 * This API operation allows privileged users to retrieve a filtered and
 * paginated list of coupon redemptions for auditing, analytics, or customer
 * service. The endpoint enforces RBAC so that only authorized roles can view
 * redemption history, including sensitive information about user, coupon, fraud
 * checks, and state transitions. The response data contains per-redemption
 * entity details, including assignment and usage timestamps, linked coupon and
 * user IDs, redemption outcome state, and optionally a reference to any
 * anti-fraud review. All filter parameters are validated against legal/business
 * constraints. The operation is critical for supporting compliance auditing,
 * campaign effectiveness review, and user entitlement resolution. Related
 * endpoints: coupon creation, redemption status update, and fraud check audits.
 * In the event of non-compliant access or unsupported filters, descriptive
 * errors are returned. Typical pagination includes page size, number, filters
 * on redemption status, date, coupon, and user identity.
 *
 * @param props.body Redemption query, filtering, and pagination options.
 * @path /couponRedemptions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Redemption query, filtering, and pagination options. */
    body: ICouponRedemption.IRequest;
  };
  export type Body = ICouponRedemption.IRequest;
  export type Response = IPageICouponRedemption;

  export const METADATA = {
    method: "PATCH",
    path: "/couponRedemptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/couponRedemptions";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageICouponRedemption => typia.random<IPageICouponRedemption>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a single coupon redemption record by ID from 'coupon_redemptions' table.
 *
 * Fetches a single coupon redemption record by its unique identifier. Ensures
 * full access control checks, as coupon redemptions may contain sensitive logs
 * about user participation in campaigns, rewards acquired, fraud attempt
 * tracking, and audit trails. The response returns all entity fields, including
 * assignment/claim/redeemed/expired timestamps and user/coupon/fraud check
 * links. If the entity is not found or the accessing client lacks proper RBAC
 * clearance, a compliant not-found or forbidden error is returned. In-use for
 * analytics dashboards, support customer troubleshooting, and campaign outcome
 * tracing. Related endpoints: PATCH coupon aggregations, PUT updates. Designed
 * for legal audit trail and analytic traceability.
 *
 * @param props.id Coupon redemption record unique identifier.
 * @path /couponRedemptions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Coupon redemption record unique identifier. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICouponRedemption;

  export const METADATA = {
    method: "GET",
    path: "/couponRedemptions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/couponRedemptions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ICouponRedemption => typia.random<ICouponRedemption>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a coupon redemption record in 'coupon_redemptions' by ID.
 *
 * This endpoint enables authorized staff or system processes to fully update a
 * coupon redemption record by its ID. Used for reconciliation after support
 * cases, post-fraud resolution, or compliance review. Validates against full
 * lifecycle state machine for coupon redemptions, restricting impermissible
 * updates and enforcing audit-trail policies. Updates to sensitive fields such
 * as status or fraud references are only permitted under proper RBAC
 * constraints and with full logging. RBAC validation is performed for every
 * mutation. Not found or denied attempts are fully logged and error-resolved.
 * Only auditable, permissible field changes are allowed. Related/paired
 * endpoints: PATCH list, GET detail, DELETE for removing faulty redemptions.
 *
 * @param props.id Coupon redemption record unique identifier.
 * @param props.body Redemption record update. All updatable fields allowed as
 *   per schema comments and lifecycle rules.
 * @path /couponRedemptions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Coupon redemption record unique identifier. */
    id: string & tags.Format<"uuid">;

    /**
     * Redemption record update. All updatable fields allowed as per schema
     * comments and lifecycle rules.
     */
    body: ICouponRedemption.IUpdate;
  };
  export type Body = ICouponRedemption.IUpdate;
  export type Response = ICouponRedemption;

  export const METADATA = {
    method: "PUT",
    path: "/couponRedemptions/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/couponRedemptions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ICouponRedemption => typia.random<ICouponRedemption>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a coupon redemption record in 'coupon_redemptions' by ID.
 *
 * Soft-deletes a coupon redemption record, marking it as deleted for business,
 * analytics, or legal retention. The actual data is never physically removed,
 * per data compliance requirements (e.g., GDPR/CCPA). All deletions are logged
 * for audit, and attempted deletions of protected or immutable records are
 * gracefully rejected with error messaging. Typical use: admin cleanup, error
 * correction, or fraud evidence preservation. Related endpoints include
 * restore/recover functionalities to undelete records if needed. RBAC strictly
 * governs access. Not-found/forbidden paths are error handled to enable
 * compliant operation.
 *
 * @param props.id Coupon redemption record unique identifier.
 * @path /couponRedemptions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Coupon redemption record unique identifier. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICouponRedemption;

  export const METADATA = {
    method: "DELETE",
    path: "/couponRedemptions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/couponRedemptions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ICouponRedemption => typia.random<ICouponRedemption>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

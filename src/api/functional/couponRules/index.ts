import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICouponRule } from "../../structures/ICouponRule";
import { IPageICouponRule } from "../../structures/IPageICouponRule";

/**
 * Create a coupon rule (POST /couponRules).
 *
 * This API endpoint creates a new coupon rule in the coupon_rules table,
 * supporting full rule configuration (eligibility, exclusion, dates,
 * AI/advanced logic in config) as per campaign/compliance requirements. The
 * request body must conform to ICouponRuleCreate for required/optional fields.
 *
 * The operation is RBAC-limited to admins, marketing, or partner systems.
 * Creation is audit-logged with actor, timestamp, and content for compliance.
 *
 * Related endpoints: PATCH for full list/search, GET /couponRules/{id} for
 * retrieval, PUT /couponRules/{id} for update/correction. Deletion is with
 * DELETE /couponRules/{id} (audit/soft delete, never physical removal per
 * compliance).
 *
 * @param props.body Coupon rule creation info (eligibility, exclusion, date,
 *   config, etc).
 * @path /couponRules
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Coupon rule creation info (eligibility, exclusion, date, config,
     * etc).
     */
    body: ICouponRule.ICreate;
  };
  export type Body = ICouponRule.ICreate;
  export type Response = ICouponRule;

  export const METADATA = {
    method: "POST",
    path: "/couponRules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/couponRules";
  export const random = (g?: Partial<typia.IRandomGenerator>): ICouponRule =>
    typia.random<ICouponRule>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Advanced search and filter for coupon rules (PATCH /couponRules).
 *
 * This PATCH endpoint provides advanced search, filtering, and sorting for the
 * coupon_rules table. It supports filter-by-coupon, eligibility, start/end
 * time, and extended rule search parameters. Pagination and sorting are
 * available for large-scale operations or compliance/reporting use cases.
 *
 * The request body must conform to the ICouponRuleSearchRequest schema,
 * specifying filter fields (coupon id, eligibility, activation period, etc),
 * desired sorting (by date, type, etc), and pagination (page, pageSize).
 *
 * Results are delivered in paginated IPageICouponRule format, including hit
 * count and standard metadata. Access is RBAC restricted to admins, campaign
 * operators, or compliance staff; individual rule details are available via GET
 * /couponRules/{id}.
 *
 * For creation and update, see POST and PUT /couponRules endpoints. Deletion is
 * handled via DELETE /couponRules/{id}, which soft-deletes the record but
 * preserves compliance audit.
 *
 * @param props.body Search/filter criteria for coupon rule list retrieval.
 * @path /couponRules
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filter criteria for coupon rule list retrieval. */
    body: ICouponRule.IRequest;
  };
  export type Body = ICouponRule.IRequest;
  export type Response = IPageICouponRule;

  export const METADATA = {
    method: "PATCH",
    path: "/couponRules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/couponRules";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageICouponRule => typia.random<IPageICouponRule>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a coupon rule by id (coupon_rules table).
 *
 * This API operation returns the full information of a single coupon rule by
 * its unique id (UUID) in the coupon_rules table. Used by admins, reporting,
 * and for reviewing rule eligibility in campaign/analytics tools.
 *
 * The operation is accessible to RBAC-controlled roles (admins, campaign
 * operators, compliance). Soft-deleted or inactive records include status in
 * response if permitted.
 *
 * Typical use cases: campaign eligibility audit, compliance reviews, campaign
 * manager interfaces, or troubleshooting rule issues.
 *
 * Returns 404 NotFound if no such rule exists or RBAC denies. For advanced
 * list/search, use PATCH /couponRules. For creation and update, see POST and
 * PUT endpoints; delete with DELETE /couponRules/{id}.
 *
 * @param props.id UUID of the coupon rule to retrieve.
 * @path /couponRules/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of the coupon rule to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICouponRule;

  export const METADATA = {
    method: "GET",
    path: "/couponRules/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/couponRules/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICouponRule =>
    typia.random<ICouponRule>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update (fully replace) a coupon rule by id (coupon_rules table).
 *
 * This API operation updates/replaces an existing coupon rule in the
 * coupon_rules table identified by its UUID primary key. All business,
 * eligibility, and technical fields are supplied in the ICouponRuleUpdate
 * request; operation is a full replacement, not partial patch. Changes are
 * audit-logged for compliance.
 *
 * RBAC applies: only admins, campaign managers, or authorized partners may
 * update rules. Soft-deleted rules cannot be updated; NotFound returned for
 * missing/inactive records.
 *
 * After update, returns the full updated ICouponRule record. Use GET
 * /couponRules/{id} to retrieve detail, PATCH for search/list. DELETE for
 * soft-removal/audit.
 *
 * All update operations must preserve compliance, eligibility, and legal
 * context (PCI/AML/GDPR) for the coupon rule system.
 *
 * @param props.id UUID of the coupon rule to update.
 * @param props.body Full replacement data for the coupon rule record.
 * @path /couponRules/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of the coupon rule to update. */
    id: string & tags.Format<"uuid">;

    /** Full replacement data for the coupon rule record. */
    body: ICouponRule.IUpdate;
  };
  export type Body = ICouponRule.IUpdate;
  export type Response = ICouponRule;

  export const METADATA = {
    method: "PUT",
    path: "/couponRules/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/couponRules/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICouponRule =>
    typia.random<ICouponRule>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a coupon rule by id (coupon_rules).
 *
 * This API endpoint marks a coupon rule as deleted (soft delete) by updating
 * the deleted_at field of the coupon_rules record referenced by its UUID id. No
 * hard deletion is performed to meet compliance and audit regulations.
 *
 * Only available to RBAC-limited actors (admin/campaign managers/compliance
 * staff). Deletion event is always audit-logged (actor, reason, timestamp).
 * Related endpoints: GET for details, PATCH for advanced list/search, PUT for
 * update/correction, POST for creation.
 *
 * Attempting to delete a non-existent or already deleted coupon rule returns
 * NotFound. Deleting a rule that is actively assigned or referenced in campaign
 * logic may require extra justification and may return Conflict/Forbidden if
 * RBAC or business rules require. This is to preserve historical/campaign
 * compliance integrity.
 *
 * @param props.id UUID of the coupon rule to soft-delete.
 * @path /couponRules/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the coupon rule to soft-delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICouponRule;

  export const METADATA = {
    method: "DELETE",
    path: "/couponRules/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/couponRules/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICouponRule =>
    typia.random<ICouponRule>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICoupon } from "../../structures/ICoupon";
import { IPageICoupon } from "../../structures/IPageICoupon";

/**
 * Create a new coupon (POST /coupons).
 *
 * This endpoint creates a new coupon in the coupons table, supporting all
 * coupon types (public, private, code-based) and settings as required by the
 * campaign, business, and compliance requirements. The request body conforms to
 * the ICouponCreate schema, enforcing validation on required fields (channel,
 * code/type, expiry, limits, stacking, etc).
 *
 * Only authorized staff (typically admins, marketing, or partner integration
 * systems) may access this operationâ€”RBAC-restricted. Created records
 * automatically log audit trails including creator and timestamps for later
 * compliance export. Upon success, the full coupon record (ICoupon) is returned
 * including system-assigned uuid.
 *
 * Error responses include: Conflict (for duplicate code or rules), Validation
 * errors, and Forbidden (insufficient privilege).
 *
 * Recommended related endpoints: PATCH /coupons for advanced list/search, GET
 * /coupons/{id} for retrieval, PUT /coupons/{id} for full update.
 *
 * Deletion via DELETE /coupons/{id}. Use PUT for full record update; PATCH for
 * partial update is not recommended for compliance fields.
 *
 * @param props.body Coupon creation information (required fields: type,
 *   code/stacking, expiry, etc).
 * @path /coupons
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Coupon creation information (required fields: type, code/stacking,
     * expiry, etc).
     */
    body: ICoupon.ICreate;
  };
  export type Body = ICoupon.ICreate;
  export type Response = ICoupon;

  export const METADATA = {
    method: "POST",
    path: "/coupons",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/coupons";
  export const random = (g?: Partial<typia.IRandomGenerator>): ICoupon =>
    typia.random<ICoupon>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Search and list coupons with advanced filters (PATCH /coupons).
 *
 * This endpoint enables authorized admins or partners to perform a complex
 * list/search query on the coupons table, supporting advanced filtering (by
 * code, channel, type, expiry, stackability), sorting, and full-text/pattern
 * matching for compliance and analytics.
 *
 * The request body conforms to ICouponSearchRequest schema, allowing
 * specification of filter fields (e.g., by status, valid/expired, usage count),
 * search term, sorting parameters (by expiry, creation, title), and standard
 * pagination (page, pageSize).
 *
 * Access is RBAC protected and typically available to marketing managers,
 * compliance auditors, or admin staff.
 *
 * Results are paginated as per the IPageICoupon response schema, including
 * coupon data and pagination metadata (total, page, pageSize, etc).
 *
 * This endpoint is recommended for backend/admin UIs for coupon management,
 * compliance audit exports, or data analysis pipelines. Use GET /coupons/{id}
 * to fetch a specific coupon by id. POST /coupons for creation, and PUT
 * /coupons/{id} for full update.
 *
 * @param props.body Search/filter criteria for coupon list retrieval.
 * @path /coupons
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filter criteria for coupon list retrieval. */
    body: ICoupon.IRequest;
  };
  export type Body = ICoupon.IRequest;
  export type Response = IPageICoupon;

  export const METADATA = {
    method: "PATCH",
    path: "/coupons",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/coupons";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageICoupon =>
    typia.random<IPageICoupon>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a coupon by id (coupons table).
 *
 * This API operation fetches the full information of a single coupon by its
 * unique identifier (UUID) from the coupons table. This is the standard detail
 * retrieval endpoint for coupon management, auditing, and customer-facing
 * systems that validate coupon data before redemption or display.
 *
 * Retrieval is RBAC-protected and can be accessed by admins, marketing
 * managers, compliance auditors, or systems needing to validate a coupon. If
 * the coupon is soft-deleted or expired, the status is returned in the record
 * for business/compliance clarity.
 *
 * Key use cases include: 1) Displaying coupon details for management or
 * redemption; 2) Validating coupon eligibility or rules client-side; 3)
 * Auditing coupon use, status, and campaign effectiveness.
 *
 * Returns 404 NotFound if the coupon id does not exist or is not visible to the
 * actor (based on soft-delete and RBAC rules). Related endpoints: PATCH
 * /coupons for list/search, POST /coupons for creation, PUT /coupons/{id} for
 * full update, DELETE /coupons/{id} for removal.
 *
 * @param props.id UUID of the coupon to retrieve.
 * @path /coupons/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of the coupon to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICoupon;

  export const METADATA = {
    method: "GET",
    path: "/coupons/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/coupons/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICoupon =>
    typia.random<ICoupon>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update (fully replace) a coupon by id.
 *
 * This endpoint updates/replaces an existing coupon record by its UUID primary
 * key. The operation requires full body replacement: all business, campaign,
 * and compliance fields must be supplied (as per ICouponUpdate schema). It
 * strictly logs old/new values for regulatory audit (e.g., for tracking changes
 * in coupon rules, expiry, eligibility, etc).
 *
 * Update operations are RBAC-restricted to authorized admins, marketing, or
 * compliance-controlled integrations. Change events are audit-logged with
 * actor, reason, and timestamp fields.
 *
 * If the coupon record does not exist, or is already soft-deleted, returns
 * NotFound. Validation and conflict errors (e.g., code duplication, invalid
 * expiry/limits) are handled as standard.
 *
 * Related endpoints: GET /coupons/{id} for detail, POST /coupons for creation,
 * DELETE /coupons/{id} for removal. PATCH /coupons can be used for list/filter
 * only (not partial update).
 *
 * Soft deletion is performed via DELETE /coupons/{id}. Full update is required
 * to remain PCI/GDPR-compliant, as partial update may introduce compliance
 * risks.
 *
 * @param props.id UUID of the coupon to update.
 * @param props.body Full replacement data for the coupon record (type,
 *   code/stacking, expiry, etc).
 * @path /coupons/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of the coupon to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Full replacement data for the coupon record (type, code/stacking,
     * expiry, etc).
     */
    body: ICoupon.IUpdate;
  };
  export type Body = ICoupon.IUpdate;
  export type Response = ICoupon;

  export const METADATA = {
    method: "PUT",
    path: "/coupons/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/coupons/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICoupon =>
    typia.random<ICoupon>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft delete (flag as deleted) a coupon by id (coupons table).
 *
 * This endpoint marks a coupon record as deleted by setting its deleted_at
 * field to the current timestamp, in compliance with audit, GDPR, and PCI
 * requirements. No physical removal occurs; the record is preserved for audit,
 * analytics, and regulatory reporting.
 *
 * This operation is only allowed for RBAC-authorized users (admins, campaign
 * managers, compliance officers). Deletion actions are logged with reason,
 * actor, and timestamp in audit logs.
 *
 * Related endpoints: PUT /coupons/{id} for update/correction, GET /coupons/{id}
 * for retrieval, PATCH /coupons for search. Attempting to delete a record that
 * does not exist or is already deleted returns NotFound.
 *
 * Deletion should not disrupt related entity chains (e.g., redemptions, rules)
 * for compliance; soft delete ensures immutable campaign/audit history.
 *
 * @param props.id UUID of the coupon to delete.
 * @path /coupons/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the coupon to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICoupon;

  export const METADATA = {
    method: "DELETE",
    path: "/coupons/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/coupons/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICoupon =>
    typia.random<ICoupon>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

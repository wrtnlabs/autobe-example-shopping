import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDonation } from "../../structures/IDonation";
import { IPageIDonation } from "../../structures/IPageIDonation";

/**
 * Create a new donation (donations table).
 *
 * This operation creates a new donation record, with client-provided details
 * including donating user (by ID), amount, target, status, event reference, and
 * timestamp. The API validates the payload according to business rules and
 * campaign compliance, then persists the donation. After creation, the new
 * donation object (with assigned ID, status, linkage to refund or related
 * entity as needed) is returned.
 *
 * RBAC and compliance business rules determine which users or administrators
 * may initiate donations and the kinds of targets eligible for donations
 * (configured per campaign, region, or organization policies). The endpoint is
 * critical for donation campaign onboarding, refund-to-donation workflows, and
 * audit trails of non-profit flows. Additional actions (like notification or
 * export) may be triggered on successful creation.
 *
 * Error handling: validation errors, policy/procedure errors (e.g., unapproved
 * targets), and RBAC permission failures.
 *
 * @param props.body Donation creation details (user, amount, target, etc).
 * @path /donations
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Donation creation details (user, amount, target, etc). */
    body: IDonation.ICreate;
  };
  export type Body = IDonation.ICreate;
  export type Response = IDonation;

  export const METADATA = {
    method: "POST",
    path: "/donations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/donations";
  export const random = (g?: Partial<typia.IRandomGenerator>): IDonation =>
    typia.random<IDonation>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Search and list paginated donations (donations table).
 *
 * This API finds and returns a filtered, sorted, and paginated page of donation
 * records from the 'donations' table. Filters may include user ID, status,
 * donation target, completion window, amount, and other compliance-sensitive or
 * business-relevant properties. Extensible design allows for new filter types
 * as future business needs evolve.
 *
 * Supports robust pagination and sort for high-volume donation programs. Used
 * in dashboards, compliance exports, or user self-service views. Results do not
 * expose direct PII but reference users/entities; details can be fetched
 * individually via detail endpoints.
 *
 * Strict RBAC and contextual permission ensure only authorized users (e.g.,
 * admins, compliance, or campaign managers) access the listing.
 *
 * Error handling: input validation, RBAC failures, and not found errors for
 * improper queries. This operation is useful for reporting, analytics, or
 * regulatory export automation.
 *
 * @param props.body Donation search filters, pagination, and sorting options.
 * @path /donations
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Donation search filters, pagination, and sorting options. */
    body: IDonation.IRequest;
  };
  export type Body = IDonation.IRequest;
  export type Response = IPageIDonation;

  export const METADATA = {
    method: "PATCH",
    path: "/donations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/donations";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIDonation =>
    typia.random<IPageIDonation>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get details of a donation by ID (donations table).
 *
 * Fetch all known data for a specific donation. This endpoint returns the full
 * donation record, including links to the donating user (by ID), target entity,
 * amount, status, region, creation timestamp, and additional properties as
 * required. Details are only supplied to users with sufficient permissions for
 * privacy and compliance; this typically means the owner, admin, or campaign
 * processors.
 *
 * Errors include 404 if the donation does not exist and 403 for unauthorized
 * access due to RBAC restrictions.
 *
 * This detail endpoint helps audit/track the life cycle and compliance status
 * of all donation flows across refund, campaign, or external integration
 * workflows. It supports integration with external payment, ERP, or compliance
 * systems.
 *
 * Related endpoints: paginated donation search, create/update, and deletion.
 *
 * @param props.id Unique identifier of the donation to retrieve.
 * @path /donations/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier of the donation to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDonation;

  export const METADATA = {
    method: "GET",
    path: "/donations/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/donations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IDonation =>
    typia.random<IDonation>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a donation by ID (donations table).
 *
 * This endpoint enables authorized users (admins/compliance/campaign managers)
 * to update a donation by its ID. Permitted update fields include status (e.g.,
 * pending, completed, canceled), amount (with appropriate checks), donation
 * target, or additional references. Change is audit-logged per
 * compliance/process requirements, and the updated donation is returned on
 * success.
 *
 * Business logic and compliance controls must be followed; injections of
 * arbitrary reference or status are validated strictly. 404 returned for
 * missing donation ID. Updates to deleted donations are generally forbidden
 * unless for restoration/undo.
 *
 * Related: paginated donations search, detail view, create, and delete
 * endpoints. Notification or external sync triggers on certain updates may be
 * handled externally.
 *
 * Error handling: validation issues, permission/RBAC errors, or update
 * conflicts.
 *
 * @param props.id Unique identifier of the donation to update.
 * @param props.body Fields to be updated and new values for the donation.
 * @path /donations/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier of the donation to update. */
    id: string & tags.Format<"uuid">;

    /** Fields to be updated and new values for the donation. */
    body: IDonation.IUpdate;
  };
  export type Body = IDonation.IUpdate;
  export type Response = IDonation;

  export const METADATA = {
    method: "PUT",
    path: "/donations/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/donations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IDonation =>
    typia.random<IDonation>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a donation by ID (donations table).
 *
 * This endpoint allows for soft-deletion of a donation record by setting its
 * deleted_at field. Only authorized users (admins, campaign staff with
 * appropriate permission) are allowed to execute this operation to maintain
 * audit trails. The historical donation record is retained for audit,
 * reporting, or compliance requirements, and physically remains in the
 * database.
 *
 * Errors: 404 if already deleted or not found. Deleting a donation does not
 * impact the underlying financial flows, and the record remains in
 * exports/history where required by regulation or reporting.
 *
 * Returned data includes the soft-deleted donation record or a confirmation
 * message. Related endpoints: donation list/search, detail, create and update.
 *
 * @param props.id Unique identifier of the donation to be soft-deleted.
 * @path /donations/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the donation to be soft-deleted. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDonation;

  export const METADATA = {
    method: "DELETE",
    path: "/donations/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/donations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IDonation =>
    typia.random<IDonation>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

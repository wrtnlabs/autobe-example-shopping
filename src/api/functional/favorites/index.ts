import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IFavorite } from "../../structures/IFavorite";
import { IPageIFavorite } from "../../structures/IPageIFavorite";

/**
 * Add a favorite entry for the current user and entity
 * (EngagementBoards.favorites).
 *
 * This endpoint allows an authenticated user to mark an entity (product,
 * inquiry, address, etc.) as a favorite. The client provides the entity_type,
 * entity_id, and the reference snapshot id. Handles checks:
 *
 * - The snapshot must match the entity and exist (and not be deleted).
 * - The combination of user, entity_type, and entity_id must be unique (cannot
 *   favorite same object twice).
 *
 * Business logic:
 *
 * - If already favorited, may return an error or silently ignore, depending on
 *   policy.
 * - May trigger notifications (opt-in state) or event hooks.
 *
 * Audit logs are created for compliance/rollback. Related APIs: favorite
 * list/search (PATCH), favorite detail (GET), update (PUT), delete (DELETE).
 * Errors: validation fails if target object/snapshot/entity is missing.
 *
 * @param props.body Favorite creation info (entity_type, entity_id, snapshot).
 * @path /favorites
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Favorite creation info (entity_type, entity_id, snapshot). */
    body: IFavorite.ICreate;
  };
  export type Body = IFavorite.ICreate;
  export type Response = IFavorite;

  export const METADATA = {
    method: "POST",
    path: "/favorites",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/favorites";
  export const random = (g?: Partial<typia.IRandomGenerator>): IFavorite =>
    typia.random<IFavorite>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List and search the authenticated user's favorites with pagination/filtering
 * (EngagementBoards.favorites).
 *
 * Fetches a paginated, filterable list of favorite items (snapshots) for the
 * authenticated user. The 'favorites' table supports favoriting products,
 * inquiries, addresses, etc., by linking to an entity type, entity id, and a
 * referenced snapshot. This operation allows searching/filtering by entity_type
 * (e.g., 'product', 'inquiry'), sorting (by created date, etc.), and supports
 * pagination for large result sets.
 *
 * RBAC is enforced: only the user's own favorites are returned. Deleted/expired
 * targets (where the snapshot or entity is deleted) may be optionally shown or
 * omitted (configurable by query). Use cases: populating user dashboards,
 * notification settings, re-adding favorites after changes, auditing user
 * engagement.
 *
 * Related APIs: favorite detail (GET), create (POST), update (PUT), delete
 * (DELETE). Errors: permission denied if user context invalid, unknown type, or
 * search/pagination misuse.
 *
 * @param props.body Search/filter/pagination info for listing favorites.
 * @path /favorites
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filter/pagination info for listing favorites. */
    body: IFavorite.IRequest;
  };
  export type Body = IFavorite.IRequest;
  export type Response = IPageIFavorite;

  export const METADATA = {
    method: "PATCH",
    path: "/favorites",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/favorites";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIFavorite =>
    typia.random<IPageIFavorite>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get detailed info on a user's favorite entity entry by ID
 * (EngagementBoards.favorites).
 *
 * This operation returns comprehensive information about a user's favorite
 * entity. Each favorite references a snapshot for immutable
 * notification/eventing, as well as entity type/id for object lookup. The
 * system checks that the entity exists, the favorite belongs to the requesting
 * user, and that associated snapshot/entity are still accessible.
 *
 * Returns notification-related data (e.g., current vs favorited snapshot,
 * notification opt-in state), allowing clients to display details for favorites
 * and react to changes (e.g., product unpublished, address changed). Only the
 * favorite owner (user) may retrieve this detail; access is forbidden to other
 * users. This endpoint pairs with the favorite listing/search (PATCH), create
 * (POST), update (PUT), and delete (DELETE) endpoints.
 *
 * @param props.id Favorite entry unique ID for lookup.
 * @path /favorites/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Favorite entry unique ID for lookup. */
    id: string;
  };
  export type Response = IFavorite;

  export const METADATA = {
    method: "GET",
    path: "/favorites/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/favorites/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IFavorite =>
    typia.random<IFavorite>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing favorite entry for the current user
 * (EngagementBoards.favorites).
 *
 * Enables a user to update information about an existing favorite, such as
 * changing which snapshot is followed (if the entity has changed), toggling
 * notifications, or any other updatable property. The request body details what
 * fields to change (e.g., entity_snapshot_id, notification settings if
 * supported).
 *
 * Checks:
 *
 * - ID matches an existing, active favorite belonging to the user.
 * - Only certain fields may be updatable (typically the snapshot reference or
 *   notification state).
 * - Notification logic is triggered if the snapshot/entity reference changes.
 *
 * Audit log created for compliance. Related endpoints: favorite list/search,
 * get, create, delete. Errors: permission denied if favorite does not belong to
 * user, invalid/missing fields, or invalid snapshot reference.
 *
 * @param props.id The ID of the favorite to update.
 * @param props.body Fields to update (e.g., snapshot reference), notification
 *   toggle, etc.
 * @path /favorites/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The ID of the favorite to update. */
    id: string;

    /**
     * Fields to update (e.g., snapshot reference), notification toggle,
     * etc.
     */
    body: IFavorite.IUpdate;
  };
  export type Body = IFavorite.IUpdate;
  export type Response = IFavorite;

  export const METADATA = {
    method: "PUT",
    path: "/favorites/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/favorites/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IFavorite =>
    typia.random<IFavorite>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Remove (soft-delete) a favorite entry for the current user by ID
 * (EngagementBoards.favorites).
 *
 * This operation removes an entity from the user's favorites list. Logically
 * performs a soft-delete for compliance/audit, so the record persists for
 * history but is not returned in normal queries.
 *
 * Checks:
 *
 * - The favorite must exist and belong to the requesting user.
 * - Deletion is logged for rollback/compliance.
 *
 * Deletion may optionally trigger notification suppression for the
 * entity/snapshot. Related endpoints: favorite list/search, get, create,
 * update. Errors: not found, permission denied.
 *
 * @param props.id Favorite entry unique ID for deletion.
 * @path /favorites/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Favorite entry unique ID for deletion. */
    id: string;
  };
  export type Response = IFavorite;

  export const METADATA = {
    method: "DELETE",
    path: "/favorites/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/favorites/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IFavorite =>
    typia.random<IFavorite>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { INotificationPreference } from "../../structures/INotificationPreference";
import { IPageINotificationPreference } from "../../structures/IPageINotificationPreference";

/**
 * Create notification preference
 * (NotificationLocalization.notification_preferences).
 *
 * This POST API creates a notification preference record for a user, channel,
 * type, and delivery method. Used when a user or admin wants to set or update
 * opt-in status for notifications (email, push, SMS, etc.), or when onboarding
 * new users. All required fields (user, channel, notification_type,
 * delivery_type, enabled) are validated. The permission system restricts record
 * creation to the user themselves or authorized admin/support roles. On
 * success, returns the newly created notification_preferences object; on error,
 * returns 400 (validation), 409 (conflict), or 403 (forbidden).
 *
 * Sensitive/PII handling: neither user nor channel are directly exposed unless
 * permitted. All creations are audit-logged for compliance.
 *
 * @param props.body Notification preference to create for
 *   user/channel/type/delivery.
 * @path /notificationPreferences
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Notification preference to create for user/channel/type/delivery. */
    body: INotificationPreference.ICreate;
  };
  export type Body = INotificationPreference.ICreate;
  export type Response = INotificationPreference;

  export const METADATA = {
    method: "POST",
    path: "/notificationPreferences",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/notificationPreferences";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): INotificationPreference => typia.random<INotificationPreference>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search notification preferences
 * (NotificationLocalization.notification_preferences).
 *
 * This PATCH operation lists or searches notification preferences for the
 * current authenticated user (or by admin, for managing user settings). All
 * filters, sort orders, or pagination options are submitted in the request
 * body. Returns a paged result set of notification_preferences objects, each
 * indicating enabled/disabled status per channel and type for the user. The
 * endpoint is used in notification management UIs, user profile panels, or
 * compliance review screens. RBAC and ownership checks ensure only authorized
 * data may be accessed. When called by end users, the scope is limited to their
 * own records.
 *
 * Malformed filters or unauthorized queries result in a 400 or 403. Returns a
 * paged list, optionally filtered by channel, type, or status.
 *
 * @param props.body Search/filter/pagination info for notification preference
 *   listing.
 * @path /notificationPreferences
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filter/pagination info for notification preference listing. */
    body: INotificationPreference.IRequest;
  };
  export type Body = INotificationPreference.IRequest;
  export type Response = IPageINotificationPreference;

  export const METADATA = {
    method: "PATCH",
    path: "/notificationPreferences",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/notificationPreferences";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageINotificationPreference =>
    typia.random<IPageINotificationPreference>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get notification preference record by ID
 * (NotificationLocalization.notification_preferences).
 *
 * This GET endpoint fetches a single notification preference by its unique ID
 * from the notification_preferences table. The retrieved record contains
 * granular opt-in/out status for a specific channel, type, and delivery method
 * for the user. Use cases include user profile notification management screens
 * or admin/support compliance review. Full RBAC and ownership checks apply. The
 * response includes status, channel_id, notification_type, delivery_type,
 * enabled, etc.
 *
 * If record is not found or access is denied, the API returns 404 or 403.
 * Permissions are strict: users only see their own records unless admin
 * policies grant access. All accesses are logged for audit/traceability.
 *
 * @param props.id Unique identifier of the notification preference record.
 * @path /notificationPreferences/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier of the notification preference record. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = INotificationPreference;

  export const METADATA = {
    method: "GET",
    path: "/notificationPreferences/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/notificationPreferences/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): INotificationPreference => typia.random<INotificationPreference>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a notification preference record (notification_preferences table) by
 * ID.
 *
 * This API operation allows modification of an existing notification
 * preference, identified by the provided unique ID. Notification preferences
 * are atomic records representing a user's opt-in or opt-out choice for a given
 * channel, notification type, and delivery type (such as email, push, SMS) in
 * the AI Shopping Mall Backend. According to the notification_preferences
 * Prisma schema, all properties are atomic and not duplicated. The operation
 * validates permissions: only the owner or authorized admins can update this
 * resource, and every change is audit-logged. Validation ensures the referenced
 * preference exists and that the input does not violate unique constraints (a
 * user cannot have two preferences for the same [user, channel,
 * notification_type, delivery_type] tuple).
 *
 * Security controls and audit logging are enforced: every update event must be
 * attributed to the performing user and logged for compliance. The system
 * strictly prohibits changing unique identifiers via this operation; only
 * preference state or notification delivery fields may be updated. The API
 * returns the full updated notification preference object or detailed error
 * messages for permission denial, unique constraint violation, or validation
 * failure. Related API operations include GET for retrieving preferences and
 * DELETE for soft deleting a preference.
 *
 * Error cases covered: not found, permission denied, constraint violation, and
 * validation errors. Complies with the platform's requirement for field-level
 * audit and contextual RBAC.
 *
 * @param props.id Unique identifier of the notification preference to be
 *   updated.
 * @param props.body Updated fields for the notification preference record. Only
 *   controllable atomic fields (enabled, delivery type, etc.), excluding unique
 *   identifier.
 * @path /notificationPreferences/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier of the notification preference to be updated. */
    id: string & tags.Format<"uuid">;

    /**
     * Updated fields for the notification preference record. Only
     * controllable atomic fields (enabled, delivery type, etc.), excluding
     * unique identifier.
     */
    body: INotificationPreference.IUpdate;
  };
  export type Body = INotificationPreference.IUpdate;
  export type Response = INotificationPreference;

  export const METADATA = {
    method: "PUT",
    path: "/notificationPreferences/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/notificationPreferences/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): INotificationPreference => typia.random<INotificationPreference>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft delete a notification preference (set deleted_at) by ID
 * (notification_preferences table).
 *
 * This API operation performs a soft delete of a notification preference,
 * identified by its UUID. In the Prisma notification_preferences schema, soft
 * deletes are implemented by setting the deleted_at timestamp on the record, in
 * compliance with GDPR, CCPA, and internal audit requirements—physical deletion
 * is prohibited for auditability. Only the preference owner or an authorized
 * admin can perform this operation, and the event is audit-logged with the
 * actor's ID for compliance review. Deleting a preference disables notification
 * delivery per user/channel/type but allows restoration or audit during review
 * periods. Returns the deleted (now soft-deleted) object for confirmation, or a
 * clear error if resource is not found, already deleted, or insufficient
 * permission. Related API endpoints include PUT for update and GET for detail
 * retrieval.
 *
 * @param props.id Unique identifier of the notification preference to be
 *   deleted.
 * @path /notificationPreferences/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the notification preference to be deleted. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = INotificationPreference;

  export const METADATA = {
    method: "DELETE",
    path: "/notificationPreferences/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/notificationPreferences/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): INotificationPreference => typia.random<INotificationPreference>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { INotificationTemplate } from "../../structures/INotificationTemplate";
import { IPageINotificationTemplate } from "../../structures/IPageINotificationTemplate";

/**
 * Create new notification template
 * (NotificationLocalization.notification_templates).
 *
 * This API operation allows for the creation of a new notification template,
 * required for delivering customized and localized notifications (email, push,
 * SMS, in-app) to users. All required fields (type, channel, locale, title,
 * content, version, active flag) must be provided and validated; the system
 * enforces uniqueness for the combination (type, channel_id, locale, version).
 * Permissions are strictly checked to allow only admin/managers to create
 * templates.
 *
 * On successful creation, the system returns the full template record. Attempts
 * to duplicate or violate field requirements return a 409 or 400 error. All
 * actions are audit-logged for compliance and configuration tracing. The data
 * returned may be used directly in preview or assignment workflows.
 *
 * @param props.body Notification template creation payload: type, locale,
 *   title, content, version, etc.
 * @path /notificationTemplates
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Notification template creation payload: type, locale, title, content,
     * version, etc.
     */
    body: INotificationTemplate.ICreate;
  };
  export type Body = INotificationTemplate.ICreate;
  export type Response = INotificationTemplate;

  export const METADATA = {
    method: "POST",
    path: "/notificationTemplates",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/notificationTemplates";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): INotificationTemplate => typia.random<INotificationTemplate>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search notification templates
 * (NotificationLocalization.notification_templates).
 *
 * This PATCH endpoint retrieves a paginated, optionally filtered list of
 * notification templates from the notification_templates table. Supported
 * filtering includes channel, type, locale, version, and status (active). The
 * operation is meant for admin and management UIs, allowing bulk review,
 * selection, and analytics of templates. Search input and sort order are
 * provided through the request body, along with possible page and per-page
 * settings.
 *
 * Security: Usually only admins/managers can retrieve all templates; end users
 * may access only visible or public templates appropriate for their context.
 * The API cross-checks RBAC and channel/locale access before returning results.
 * All results include template metadata, version, locale, and contents (where
 * permitted).
 *
 * Error handling: invalid parameters return 400, RBAC/permission issues return
 * 403.
 *
 * @param props.body Search/filter/pagination parameters for finding
 *   notification templates.
 * @path /notificationTemplates
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Search/filter/pagination parameters for finding notification
     * templates.
     */
    body: INotificationTemplate.IRequest;
  };
  export type Body = INotificationTemplate.IRequest;
  export type Response = IPageINotificationTemplate;

  export const METADATA = {
    method: "PATCH",
    path: "/notificationTemplates",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/notificationTemplates";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageINotificationTemplate => typia.random<IPageINotificationTemplate>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a single notification template by ID
 * (NotificationLocalization.notification_templates).
 *
 * This GET API retrieves the full record for a specific notification template
 * using its ID. The notification_templates table stores versioned, localized,
 * and channel-specific notification templates for SMS, email, push, or in-app
 * delivery. The operation is essential for template editing, preview, and
 * assignment workflows. Returns metadata, content, version, status, and locale;
 * for permission boundaries (admin, manager, or permitted channel users).
 *
 * Permission and RBAC validation are enforced; template content exposure is
 * limited to appropriately scoped users. If the template does not exist or the
 * user is not permitted to view it, a 404 or 403 is returned respectively. All
 * accesses are logged for compliance/audit.
 *
 * Related workflows: template editing, notification creation/preview, channel
 * configuration UI.
 *
 * @param props.id Unique identifier of the notification template to retrieve.
 * @path /notificationTemplates/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier of the notification template to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = INotificationTemplate;

  export const METADATA = {
    method: "GET",
    path: "/notificationTemplates/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/notificationTemplates/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): INotificationTemplate => typia.random<INotificationTemplate>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update notification template
 * (NotificationLocalization.notification_templates).
 *
 * This operation updates an existing notification template identified by its
 * ID, in the notification_templates table. Allowed fields to update include:
 * title, content, locale, status (is_active), but not version, channel_id, or
 * type. The principal use case is for admins or template managers to edit
 * templates after creation, or to activate/deactivate for assignment. Full RBAC
 * and validation are enforced; update activity is always audit-logged. The
 * returned object is the up-to-date template information.
 *
 * If a non-existent or immutable template is addressed, a 404 or 409 error is
 * returned. Attempts to update protected fields are rejected. Successful
 * updates may take effect immediately for notifications referencing the
 * template.
 *
 * @param props.id Unique identifier of the notification template to update.
 * @param props.body Fields and values to update on the notification template
 *   (title, content, status, etc.).
 * @path /notificationTemplates/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier of the notification template to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Fields and values to update on the notification template (title,
     * content, status, etc.).
     */
    body: INotificationTemplate.IUpdate;
  };
  export type Body = INotificationTemplate.IUpdate;
  export type Response = INotificationTemplate;

  export const METADATA = {
    method: "PUT",
    path: "/notificationTemplates/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/notificationTemplates/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): INotificationTemplate => typia.random<INotificationTemplate>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete notification template
 * (NotificationLocalization.notification_templates).
 *
 * This API operation marks a notification template as deleted (by setting a
 * soft-delete field) for the given ID. Implements soft (not hard) delete logic
 * per compliance and audit requirements. Only system admins or authorized
 * template managers can perform this action; users cannot delete templates.
 * Deletion is audit-logged. Soft-deleted templates are excluded from normal
 * queries but retained for history and rollback.
 *
 * Attempting to remove a non-existent or already-removed template returns a 404
 * error. The returned object confirms deletion or updated template data (marked
 * deleted).
 *
 * @param props.id Unique identifier of the notification template to
 *   soft-delete.
 * @path /notificationTemplates/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the notification template to soft-delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = INotificationTemplate;

  export const METADATA = {
    method: "DELETE",
    path: "/notificationTemplates/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/notificationTemplates/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): INotificationTemplate => typia.random<INotificationTemplate>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IOrderAuditLog } from "../../structures/IOrderAuditLog";
import { IPageIOrderAuditLog } from "../../structures/IPageIOrderAuditLog";
import { IDeleteConfirmation } from "../../structures/IDeleteConfirmation";

/**
 * Create a new order audit log entry (order_audit_logs table).
 *
 * This operation creates a new atomic, immutable audit log entry tied to an
 * order event. Filled fields include order, actor (user/admin/system), action
 * type, additional context, and timestamp. It serves as legal/evidentiary proof
 * of system actions and supports compliance audits.
 *
 * Access is controlled by RBAC, typically restricted to system services, admin,
 * or back-office flows. Payload is validated for all required fields. Once
 * written, audit log entries are never changed or deleted except for
 * soft-delete by privileged compliance staff.
 *
 * Works alongside order status history, main order update endpoints, etc. Error
 * cases are invalid data, permission denied, or reference integrity errors.
 *
 * @param props.body Order audit log creation parameters
 * @path /orderAuditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Order audit log creation parameters */
    body: IOrderAuditLog.ICreate;
  };
  export type Body = IOrderAuditLog.ICreate;
  export type Response = IOrderAuditLog;

  export const METADATA = {
    method: "POST",
    path: "/orderAuditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/orderAuditLogs";
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrderAuditLog =>
    typia.random<IOrderAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search order audit logs (order_audit_logs table).
 *
 * This operation returns a paginated, filterable list of order audit log
 * entries from the 'order_audit_logs' table. It supports searching by fields
 * such as order ID, user ID, action type, or time ranges, and can be sorted on
 * any indexed attribute.
 *
 * Access is permissioned according to audit-read privileges (admin, auditor
 * roles). Results respect soft deletion. Input parameters for pagination (page,
 * pageSize), filters, and sorts are accepted via request body.
 *
 * Often used alongside order detail and order status endpoints for forensic
 * analysis, compliance reporting, and dispute resolution. Errors include bad
 * filter, access denied, and invalid input.
 *
 * @param props.body Search/filter parameters for order audit logs
 * @path /orderAuditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filter parameters for order audit logs */
    body: IOrderAuditLog.IRequest;
  };
  export type Body = IOrderAuditLog.IRequest;
  export type Response = IPageIOrderAuditLog;

  export const METADATA = {
    method: "PATCH",
    path: "/orderAuditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/orderAuditLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIOrderAuditLog => typia.random<IPageIOrderAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get an order audit log entry by ID (order_audit_logs table).
 *
 * Retrieve a single audit log entry for an order, identified by its unique ID
 * in the 'order_audit_logs' table. All action details, actor, timestamps, and
 * action data are returned to authorized users (admin, auditor, or order owner
 * with restricted scope).
 *
 * Supports compliance workflows, root-cause analysis, and audit case handling.
 * Soft-deleted entries are excluded unless explicitly requested by an admin.
 * Error handling includes not found, permission denied, or record
 * soft-deleted.
 *
 * Often used in conjunction with order history, status, and refund/exchange
 * workflows.
 *
 * @param props.id Unique identifier for the order audit log entry
 * @path /orderAuditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier for the order audit log entry */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IOrderAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/orderAuditLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/orderAuditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrderAuditLog =>
    typia.random<IOrderAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update audit log metadata for an order (special admin only, order_audit_logs
 * table).
 *
 * Update certain metadata fields of an order audit log entry (e.g., to attach
 * additional context for a compliance investigation). Most attributes are
 * unchangeable; only non-critical or compliance-appended fields may be updated
 * with appropriate privilege (e.g., senior admin).
 *
 * Strictly logged, access-controlled by RBAC, and always records before/after
 * values for legal proof. Immutable fields and action details cannot be
 * changed; requests attempting this will be rejected with appropriate errors.
 *
 * Integrates with compliance and audit trail workflows. Errors include
 * permission denied, not found, or invalid update data.
 *
 * @param props.id Unique identifier for the order audit log entry
 * @param props.body Order audit log update parameters (only updatable fields)
 * @path /orderAuditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier for the order audit log entry */
    id: string & tags.Format<"uuid">;

    /** Order audit log update parameters (only updatable fields) */
    body: IOrderAuditLog.IUpdate;
  };
  export type Body = IOrderAuditLog.IUpdate;
  export type Response = IOrderAuditLog;

  export const METADATA = {
    method: "PUT",
    path: "/orderAuditLogs/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/orderAuditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrderAuditLog =>
    typia.random<IOrderAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete an order audit log entry (order_audit_logs table).
 *
 * Mark an order audit log entry as soft-deleted, such that it cannot be
 * retrieved by standard list or get operations unless explicitly requested by
 * privileged compliance staff. All soft-deletions are themselves audit-logged,
 * and this action is tightly access-controlled.
 *
 * Used in rare circumstances (e.g., after successful GDPR erasure) and always
 * leaves the original record intact for audits. Non-existent or already deleted
 * records are handled gracefully.
 *
 * This operation is primarily used in compliance and legal contexts, not in
 * normal order processing.
 *
 * @param props.id Unique identifier for the order audit log entry
 * @path /orderAuditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier for the order audit log entry */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDeleteConfirmation;

  export const METADATA = {
    method: "DELETE",
    path: "/orderAuditLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/orderAuditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IDeleteConfirmation => typia.random<IDeleteConfirmation>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

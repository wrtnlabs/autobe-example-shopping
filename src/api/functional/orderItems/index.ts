import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IOrderItem } from "../../structures/IOrderItem";
import { IPageIOrderItem } from "../../structures/IPageIOrderItem";

/**
 * Create a new order item record (Prisma: order_items table).
 *
 * This endpoint creates a new order item and attaches it to a specified order.
 * Used rarely in standard flows; most items are created as part of a new order,
 * but this supports admin, after-sales, or audit-driven flows. Validates that
 * the referenced order exists and is open for modification; all business logic
 * around inventory, pricing, order limits, and compliance is enforced. Input
 * must include order reference, variant reference, quantity, and any
 * notes/status required. All actions are fully audit-logged. Returns the
 * created item with assigned ID and timestamps.
 *
 * @param props.body Details for new order item: references, quantity, and
 *   properties.
 * @path /orderItems
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Details for new order item: references, quantity, and properties. */
    body: IOrderItem.ICreate;
  };
  export type Body = IOrderItem.ICreate;
  export type Response = IOrderItem;

  export const METADATA = {
    method: "POST",
    path: "/orderItems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/orderItems";
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrderItem =>
    typia.random<IOrderItem>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get list of order items with advanced query, paging, and filtering (Prisma:
 * order_items table).
 *
 * This endpoint returns a paginated, filtered list of order items. Used for
 * inventory, order analytics, shipment/return processing, and granular
 * customer/admin operations. Business logic enforces search/filter on fields
 * like status (delivered, returned), product reference, order, and time
 * periods. Provides full audit compliance (shows only non-deleted records
 * unless permissions allow otherwise) and is optimized for both admin and
 * customer scenarios. Part of the full order/detail workflow for UI
 * integrations. Error cases for bad filters, bad input, or lack of permission
 * handled consistently. Response includes collection of order item summaries
 * and metadata for pagination and UI.
 *
 * @param props.body Query parameters for order item searching, including paging
 *   and filters.
 * @path /orderItems
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Query parameters for order item searching, including paging and
     * filters.
     */
    body: IOrderItem.IRequest;
  };
  export type Body = IOrderItem.IRequest;
  export type Response = IPageIOrderItem;

  export const METADATA = {
    method: "PATCH",
    path: "/orderItems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/orderItems";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIOrderItem => typia.random<IPageIOrderItem>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetch full details of an order item by ID (Prisma: order_items table).
 *
 * Retrieves all available data about an individual order item by ID, including
 * product variant reference, order relationship, status, and audit metadata.
 * RBAC and security rules restrict access to authorized users/admins;
 * soft-deleted items not returned unless admin override. Input validation
 * ensures proper UUID format and existence. Used together with order/detail
 * endpoints for comprehensive after-sales workflows. Errors returned for not
 * found, unauthorized, or system/database errors. Provides all fields from the
 * order_items table and related/lookup metadata for UI purposes.
 *
 * @param props.id Target order item ID
 * @path /orderItems/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target order item ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IOrderItem;

  export const METADATA = {
    method: "GET",
    path: "/orderItems/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/orderItems/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrderItem =>
    typia.random<IOrderItem>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an order item by ID (Prisma: order_items table).
 *
 * Updates all modifiable fields of an identified order item. Validations ensure
 * legal edit state (e.g., item not delivered, allowable to change), tied
 * properly to the referenced order, and within compliance (no edit if
 * soft-deleted, unless admin). All edits logged in audit trail. Used in
 * inventory correction, after-sales correction, and fulfillment admin
 * interfaces. Errors reported for disallowed edits, bad input, permission, or
 * missing resource.
 *
 * @param props.id Target order item ID
 * @param props.body All updatable fields and references for the item.
 * @path /orderItems/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target order item ID */
    id: string & tags.Format<"uuid">;

    /** All updatable fields and references for the item. */
    body: IOrderItem.IUpdate;
  };
  export type Body = IOrderItem.IUpdate;
  export type Response = IOrderItem;

  export const METADATA = {
    method: "PUT",
    path: "/orderItems/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/orderItems/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrderItem =>
    typia.random<IOrderItem>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete an order item by ID (Prisma: order_items table).
 *
 * Marks the specified order item as (soft) deleted by setting the deleted_at
 * timestamp. Actual data remains for regulatory audit and potential future
 * restoration. Action is audit logged, and business rule checks confirm
 * eligibility (cannot delete delivered/completed). Strict permission
 * control—normally only allowed for admins, or as part of an order edit.
 * Returns the soft-deleted item, including updated metadata. Used mainly for
 * admin workflows, rarely for customers.
 *
 * @param props.id Target order item ID
 * @path /orderItems/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target order item ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IOrderItem;

  export const METADATA = {
    method: "DELETE",
    path: "/orderItems/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/orderItems/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrderItem =>
    typia.random<IOrderItem>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

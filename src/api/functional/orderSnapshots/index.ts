import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IOrderSnapshot } from "../../structures/IOrderSnapshot";
import { IPageIOrderSnapshot } from "../../structures/IPageIOrderSnapshot";
import { IDeleteConfirmation } from "../../structures/IDeleteConfirmation";

/**
 * Create a new order snapshot (order_snapshots table).
 *
 * This operation creates a new immutable snapshot of an existing order,
 * recording the actor responsible for the change and the full serialized order
 * state in the 'order_snapshots' table. Snapshots are essential for rollback
 * support, compliance evidence, and auditing.
 *
 * Access is restricted to authorized users with proper permissions (admin,
 * relevant seller, or customer with access). Payload is validated for
 * completeness; invalid or incomplete data will trigger error responses.
 * Snapshots can only be added, never updated in place (immutability).
 *
 * This API integrates with order update workflows and is logged for compliance.
 * Related APIs include order update, order status history, and audit log
 * endpoints.
 *
 * @param props.body Order snapshot creation payload
 * @path /orderSnapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Order snapshot creation payload */
    body: IOrderSnapshot.ICreate;
  };
  export type Body = IOrderSnapshot.ICreate;
  export type Response = IOrderSnapshot;

  export const METADATA = {
    method: "POST",
    path: "/orderSnapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/orderSnapshots";
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrderSnapshot =>
    typia.random<IOrderSnapshot>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List and search order snapshot records (CartOrder domain).
 *
 * This endpoint returns a filtered and paginated list of order snapshot
 * records. Each snapshot is an immutable, serialized state of an order as of a
 * change event (placed, updated, completed, etc)â€”used for rollback/reporting
 * and auditability. Permits filtering by order, actor (user/admin), timestamp
 * ranges, and workflow context.
 *
 * Security: RBAC and privacy masking to restrict access to only authorized
 * entities (e.g., customer, seller, or admin with proper permission).
 * Underlying audit history is not altered by reads.
 *
 * Use cases: Customer support, fraud audit, rollback after incident, compliance
 * reporting. Related: order/audit log endpoints for more atomic reporting.
 *
 * Errors: Bad search parameters, permission or backend faults respond per API
 * error contracts.
 *
 * @param props.body Batch search/filter and pagination options for order
 *   snapshot retrieval.
 * @path /orderSnapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Batch search/filter and pagination options for order snapshot
     * retrieval.
     */
    body: IOrderSnapshot.IRequest;
  };
  export type Body = IOrderSnapshot.IRequest;
  export type Response = IPageIOrderSnapshot;

  export const METADATA = {
    method: "PATCH",
    path: "/orderSnapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/orderSnapshots";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIOrderSnapshot => typia.random<IPageIOrderSnapshot>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get an order snapshot by ID (order_snapshots table).
 *
 * This operation retrieves the complete immutable state of an order at a
 * particular version, using its unique identifier from the 'order_snapshots'
 * table. This supports full auditability and rollback capability for
 * compliance.
 *
 * The endpoint is accessible to authorized users (admin, seller, customer for
 * their own orders) and is logged for compliance. Ensures soft deletion (if the
 * snapshot itself is ever marked) is respected and non-existent resources
 * return clear error status. The operation enforces contextual RBAC.
 *
 * Used in conjunction with the order detail API for auditing or restoration
 * workflows. Error cases include not-found, permission denied, or soft-deleted
 * records.
 *
 * @param props.id Unique identifier for the order snapshot
 * @path /orderSnapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier for the order snapshot */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IOrderSnapshot;

  export const METADATA = {
    method: "GET",
    path: "/orderSnapshots/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/orderSnapshots/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrderSnapshot =>
    typia.random<IOrderSnapshot>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update metadata of an order snapshot (special admin only, order_snapshots
 * table).
 *
 * This operation updates select fields on an existing order snapshot entity,
 * subject to strict compliance and audit workflow. Most attributes (such as
 * immutable snapshot data) are not mutable; this endpoint is intended for
 * exceptional cases where an administrative correction is necessary (e.g., to
 * append missing audit context, not to edit order data itself).
 *
 * Access is strictly limited (e.g., senior admin or compliance officer) and
 * fully logged, including before/after data for rollback. All changes must
 * preserve proof of original state and may require secondary approval in
 * business logic. Attempts to update critical immutable fields (e.g., snapshot
 * data) will be rejected.
 *
 * Error cases include permission denied, not found, and prohibited change to
 * protected fields. Used sparingly in conjunction with the audit log API.
 *
 * @param props.id Unique identifier for the order snapshot
 * @param props.body Order snapshot update details (only permitted fields)
 * @path /orderSnapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier for the order snapshot */
    id: string & tags.Format<"uuid">;

    /** Order snapshot update details (only permitted fields) */
    body: IOrderSnapshot.IUpdate;
  };
  export type Body = IOrderSnapshot.IUpdate;
  export type Response = IOrderSnapshot;

  export const METADATA = {
    method: "PUT",
    path: "/orderSnapshots/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/orderSnapshots/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrderSnapshot =>
    typia.random<IOrderSnapshot>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete an order snapshot (order_snapshots table).
 *
 * This operation marks an order snapshot as 'soft-deleted,' hiding it from
 * standard retrieval but retaining it for legal and traceability needs. No
 * snapshot is physically deleted to preserve the immutable audit chain.
 * Operation triggers a new compliance audit log and is allowed only for highly
 * privileged users per RBAC.
 *
 * Non-existent or already deleted entities are handled with clear error
 * messages. This operation is closely monitored, with actions captured in the
 * audit log.
 *
 * Typical use-cases involve data redaction, regulatory take-down, or
 * exceptional circumstances like erroneous or abusive data entry.
 *
 * @param props.id Unique identifier for the order snapshot
 * @path /orderSnapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier for the order snapshot */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDeleteConfirmation;

  export const METADATA = {
    method: "DELETE",
    path: "/orderSnapshots/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/orderSnapshots/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IDeleteConfirmation => typia.random<IDeleteConfirmation>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

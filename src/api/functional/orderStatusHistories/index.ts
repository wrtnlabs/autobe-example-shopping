import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IOrderStatusHistory } from "../../structures/IOrderStatusHistory";
import { IPageIOrderStatusHistory } from "../../structures/IPageIOrderStatusHistory";

/**
 * Create a new order status history in the 'order_status_histories' table.
 *
 * This endpoint provides creation of a new order status history entry, which is
 * essential to maintain immutable audit trails of all order state transitions,
 * as specified in the 'Cart & Order' requirements section. Each history entry
 * references the order, actor (user/admin), and records the state transition
 * (from_status, to_status). Optional comments can be used to provide context
 * for status changes (e.g., auto-cancel, admin override). All entries must
 * capture the creation timestamp and are never deleted but may be soft-deleted
 * for audit compliance. Validation ensures referenced order and user exist;
 * non-existent IDs result in a 404 error. Related operations: retrieving order
 * status history, updating (for comment corrections), and soft-deleting for
 * privacy control.
 *
 * @param props.body Information required for creating an order status history
 *   entry, such as order_id, actor_id, from_status, to_status, comment, and
 *   created_at.
 * @path /orderStatusHistories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Information required for creating an order status history entry, such
     * as order_id, actor_id, from_status, to_status, comment, and
     * created_at.
     */
    body: IOrderStatusHistory.ICreate;
  };
  export type Body = IOrderStatusHistory.ICreate;
  export type Response = IOrderStatusHistory;

  export const METADATA = {
    method: "POST",
    path: "/orderStatusHistories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/orderStatusHistories";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IOrderStatusHistory => typia.random<IOrderStatusHistory>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List paginated order status change histories (Prisma: order_status_histories
 * table).
 *
 * Returns a paged list of order status history records, supporting filters on
 * date, actor (user/admin), order reference, and status transitions. Integral
 * to order audit, compliance reporting, and advanced dashboard functions. Only
 * non-deleted, valid records returned by default, unless admin override. All
 * access actions are audit logged by the system. Errors for bad input or
 * unauthorized queries handled with clear messages. Used to present full
 * workflow and timeline tracking in management and customer UIs.
 *
 * @param props.body Filtering and paging parameters for listing order status
 *   histories.
 * @path /orderStatusHistories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filtering and paging parameters for listing order status histories. */
    body: IOrderStatusHistory.IRequest;
  };
  export type Body = IOrderStatusHistory.IRequest;
  export type Response = IPageIOrderStatusHistory;

  export const METADATA = {
    method: "PATCH",
    path: "/orderStatusHistories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/orderStatusHistories";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIOrderStatusHistory => typia.random<IPageIOrderStatusHistory>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a specific order status history record by ID (Prisma:
 * order_status_histories table).
 *
 * Gets all details for a single status change history record, identified by
 * unique ID. Fields include order reference, old/new status, actor, timestamp,
 * and any associated comment. Security logic ensures only authorized actors may
 * view the full details, and all reads are audit logged for compliance. Not
 * found and permission errors are structured. Used for detailed workflow
 * analysis and audit exports.
 *
 * @param props.id Target order status history ID
 * @path /orderStatusHistories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target order status history ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IOrderStatusHistory;

  export const METADATA = {
    method: "GET",
    path: "/orderStatusHistories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/orderStatusHistories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IOrderStatusHistory => typia.random<IOrderStatusHistory>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing order status history entry in the 'order_status_histories'
 * table.
 *
 * This endpoint updates an existing order status history entry, specifically
 * allowing corrections to attributes such as the comment or possibly the state
 * transition fields if corrective action is warranted. The operation follows
 * the compliance requirement that original audit trails must not be overwritten
 * or destroyed: all updates are timestamped, and history can be traced. Primary
 * references (order_id, actor_id) cannot be changed post-creation. Soft-deleted
 * entries cannot be updated. Related operations include creation (POST),
 * retrieval (GET), and deletion (DELETE) for privacy or error mitigation.
 *
 * @param props.id Unique identifier of the order status history entry.
 * @param props.body Updated details for the order status history entry, limited
 *   to correctable fields (such as comment or from/to status fields).
 * @path /orderStatusHistories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier of the order status history entry. */
    id: string & tags.Format<"uuid">;

    /**
     * Updated details for the order status history entry, limited to
     * correctable fields (such as comment or from/to status fields).
     */
    body: IOrderStatusHistory.IUpdate;
  };
  export type Body = IOrderStatusHistory.IUpdate;
  export type Response = IOrderStatusHistory;

  export const METADATA = {
    method: "PUT",
    path: "/orderStatusHistories/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/orderStatusHistories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IOrderStatusHistory => typia.random<IOrderStatusHistory>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft delete an order status history entry in the 'order_status_histories'
 * table.
 *
 * This endpoint soft-deletes a single order status history entry by setting a
 * deleted timestamp rather than removing it from the database—which meets the
 * requirement for immutable auditability in the 'Cart & Order' and 'Business,
 * Compliance & Security' specifications. Only entries that exist and are not
 * already soft-deleted may be deleted. Soft-deleted records are excluded from
 * active audit queries but remain accessible to authorized (compliance, audit)
 * users as needed. Related operations: creation (POST), update (PUT), and
 * retrieval (GET/patch for audit).
 *
 * @param props.id Unique identifier of the order status history entry to soft
 *   delete.
 * @path /orderStatusHistories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the order status history entry to soft delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IOrderStatusHistory;

  export const METADATA = {
    method: "DELETE",
    path: "/orderStatusHistories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/orderStatusHistories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IOrderStatusHistory => typia.random<IOrderStatusHistory>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

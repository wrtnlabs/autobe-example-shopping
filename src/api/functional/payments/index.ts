import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPayment } from "../../structures/IPayment";
import { IPageIPayment } from "../../structures/IPageIPayment";

/**
 * Create a new payment in the 'payments' table.
 *
 * This endpoint creates a single payment record, used to record the
 * creation/initiation of payment events (including regular payments, refunds,
 * or manual adjustments) attached to an order/user/channel. This is a
 * system/internal event for recordkeeping, not a direct integration with
 * payment processors. Ensures required fields are provided and all references
 * are valid (returns 400/404 on error). Related operations include list
 * (PATCH), detail retrieval (GET), updating (PUT), and soft deletion (DELETE).
 * Idempotency enforcement is the responsibility of the calling logic (e.g., for
 * double-insertion prevention).
 *
 * @param props.body Payment creation details (order_id, user_id, channel_id,
 *   payment_method, amount, status, optional external transaction reference).
 * @path /payments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Payment creation details (order_id, user_id, channel_id,
     * payment_method, amount, status, optional external transaction
     * reference).
     */
    body: IPayment.ICreate;
  };
  export type Body = IPayment.ICreate;
  export type Response = IPayment;

  export const METADATA = {
    method: "POST",
    path: "/payments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/payments";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPayment =>
    typia.random<IPayment>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List payments in the 'payments' table with searching, filtering, and
 * pagination support.
 *
 * This endpoint provides list retrieval for payment records, including support
 * for pagination, filtering by payment attributes (status, payment_method,
 * channel, user, order), and sorting by date fields. This fulfills requirements
 * for routine reconciliation, compliance auditability, and operational
 * dashboards. Supports query parameters (included in body). Sensitive payment
 * token data (external_transaction_id) is never exposed in full for PCI
 * compliance. Related operations: single payment retrieval (GET), create
 * (POST), update (PUT), and delete (DELETE). Errors are returned for invalid
 * query parameters or excessive result limits.
 *
 * @param props.body Payment search/filter and pagination information for list
 *   retrieval.
 * @path /payments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Payment search/filter and pagination information for list retrieval. */
    body: IPayment.IRequest;
  };
  export type Body = IPayment.IRequest;
  export type Response = IPageIPayment;

  export const METADATA = {
    method: "PATCH",
    path: "/payments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/payments";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIPayment =>
    typia.random<IPageIPayment>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a single payment from the 'payments' table by ID.
 *
 * This endpoint fetches a full payment record by unique ID, providing details
 * such as user, order, channel, payment method, status, and timestamps.
 * Sensitive fields are masked or omitted as needed. Used when inspecting a
 * particular payment for customer support, accounting, or auditing. Related
 * operations: create (POST), update (PUT), delete (DELETE), and payment list
 * (PATCH). Throws 404 on missing ID.
 *
 * @param props.id Unique identifier of the payment to retrieve.
 * @path /payments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier of the payment to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IPayment;

  export const METADATA = {
    method: "GET",
    path: "/payments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/payments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IPayment =>
    typia.random<IPayment>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a payment in the 'payments' table by ID.
 *
 * This endpoint updates certain mutable fields of an existing payment record,
 * such as status, external_transaction_id (where allowed), or correction of
 * timing fields. Immutability is enforced for key references (order_id,
 * user_id, channel_id). Update actions are logged in an audit trail as required
 * by compliance. Related operations: list (PATCH), retrieval (GET), creation
 * (POST), and deletion (DELETE). 404 returned for missing/soft-deleted IDs.
 * Validation for allowed updates per payment state (e.g., can't change a
 * completed payment's method).
 *
 * @param props.id Unique identifier for the payment to update.
 * @param props.body Information for updating mutable payment fields (e.g.,
 *   status, external_transaction_id, paid_at).
 * @path /payments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier for the payment to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Information for updating mutable payment fields (e.g., status,
     * external_transaction_id, paid_at).
     */
    body: IPayment.IUpdate;
  };
  export type Body = IPayment.IUpdate;
  export type Response = IPayment;

  export const METADATA = {
    method: "PUT",
    path: "/payments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/payments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IPayment =>
    typia.random<IPayment>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft delete a payment in the 'payments' table by ID.
 *
 * This endpoint soft-deletes a payment record by setting its deleted_at
 * timestamp. As required by financial and audit compliance, payment records are
 * never physically deleted, but excluded from active queries once deleted.
 * Deletion is only possible for records that exist and are not already marked
 * as deleted. All deletions are logged for auditability (in related audit
 * trail). Related to creation (POST), update (PUT), retrieval (GET), and
 * listing (PATCH). Returns 404 for missing or already removed records.
 *
 * @param props.id Unique identifier of the payment to soft delete.
 * @path /payments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the payment to soft delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IPayment;

  export const METADATA = {
    method: "DELETE",
    path: "/payments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/payments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IPayment =>
    typia.random<IPayment>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IProductAttribute } from "../../structures/IProductAttribute";
import { IPageIProductAttribute } from "../../structures/IPageIProductAttribute";

/**
 * Creates a new product attribute in product_attributes and returns entity.
 *
 * Creates a product attribute after validating variant and option references,
 * value constraints, and normalization rules. Used in product bulk setup and
 * flexible variant management, enabling sellers and admins to define how each
 * SKU (variant) resolves its selectable characteristics. Returns full entity,
 * including references and generated unique identifier. Business rule checks
 * for variant/option existence and that attributes don’t violate unique or
 * referential constraints. Integrates into robust CRUD lifecycle for e-commerce
 * catalogs.
 *
 * @param props.body Information to create a product attribute
 * @path /productAttributes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Information to create a product attribute */
    body: IProductAttribute.ICreate;
  };
  export type Body = IProductAttribute.ICreate;
  export type Response = IProductAttribute;

  export const METADATA = {
    method: "POST",
    path: "/productAttributes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/productAttributes";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IProductAttribute => typia.random<IProductAttribute>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves a paginated, filtered set of product attributes from
 * product_attributes.
 *
 * Provides batch querying of normalized product attributes, supporting advanced
 * search, filter by variant_id/option_id, or value, with strict adherence to
 * product_attributes schema definitions. Product attributes represent the
 * resolved realization of product options at the variant level (e.g.,
 * color=red, size=L). The endpoint's outputs are atomic, supporting SKU
 * configuration, bulk updates, and analytics/persistence across the e-commerce
 * platform. Integrates with related endpoints for variant and option CRUD.
 * Errors are generated for malformed input or insufficient permissions.
 * Pagination and flexible data slicing are provided for high-volume use.
 *
 * @param props.body Criteria for searching/filtering product attributes
 * @path /productAttributes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Criteria for searching/filtering product attributes */
    body: IProductAttribute.IRequest;
  };
  export type Body = IProductAttribute.IRequest;
  export type Response = IPageIProductAttribute;

  export const METADATA = {
    method: "PATCH",
    path: "/productAttributes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/productAttributes";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIProductAttribute => typia.random<IPageIProductAttribute>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetches a single product attribute entity from product_attributes by ID.
 *
 * Returns an atomic product attribute record by ID. The product_attributes
 * table uses strict 3NF to map a specific product variant (SKU) to one of its
 * option values (e.g., color: red, size: large). This endpoint supports detail
 * fetch for catalog editing, analytics reporting, or UI configuration use
 * cases. Errors are raised for non-existent, deleted, or inaccessible records.
 * This function complements the core batch and write APIs for attribute CRUD,
 * and is referenced by variant/option management UIs and import/export
 * systems.
 *
 * @param props.id Primary key for the product attribute to fetch
 * @path /productAttributes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Primary key for the product attribute to fetch */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IProductAttribute;

  export const METADATA = {
    method: "GET",
    path: "/productAttributes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/productAttributes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IProductAttribute => typia.random<IProductAttribute>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates a single product attribute entity in product_attributes by ID.
 *
 * Updates a product attribute entity atomically—fields may include value and
 * (optionally) variant/option reference changes. Product attributes are
 * strictly normalized and serve as point-to-point mappings between product
 * variant and its options (attributes like color or size, realized per specific
 * SKU). This API is referenced directly by product management platforms,
 * integration adapters, custom admin bulk update UIs, and is transactional for
 * audit/auditability. Related endpoints for creation, deletion, and fetch by
 * ID. Validation errors include reference, uniqueness, business logic (one
 * attribute per variant/option pair).
 *
 * @param props.id Primary key for the product attribute to update
 * @param props.body Fields to update in the product attribute record
 * @path /productAttributes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Primary key for the product attribute to update */
    id: string & tags.Format<"uuid">;

    /** Fields to update in the product attribute record */
    body: IProductAttribute.IUpdate;
  };
  export type Body = IProductAttribute.IUpdate;
  export type Response = IProductAttribute;

  export const METADATA = {
    method: "PUT",
    path: "/productAttributes/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/productAttributes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IProductAttribute => typia.random<IProductAttribute>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft deletes a product attribute entity in product_attributes by ID.
 *
 * Soft deletes the specified product attribute by marking it deleted in the
 * table. Product attributes form the canonical mapping of
 * variant-option-value—removal disables this mapping for SKU configuration.
 * This operation logs the deletion for compliance. Validation covers attribute
 * existence, deletion state, and referential integrity; active variant SKU
 * mappings may prevent deletion via business logic checks. This endpoint is
 * typically coupled with product bulk configuration, catalog updates, and
 * option/variant CRUD flows. Core to maintaining catalog data
 * quality/auditability under compliance regimes.
 *
 * @param props.id Primary key for the product attribute to delete
 * @path /productAttributes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Primary key for the product attribute to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/productAttributes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/productAttributes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

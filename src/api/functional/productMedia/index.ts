import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IProductMedia } from "../../structures/IProductMedia";
import { IPageIProductMedia } from "../../structures/IPageIProductMedia";

/**
 * Add a new product media (attach image/video/doc to product/version,
 * `product_media` table).
 *
 * Creates (adds) a new productMedia record linking an attachment file to a
 * product or snapshot. Inputs are validated for RBAC, atomicity (no
 * duplication), and media-specific constraints. Attaches file (by attachment
 * ID) to product and optionally to a particular snapshot/version for
 * history/rollback. Audit/compliance logging on all creation events. Failure
 * returns schema violations (400), authorization errors, or linkage errors
 * (404).
 *
 * @param props.body Creation payload for product media: product, attachment,
 *   optional snapshot, alt, type, order fields.
 * @path /productMedia
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Creation payload for product media: product, attachment, optional
     * snapshot, alt, type, order fields.
     */
    body: IProductMedia.ICreate;
  };
  export type Body = IProductMedia.ICreate;
  export type Response = IProductMedia;

  export const METADATA = {
    method: "POST",
    path: "/productMedia",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/productMedia";
  export const random = (g?: Partial<typia.IRandomGenerator>): IProductMedia =>
    typia.random<IProductMedia>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search product media (`product_media` table, paginated/filterable
 * attachments).
 *
 * Returns a paged, searchable list of product media records (images, videos,
 * docs) for products or snapshots. Implements filtering/sorting per API
 * request, supporting advanced UX (gallery, media selection). Returns atomic
 * metadata (type, alt_text, sort_order, URLs) from Prisma product_media.
 * Soft-deleted media are excluded. Strongly validates query/pagination
 * parameters. Used for constructing product galleries or snapshot
 * reconstructions, and for administrative reviews, with compliance logging as
 * needed.
 *
 * @param props.body Filter/sort/pagination query for product media list (by
 *   product/snapshot/type, order, etc).
 * @path /productMedia
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filter/sort/pagination query for product media list (by
     * product/snapshot/type, order, etc).
     */
    body: IProductMedia.IRequest;
  };
  export type Body = IProductMedia.IRequest;
  export type Response = IPageIProductMedia;

  export const METADATA = {
    method: "PATCH",
    path: "/productMedia",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/productMedia";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIProductMedia => typia.random<IPageIProductMedia>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get product media record (`product_media` table) by ID, with metadata,
 * attachment ref, etc.
 *
 * Retrieves a single product media record with all attached metadata, as
 * described in the `product_media` schema. Used for detailed image/video
 * introspection in the seller, admin, or customer UX. Attachments are
 * referenced via foreign keys, with full alt-text, accessibility, and order
 * metadata. RBAC and soft delete rules enforced. Returns 404/403 if not found
 * or forbidden. Used in advanced product management and compliance review
 * workflows.
 *
 * @param props.id Product media record ID to retrieve.
 * @path /productMedia/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Product media record ID to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IProductMedia;

  export const METADATA = {
    method: "GET",
    path: "/productMedia/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/productMedia/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IProductMedia =>
    typia.random<IProductMedia>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a product media by ID (`product_media` table, only allowed fields).
 *
 * Updates metadata of a product media record by its ID. Only seller or admin
 * permitted. Updatable: order, type, alt text, and attachment. Atomic and full
 * validation (cannot update immutable record fields or change linkage to a
 * snapshot after initial creation). Soft delete and RBAC rules enforced
 * (403/404 on error). All changes are compliance-logged. Used for correcting
 * image labels, changing media order, updating type or referencing a new
 * attachment for a product/version.
 *
 * @param props.id ID of the product media record to update.
 * @param props.body Payload for updatable product media metadata (order, type,
 *   attachment, alt text).
 * @path /productMedia/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** ID of the product media record to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Payload for updatable product media metadata (order, type,
     * attachment, alt text).
     */
    body: IProductMedia.IUpdate;
  };
  export type Body = IProductMedia.IUpdate;
  export type Response = IProductMedia;

  export const METADATA = {
    method: "PUT",
    path: "/productMedia/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/productMedia/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IProductMedia =>
    typia.random<IProductMedia>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete product media record by ID (logical/action, not true file
 * removal).
 *
 * Performs soft deletion of a productMedia record by its ID. The record is
 * flagged as deleted (not physically erased) for legal, rollback, and audit
 * purposes. Attachment/file remains in object storage per version rules. RBAC
 * enforced: only seller or admin permitted. Full compliance and error logic as
 * with all destructive operations: returns 404 if not found, 403 if not
 * allowed, 409 if already non-active. Used for managing product image galleries
 * and historical UGC/data lifecycle.
 *
 * @param props.id ID of the product media record to mark as deleted.
 * @path /productMedia/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** ID of the product media record to mark as deleted. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IProductMedia;

  export const METADATA = {
    method: "DELETE",
    path: "/productMedia/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/productMedia/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IProductMedia =>
    typia.random<IProductMedia>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IProductOption } from "../../structures/IProductOption";
import { IPageIProductOption } from "../../structures/IPageIProductOption";

/**
 * Creates a new product option in product_options and returns the entity.
 *
 * Creates a product option, validating against schema constraints: non-null
 * name, assignment to a product, and optional required flag and sort order.
 * This operation is used in product onboarding or administrative functions for
 * extending available characteristics of a SKU. Triggers changes in related
 * product configuration and can be integrated with audit logging for
 * compliance. Conflicting or duplicate entries return errors; permissions are
 * checked per business rule for product management. The response body returns
 * the newly created product option entity with all fields, including any
 * assigned unique IDs and references.
 *
 * @param props.body Info for the product option to create
 * @path /productOptions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Info for the product option to create */
    body: IProductOption.ICreate;
  };
  export type Body = IProductOption.ICreate;
  export type Response = IProductOption;

  export const METADATA = {
    method: "POST",
    path: "/productOptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/productOptions";
  export const random = (g?: Partial<typia.IRandomGenerator>): IProductOption =>
    typia.random<IProductOption>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves a paged, filtered list of product options from the product_options
 * table.
 *
 * Returns a paginated, filterable array of product options with optional
 * criteria, leveraging the 3NF product_options schema. Each record returned is
 * atomic, holding product option metadata such as the associated product
 * reference, display name, required flag, and display order. Enables batch
 * workflows in product setup, integration, or bulk updates in commerce
 * platforms. Query may include filters by product_id, required flag, or name
 * for admin/seller management. Tied to related endpoints for single option
 * creation, update, and deletion. Handles standard errors for bad request or
 * permission issues. This endpoint plays a central role in the administration
 * of variant and attribute configuration as per e-commerce requirements.
 *
 * @param props.body Criteria and pagination info for querying product options
 * @path /productOptions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Criteria and pagination info for querying product options */
    body: IProductOption.IRequest;
  };
  export type Body = IProductOption.IRequest;
  export type Response = IPageIProductOption;

  export const METADATA = {
    method: "PATCH",
    path: "/productOptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/productOptions";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIProductOption => typia.random<IPageIProductOption>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetches a single product option from product_options by ID.
 *
 * Retrieves all fields of a single product option from product_options by
 * primary key. A product option is an atomic characteristic of a product (e.g.,
 * 'size', 'color'), supporting variant configuration and flexible SKU
 * management. This endpoint also returns relational fields or foreign keys as
 * required, supporting integration, catalog administration, and option
 * analytics. Returns error if the option doesn't exist or is inaccessible due
 * to permissions. Complements the product option creation, update, deletion,
 * and listing endpoints in the overall API.
 *
 * @param props.id Primary key for the product option to fetch
 * @path /productOptions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Primary key for the product option to fetch */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IProductOption;

  export const METADATA = {
    method: "GET",
    path: "/productOptions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/productOptions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IProductOption =>
    typia.random<IProductOption>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates a single product option in product_options by ID.
 *
 * Modifies fields of a product option record in product_options, supporting
 * safe update by enforcing schema validations (such as name, required, and
 * sort_order rules). Used in the context of catalog or SKU management, enabling
 * flexibility and dynamic e-commerce product configuration. The update may be
 * partial or full, depending on business rules. Related API endpoints support
 * complete product option CRUD lifecycle. Errors cover not found, validation
 * error, or authorization failure. An updated record is returned, including all
 * changed fields and references to ensure UI consistency and data integrity for
 * commerce operations.
 *
 * @param props.id Primary key for the product option to update
 * @param props.body Fields to update on the target product option
 * @path /productOptions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Primary key for the product option to update */
    id: string & tags.Format<"uuid">;

    /** Fields to update on the target product option */
    body: IProductOption.IUpdate;
  };
  export type Body = IProductOption.IUpdate;
  export type Response = IProductOption;

  export const METADATA = {
    method: "PUT",
    path: "/productOptions/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/productOptions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IProductOption =>
    typia.random<IProductOption>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft deletes a product option in product_options by ID.
 *
 * Deletes a product option by marking its deleted_at field, without physical
 * removal. Option deletion is only possible if it's not in use by variants.
 * Business logic enforces referential and workflow integrity. Logged for audit;
 * part of product option CRUD API surface. Supports catalog maintenance and
 * configuration cleanup for sellers/admins. Related endpoints for list, create,
 * update, and fetch complete the REST lifecycle for this resource.
 *
 * @param props.id Primary key for the product option to delete
 * @path /productOptions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Primary key for the product option to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/productOptions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/productOptions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

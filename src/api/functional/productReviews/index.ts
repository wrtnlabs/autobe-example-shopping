import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IProductReview } from "../../structures/IProductReview";
import { IPageIProductReview } from "../../structures/IPageIProductReview";

/**
 * Create a new product review (product_reviews table, including
 * versioned/snapshot context) as verified user.
 *
 * Enables an authenticated user (usually verified buyer) to submit a new review
 * for a product, or for a specific product snapshot in the case of versioned
 * products. The endpoint accepts required fields such as product ID,
 * product_snapshot ID (if present/applicable), author ID (from session),
 * rating, title (optional), review body, and any moderation flagging.
 *
 * Business logic ensures only one review per product/snapshot per user, and
 * enforces anti-abuse/fraud detection as outlined in the requirements (possibly
 * integrating with AI/fraud modules). Successful creation returns the full
 * review record.
 *
 * This endpoint is a critical part of the engagement lifecycle for products,
 * complimented by PATCH (list/search), GET (detail), PUT (update), and DELETE
 * (soft-delete) endpoints. All review creation events are logged for
 * audit/compliance reporting.
 *
 * @param props.body All required information to create a product review,
 *   including snapshot reference, author, rating, and content.
 * @path /productReviews
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * All required information to create a product review, including
     * snapshot reference, author, rating, and content.
     */
    body: IProductReview.ICreate;
  };
  export type Body = IProductReview.ICreate;
  export type Response = IProductReview;

  export const METADATA = {
    method: "POST",
    path: "/productReviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/productReviews";
  export const random = (g?: Partial<typia.IRandomGenerator>): IProductReview =>
    typia.random<IProductReview>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List and search product reviews (product_reviews table) with filtering and
 * pagination.
 *
 * This API provides an advanced product review listing and search function for
 * the 'product_reviews' table. Clients may request reviews by product ID,
 * snapshot ID (for immutable product version linkage), author, star rating,
 * creation date, or moderation status. The endpoint is used for product page
 * review lists, admin/moderation dashboards, and search interfaces. For
 * administrators/moderators, additional filters may be exposed (e.g., to
 * include soft-deleted or flagged reviews).
 *
 * Pagination and sorting (by date/rating) are supported in the request body to
 * handle large review sets. Standard RBAC is enforced to ensure regular users
 * only see published/non-deleted, verified reviews as appropriate, while
 * privileged users can see all for moderation. The endpoint is fully auditable
 * and allows integration with GET (retrieve single), POST (create), PUT
 * (update), and DELETE (soft-delete) endpoints for full product review
 * lifecycle management.
 *
 * @param props.body Filter/search options for product reviews, including
 *   product ID, snapshot, author, rating, moderation status, pagination, etc.
 * @path /productReviews
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filter/search options for product reviews, including product ID,
     * snapshot, author, rating, moderation status, pagination, etc.
     */
    body: IProductReview.IRequest;
  };
  export type Body = IProductReview.IRequest;
  export type Response = IPageIProductReview;

  export const METADATA = {
    method: "PATCH",
    path: "/productReviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/productReviews";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIProductReview => typia.random<IPageIProductReview>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a specific product review (product_reviews table) by ID for
 * detail/audit.
 *
 * Fetches the full details for a single product review from the
 * 'product_reviews' table, targeted by ID. Returns all relevant fields (product
 * reference, author, product_snapshot link, star rating, content body,
 * timestamps, and associated metadata). If the review is soft-deleted or
 * otherwise hidden, only authorized roles (admin/moderator) will be able to
 * access it.
 *
 * Appropriate for product review detail pages, moderation dashboards, and audit
 * needs. Combined with reviewing endpoints (PATCH for listing, POST for
 * creation, PUT for updating, and DELETE for soft-deletion) to support full
 * review lifecycle management.
 *
 * @param props.id ID of the product review to retrieve.
 * @path /productReviews/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** ID of the product review to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IProductReview;

  export const METADATA = {
    method: "GET",
    path: "/productReviews/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/productReviews/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IProductReview =>
    typia.random<IProductReview>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a specific product review (product_reviews table) by ID with
 * RBAC/audit control.
 *
 * Allows an authenticated and authorized user (original review author, admin,
 * moderator) to update a product review. Required validation: user must be
 * permitted to edit this review, and only allowed fields may be updated (e.g.,
 * owner can change headline/body/rating, staff can set moderation flags, etc.).
 * The system must fully log/audit all modifications, possibly creating a new
 * review version/snapshot for compliance.
 *
 * The request body specifies modifications (headline, body, rating, moderation
 * metadata). The endpoint ensures RBAC and audit compliance, and returns
 * updated review data. This function supports lifecycle coverage alongside
 * creation, retrieval, searching, and deletion endpoints for product reviews.
 *
 * @param props.id ID of the product review to update.
 * @param props.body Fields to update for this product review (headline,
 *   content, rating, moderation only as allowed).
 * @path /productReviews/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** ID of the product review to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Fields to update for this product review (headline, content, rating,
     * moderation only as allowed).
     */
    body: IProductReview.IUpdate;
  };
  export type Body = IProductReview.IUpdate;
  export type Response = IProductReview;

  export const METADATA = {
    method: "PUT",
    path: "/productReviews/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/productReviews/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IProductReview =>
    typia.random<IProductReview>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a product review (product_reviews table) by ID with audit
 * compliance.
 *
 * Allows authorized users (original review author, moderator, or admin) to
 * soft-delete a product review, setting its 'deleted_at' timestamp and
 * preserving the record for compliance, audit, and moderation. Physically
 * deleting the review is not permitted by policy; soft-delete ensures proper
 * history for legal reporting and staff access.
 *
 * Related endpoints cover review creation (POST), listing/searching (PATCH),
 * detail (GET), updating (PUT), each supporting the review engagement
 * lifecycle. Operation should return confirmation, success flag, and updated
 * audit status. RBAC and audit logging are mandatory for this operation.
 *
 * @param props.id ID of the product review to soft-delete.
 * @path /productReviews/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** ID of the product review to soft-delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IProductReview.ISoftDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/productReviews/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/productReviews/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IProductReview.ISoftDeleteResult =>
    typia.random<IProductReview.ISoftDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

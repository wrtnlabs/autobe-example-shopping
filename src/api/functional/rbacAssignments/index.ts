import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRbacAssignment } from "../../structures/IRbacAssignment";
import { IPageIRbacAssignment } from "../../structures/IPageIRbacAssignment";

/**
 * Assign a role and permission to a user by creating an RBAC assignment.
 *
 * This endpoint creates a new RBAC assignment for a user, role, and permission
 * mapping in the system RBAC model (as reflected in the 'rbac_assignments'
 * table). On POST, it validates the atomic assignment fields (including
 * user_id, role_id, permission_id, and optional scoping/expiry), ensuring that
 * no duplicate exists for the same combination.
 *
 * Assignment creation is admin-restricted as it can alter permissions and
 * escalate access. All actions are logged in the audit log for traceability,
 * which is essential for rollback or investigating incidents. If any of the
 * provided IDs do not exist or violate constraints (e.g., role/permission not
 * found), a validation or not-found error is returned. Success returns the full
 * newly created assignment record.
 *
 * Edge cases: Duplicate assignments (same user/role/permission/context) result
 * in a conflict error. Only users with explicit admin/RBAC assignment rights
 * may use this endpoint. Assignment creation is fully auditable and supports
 * compliance needs.
 *
 * @param props.body RBAC assignment creation payload, aligning with
 *   IRbacAssignment.ICreate (user_id, role_id, permission_id, channel/section
 *   scope, expiry).
 * @path /rbacAssignments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * RBAC assignment creation payload, aligning with
     * IRbacAssignment.ICreate (user_id, role_id, permission_id,
     * channel/section scope, expiry).
     */
    body: IRbacAssignment.ICreate;
  };
  export type Body = IRbacAssignment.ICreate;
  export type Response = IRbacAssignment;

  export const METADATA = {
    method: "POST",
    path: "/rbacAssignments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/rbacAssignments";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IRbacAssignment => typia.random<IRbacAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a filtered, paginated list of RBAC assignments.
 *
 * This list endpoint retrieves RBAC assignments from the 'rbac_assignments'
 * table, supporting advanced filtering, searching by user_id, role_id,
 * permission_id, channel/section scope, or expiry. The endpoint is meant for
 * admin/operations teams managing access control: search is specified via a
 * request body, with pagination and sorting options included (e.g., per page,
 * offset, sort by created_at, etc).
 *
 * For each assignment returned, the fields include references to user ID, role
 * ID, permission ID, and their scoping/expiry information as per the table
 * schema. The endpoint never includes denormalized related entity details—those
 * should be queried separately. Only users with explicit admin/RBAC audit
 * rights may access this list.
 *
 * Edge cases: If no assignments match the filters, returns an empty result with
 * proper pagination meta. Request body structure must match
 * IRbacAssignment.IRequestSearch. The endpoint is fully auditable—every access
 * is logged for compliance.
 *
 * @param props.body Search and pagination filters for RBAC assignment list,
 *   matching IRbacAssignment.IRequestSearch data structure.
 * @path /rbacAssignments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Search and pagination filters for RBAC assignment list, matching
     * IRbacAssignment.IRequestSearch data structure.
     */
    body: IRbacAssignment.IRequestSearch;
  };
  export type Body = IRbacAssignment.IRequestSearch;
  export type Response = IPageIRbacAssignment;

  export const METADATA = {
    method: "PATCH",
    path: "/rbacAssignments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/rbacAssignments";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIRbacAssignment => typia.random<IPageIRbacAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a single RBAC assignment record by ID.
 *
 * This endpoint returns a single RBAC assignment entity identified by its
 * unique ID, mapping directly to the table 'rbac_assignments'. Admins can use
 * this to review the specific links between user, role, and permission, as well
 * as any assignment-scoped context (channel, section, expiry). No extraneous
 * data or denormalized entity details are included; all related records must be
 * fetched separately.
 *
 * If the provided assignment ID does not correspond to any record, a not-found
 * error is returned. If access is not permitted, a forbidden error is raised.
 * The access is logged in the audit log for traceability, per compliance
 * practices. Used for admin dashboards, compliance investigations, and
 * troubleshooting permission issues.
 *
 * @param props.id Unique identifier of the RBAC assignment to retrieve.
 * @path /rbacAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier of the RBAC assignment to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IRbacAssignment;

  export const METADATA = {
    method: "GET",
    path: "/rbacAssignments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/rbacAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IRbacAssignment => typia.random<IRbacAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an RBAC assignment by its unique ID.
 *
 * This endpoint is for updating an existing RBAC assignment by its unique ID.
 * Updates may include changes to the role_id, permission_id, scoping fields
 * (channel/section), or assignment expiry, all following atomic change and full
 * audit logging.
 *
 * The endpoint validates that the target assignment exists and that the new
 * mapping does not introduce a duplicate or contradictory assignment. Updating
 * role/permission assignments is privileged and triggers audit log entries for
 * traceability. Any access or update error results in a clear, audit-captured
 * error response. If the request attempts to update to a non-existent entity
 * (e.g., reference to invalid role_id), a validation or not-found error is
 * returned.
 *
 * The endpoint does not update data in user, role, or permission entities, only
 * the junction assignment table as required by strict normalization/compliance
 * approaches.
 *
 * @param props.id Unique identifier for the RBAC assignment to update.
 * @param props.body RBAC assignment update payload, provides atomic field
 *   changes for assignment row (role_id/permission_id/scope/expiry).
 * @path /rbacAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier for the RBAC assignment to update. */
    id: string & tags.Format<"uuid">;

    /**
     * RBAC assignment update payload, provides atomic field changes for
     * assignment row (role_id/permission_id/scope/expiry).
     */
    body: IRbacAssignment.IUpdate;
  };
  export type Body = IRbacAssignment.IUpdate;
  export type Response = IRbacAssignment;

  export const METADATA = {
    method: "PUT",
    path: "/rbacAssignments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/rbacAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IRbacAssignment => typia.random<IRbacAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Logically delete (soft delete) an RBAC assignment by ID.
 *
 * This endpoint logically deletes an RBAC assignment by marking it as deleted
 * (soft delete, deleted_at timestamp) instead of removing it from the database.
 * This supports compliance and auditability by keeping a record of all
 * historical assignments. Only admins or system users with explicit privilege
 * may execute this deletion.
 *
 * Upon call, the endpoint checks whether the assignment exists and whether it
 * is safe to remove (e.g., not an essential/system-critical mapping).
 * Attempting to delete a non-existent assignment will result in a not-found
 * error. All deletions, successful or failed, are audit-logged for compliance
 * and traceability. Assignment removal may trigger downstream workflows for
 * permission reconciliation, but these are handled outside this endpoint.
 *
 * @param props.id Unique identifier for the RBAC assignment to delete.
 * @path /rbacAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier for the RBAC assignment to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IRbacAssignment;

  export const METADATA = {
    method: "DELETE",
    path: "/rbacAssignments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/rbacAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IRbacAssignment => typia.random<IRbacAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRbacRole } from "../../structures/IRbacRole";
import { IPageIRbacRole } from "../../structures/IPageIRbacRole";
import { IResult } from "../../structures/IResult";

/**
 * Create a new RBAC role in the system ('rbac_roles' table).
 *
 * This operation allows a system administrator to define add a new RBAC role to
 * support custom permission workflows, compliance requirements, or
 * project-based permission sets. The body corresponds to 'IRbacRole.ICreate',
 * enforcing code uniqueness and validating other role metadata. Role creation
 * is audited for compliance and regulatory export. Only users with system or
 * RBAC management scope may create roles. The new role is immediately available
 * for assignment once created. Failure or errors (permissions, duplicate code,
 * missing fields) return error responses as per system convention. Used
 * together with PATCH/GET/PUT/DELETE for lifecycle management.
 *
 * @param props.body Payload with all required information to create a new RBAC
 *   role (code, description, etc.).
 * @path /rbacRoles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Payload with all required information to create a new RBAC role
     * (code, description, etc.).
     */
    body: IRbacRole.ICreate;
  };
  export type Body = IRbacRole.ICreate;
  export type Response = IRbacRole;

  export const METADATA = {
    method: "POST",
    path: "/rbacRoles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/rbacRoles";
  export const random = (g?: Partial<typia.IRandomGenerator>): IRbacRole =>
    typia.random<IRbacRole>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a paginated/searchable list of RBAC roles (from 'rbac_roles' table).
 *
 * This operation provides an authorized user (typically admin) with a
 * paginated, filterable list of all RBAC role definitions currently in the
 * system, as represented in the 'rbac_roles' table. Each role includes key
 * fields (code, description, is_builtin, timestamps) per schema.
 * Filtering/search are especially important in large installations with many
 * custom/temporary/project roles. Access is strictly enforced: only users with
 * system-level administrative or RBAC management rights may execute this query.
 * Standard system pagination and search conventions (filter by
 * code/description, sort, page size) apply. This list operation complements
 * detail, create, update, and delete endpoints for full lifecycle RBAC control.
 * Error handling for permission, filter validation, and out-of-range pagination
 * is mandatory, surfaced via standard API error contracts.
 *
 * @param props.body Filter/search criteria and paging options for RBAC roles
 *   list.
 * @path /rbacRoles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filter/search criteria and paging options for RBAC roles list. */
    body: IRbacRole.IRequest;
  };
  export type Body = IRbacRole.IRequest;
  export type Response = IPageIRbacRole;

  export const METADATA = {
    method: "PATCH",
    path: "/rbacRoles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/rbacRoles";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIRbacRole =>
    typia.random<IPageIRbacRole>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get details for a specific RBAC role (from 'rbac_roles' table) by id.
 *
 * This endpoint allows an admin or authorized user to retrieve all recorded
 * information for a specific RBAC role, as persisted in the 'rbac_roles' table.
 * Returns normalized attribute set per schemaâ€”id, code, description,
 * is_builtin, audit timestamps, etc. This operation helps administrators and
 * governance staff inspect exact role structures for compliance and permission
 * troubleshooting. The operation is used together with list, create, update,
 * and delete endpoints for full RBAC lifecycle. RBAC and audit policy enforced
 * so only eligible users/roles can access. If no role exists for the specified
 * id, a not-found error is returned per API convention.
 *
 * @param props.id Unique identifier for the RBAC role to retrieve.
 * @path /rbacRoles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier for the RBAC role to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IRbacRole;

  export const METADATA = {
    method: "GET",
    path: "/rbacRoles/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/rbacRoles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IRbacRole =>
    typia.random<IRbacRole>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an RBAC role's details (from 'rbac_roles' table) by id.
 *
 * Allows an admin or privileged user to update details of an existing RBAC role
 * in the system. Typical use cases: amending a custom role's description,
 * renaming a project-based role, or toggling is_builtin for internal system
 * repointing (though generally only false for custom roles). The body matches
 * 'IRbacRole.IUpdate', which supports updating code, description, and auxiliary
 * fields. Unique code constraint is enforced. All updates are audit-logged,
 * with changes cross-referenced for compliance and rollback. Security enforced
 * by RBAC. Errors for permission, update conflict, or non-existent roles are
 * handled per standard API contract. Operates together with
 * PATCH/GET/POST/DELETE for complete management.
 *
 * @param props.id Unique identifier for the RBAC role to update.
 * @param props.body Fields to update for the RBAC role.
 * @path /rbacRoles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier for the RBAC role to update. */
    id: string & tags.Format<"uuid">;

    /** Fields to update for the RBAC role. */
    body: IRbacRole.IUpdate;
  };
  export type Body = IRbacRole.IUpdate;
  export type Response = IRbacRole;

  export const METADATA = {
    method: "PUT",
    path: "/rbacRoles/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/rbacRoles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IRbacRole =>
    typia.random<IRbacRole>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete (retire) a specific RBAC role (from 'rbac_roles' table) by id.
 *
 * Allows an authorized admin to permanently remove or retire a custom RBAC role
 * from active assignment. Removal is generally hard delete unless compliance
 * policy requires soft-delete and audit retention. Standard system checks
 * ensure not deleting built-in or in-use roles (error if attempted). All
 * deletions are kept in audit logs for full regulatory traceability. After
 * deletion, role cannot be further assigned in the RBAC engine. Used in
 * conjunction with PATCH, GET, POST, and PUT as part of lifecycle management.
 *
 * @param props.id Unique identifier for the RBAC role to delete.
 * @path /rbacRoles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier for the RBAC role to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IResult;

  export const METADATA = {
    method: "DELETE",
    path: "/rbacRoles/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/rbacRoles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IResult =>
    typia.random<IResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IReturn } from "../../structures/IReturn";
import { IPageIReturn } from "../../structures/IPageIReturn";

/**
 * Create a new product return for an order item.
 *
 * This operation registers a new return for a specific purchased order item.
 * The request includes required details such as order_item_id, user_id (as
 * initiator), return reason, and any supporting information for after-sales
 * processing. The table models each return as an atomic, auditable event, which
 * then participates in system workflows (approval, refund, analysis).
 *
 * Validation: Input checks ensure the order item is eligible for return, not
 * already returned/exchanged, and supplied information is complete.
 * Permissions: Customers can generally initiate their own returns;
 * sellers/admins may act for escalations with proper authorization; all actions
 * are audit-logged.
 *
 * Related: Status change/update is managed by separate endpoints. Once created,
 * the return participates in tracked after-sales workflow.
 *
 * Errors: Business logic errors (ineligible for return), missing/invalid IDs,
 * or permission failures trigger standardized API errors.
 *
 * @param props.body New return registration (order item, user, reason, etc.).
 * @path /returns
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** New return registration (order item, user, reason, etc.). */
    body: IReturn.ICreate;
  };
  export type Body = IReturn.ICreate;
  export type Response = IReturn;

  export const METADATA = {
    method: "POST",
    path: "/returns",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/returns";
  export const random = (g?: Partial<typia.IRandomGenerator>): IReturn =>
    typia.random<IReturn>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a paginated and filtered list of product return records.
 *
 * This operation retrieves a paginated and optionally filtered list of product
 * returns as recorded in the returns table. Returns are per-order-item
 * customer-initiated events, supporting rich status tracking
 * (requested/approved/rejected/completed), auditability, and reporting.
 * Filtering parameters may include user ID, status, order/item ID, date ranges,
 * or reason substrings.
 *
 * Security: RBAC-controlled; users may view their own returns, sellers/admins
 * may see scope-limited results. Sensitive PII in order or user references is
 * filtered based on role.
 *
 * Business: This API is critical for after-sales compliance (GDPR/CCPA, see
 * requirements), customer management, and analytics. List result may include
 * links to details, modification endpoints, and audit/event histories.
 *
 * Errors: Validation errors for unsupported search parameters, permissions, or
 * internal search failures will follow standardized error responses.
 *
 * @param props.body Filter and pagination options for retrieving returns data.
 * @path /returns
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filter and pagination options for retrieving returns data. */
    body: IReturn.IRequest;
  };
  export type Body = IReturn.IRequest;
  export type Response = IPageIReturn;

  export const METADATA = {
    method: "PATCH",
    path: "/returns",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/returns";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIReturn =>
    typia.random<IPageIReturn>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get the details of a single return record in the returns table.
 *
 * This endpoint returns all details of a target return record as kept in the
 * returns table. Returns are linked to a specific order item, user, and include
 * reason, status, and workflow timestamps (requested_at, completed_at).
 * Response includes all atomic/normalized fields—order or user references are
 * filtered per role/permissions (e.g., customers only see their records,
 * sellers/admins see broader data).
 *
 * This operation assists in after-sales escalation, return status tracking,
 * analytics, and serves as a base for further actions (e.g., completion,
 * cancellation, reporting).
 *
 * Errors: Returns 404 for nonexistent or deleted return IDs. Permissions and
 * masking enforced as per RBAC policy.
 *
 * @param props.id Target return's unique identifier (UUID) to retrieve.
 * @path /returns/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target return's unique identifier (UUID) to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IReturn;

  export const METADATA = {
    method: "GET",
    path: "/returns/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/returns/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IReturn =>
    typia.random<IReturn>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update metadata or workflow status of a return record.
 *
 * Allows authorized actors to update details of an existing return record, such
 * as progressing the workflow status (requested/approved/rejected/completed),
 * updating reasons, or adding supplementary notes/detail fields. The API
 * enforces validation against business logic/rules (e.g., transitions only
 * allowed per defined workflow; some fields immutable after certain stages).
 *
 * Security: Only the owner (customer), authorized seller, or admin can update
 * returns—enforced by RBAC logic. All updates are audit-logged for compliance
 * (legal requirements, dispute handling).
 *
 * Errors: Invalid transition/state, permission failures, or modification
 * attempts on finalized/deleted returns return errors as per API policy.
 *
 * @param props.id Return's unique identifier (UUID) to update.
 * @param props.body Return update information and workflow status change
 *   request.
 * @path /returns/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Return's unique identifier (UUID) to update. */
    id: string & tags.Format<"uuid">;

    /** Return update information and workflow status change request. */
    body: IReturn.IUpdate;
  };
  export type Body = IReturn.IUpdate;
  export type Response = IReturn;

  export const METADATA = {
    method: "PUT",
    path: "/returns/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/returns/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IReturn =>
    typia.random<IReturn>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a return record for audit and compliance purposes.
 *
 * This endpoint marks a return as deleted in the returns table by setting its
 * 'deleted_at' field, ensuring the record is preserved for compliance and
 * audit. Deletion is only permitted for allowed roles and when business rules
 * permit (e.g., returns not finalized/completed, proper authorization). Related
 * after-sales or refund processing is not reversed by this call—manual review
 * may be required for complex dependencies.
 *
 * RBAC: Permission checks are enforced; only allowed users/admins can
 * soft-delete returns. Errors include insufficient permissions, attempts to
 * delete non-existent or already-deleted records, or workflow violations.
 *
 * Audit: All deletions are immutably logged and can be reviewed in after-sales
 * compliance reporting.
 *
 * @param props.id Return record's unique identifier (UUID) to delete.
 * @path /returns/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Return record's unique identifier (UUID) to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IReturn;

  export const METADATA = {
    method: "DELETE",
    path: "/returns/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/returns/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IReturn =>
    typia.random<IReturn>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

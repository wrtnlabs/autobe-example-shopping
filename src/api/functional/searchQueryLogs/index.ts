import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ISearchQueryLog } from "../../structures/ISearchQueryLog";
import { IPageISearchQueryLog } from "../../structures/IPageISearchQueryLog";

/**
 * Insert a new search query log entry into the search_query_logs table for
 * audit/analytics purposes.
 *
 * This endpoint receives data on a search event (as performed by a user or
 * system module) and persists a new search query log entry in the
 * 'search_query_logs' database table. The POST body requires essential event
 * details: the search query as plain text, associated language/locale,
 * (optionally) a JSON-encoded string describing filters/facets, result count
 * returned, and if available, the user’s unique identifier. Strict input
 * validation ensures all mandatory fields (query, language, result_count,
 * created_at) are present and type-safe.
 *
 * The operation is subject to RBAC: only trusted internal subsystems or users
 * with 'log:write' or analytics-write permission may call this endpoint,
 * maintaining legal and business compliance. Write attempts involving invalid
 * data or unauthorized requesters are rejected (400, 403). When storing
 * user-linked search activity, all PII and sensitive content must be
 * pre-processed or redacted as per privacy policy.
 *
 * @param props.body A new search event's log details, including query,
 *   language, filters, result count, and optional user reference.
 * @path /searchQueryLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * A new search event's log details, including query, language, filters,
     * result count, and optional user reference.
     */
    body: ISearchQueryLog.ICreate;
  };
  export type Body = ISearchQueryLog.ICreate;
  export type Response = ISearchQueryLog;

  export const METADATA = {
    method: "POST",
    path: "/searchQueryLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/searchQueryLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISearchQueryLog => typia.random<ISearchQueryLog>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a paginated, filterable list of search query log entries from
 * search_query_logs table.
 *
 * This endpoint provides a comprehensive, paginated, and filterable listing
 * interface for search query logs, supporting advanced analytics, compliance
 * examination, and large-scale audit scenarios. The underlying Prisma table
 * 'search_query_logs' is designed to record every individual search event (from
 * user or system), including query term, applied filters, detected language,
 * user reference (optional), and the result count returned. All columns are
 * fully atomic for third normal form, and denormalization for aggregate
 * reporting is kept external to this table.
 *
 * Access to the `/searchQueryLogs` PATCH endpoint is restricted to users and
 * admins with explicit permission for analytics/reporting as the log data may
 * include privacy-sensitive user actions or internal system queries. Clients
 * typically supply a JSON request body with filters—such as by date range,
 * language, query text, or min/max result count—for audit, security review, or
 * dashboard rendering. Sorting (by recency, relevance, or volume) and
 * pagination are enforced by parameters in the request body to ensure scalable
 * and efficient querying.
 *
 * If the system is configured for multi-tenant operation, additional filters
 * may enforce that only logs from the requesting user or accessible tenants are
 * included. Operational errors (e.g., invalid filter, malformed date, or
 * missing mandatory pagination info) return a 400 error. Unauthorized access
 * (missing permissions) returns 403. Search queries are never deleted directly
 * to support audit and compliance unless explicitly purged for legal reasons.
 *
 * @param props.body Filtering, sorting, and pagination options for search query
 *   log list retrieval.
 * @path /searchQueryLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filtering, sorting, and pagination options for search query log list
     * retrieval.
     */
    body: ISearchQueryLog.IRequest;
  };
  export type Body = ISearchQueryLog.IRequest;
  export type Response = IPageISearchQueryLog;

  export const METADATA = {
    method: "PATCH",
    path: "/searchQueryLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/searchQueryLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageISearchQueryLog => typia.random<IPageISearchQueryLog>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve detailed information about a specific search query log entry by UUID
 * from search_query_logs table.
 *
 * GET /searchQueryLogs/{id} retrieves all stored details for one search query
 * log entry, precisely as stored in the search_query_logs database table. This
 * table is purpose-built for the AI Shopping Mall’s analytics and compliance
 * needs, capturing per-event search actions by users or the system itself. The
 * entry includes the plain-text query, language code (for i18n or
 * localization), filter details (e.g. category, price, etc, stored as JSON
 * string), a reference to user if authenticated (may be null), and the integer
 * result count.
 *
 * Access to the detail endpoint is restricted to analytics-enabled users,
 * admins, or users accessing their own records per RBAC rules. The API performs
 * input validation on UUID (returns 400 on error) and checks record existence
 * (404 if absent). Upon success, all data fields (including metadata) are
 * returned for display, audit, or analyst review. This endpoint is frequently
 * paired with PATCH (list/filter) and DELETE (logical remove), providing
 * complete auditability and error traceability on search behaviors.
 *
 * @param props.id Unique identifier of the search query log entry (UUID).
 * @path /searchQueryLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier of the search query log entry (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ISearchQueryLog;

  export const METADATA = {
    method: "GET",
    path: "/searchQueryLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/searchQueryLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISearchQueryLog => typia.random<ISearchQueryLog>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Overwrite (replace) or annotate an existing search query log record in the
 * search_query_logs table by UUID.
 *
 * This endpoint provides secure, full update capability of an individual search
 * query log record, identified by UUID. Typical cases involve correcting a
 * logged search (e.g., retroactive filter updates, amending misrecorded
 * language code, or appending a compliance annotation/tag) or updating user
 * attribution after a merger of accounts. Input is strictly validated and
 * type-safe: only all required fields in the request body will be used to
 * overwrite the log entry. All changes must be audit-logged, storing prior
 * record state for full rollback and legal auditability.
 *
 * PUT on /searchQueryLogs/{id} is access controlled to admins,
 * analytics/compliance officers, or trusted service accounts only. Invalid
 * UUIDs result in 400 error, missing records return 404, and permission issues
 * give 403. The response returns the modified record matching
 * 'ISearchQueryLog'. If partial update is needed, use PATCH or relevant
 * sub-field update endpoint (not defined in this basic CRUD set).
 *
 * @param props.id Unique identifier for the search query log record to update
 *   (UUID).
 * @param props.body Complete set of fields overwriting the target search query
 *   log record.
 * @path /searchQueryLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier for the search query log record to update (UUID). */
    id: string & tags.Format<"uuid">;

    /**
     * Complete set of fields overwriting the target search query log
     * record.
     */
    body: ISearchQueryLog.IUpdate;
  };
  export type Body = ISearchQueryLog.IUpdate;
  export type Response = ISearchQueryLog;

  export const METADATA = {
    method: "PUT",
    path: "/searchQueryLogs/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/searchQueryLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISearchQueryLog => typia.random<ISearchQueryLog>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete (logical remove) a single search query log entry in the
 * search_query_logs table by UUID for compliance.
 *
 * This endpoint flags one search query log entry in the search_query_logs table
 * as deleted (using soft delete via a deleted_at timestamp). This is a
 * compliance-driven feature supporting regulatory requirements (such as GDPR's
 * right to erasure) while preserving the system's audit trace. When called, the
 * log entry will be suppressed from standard audit/analytics views but remains
 * available for privileged compliance inspection or rollback if needed. The
 * endpoint takes a UUID identifying the record to delete, validates the
 * requestor's privileges, and returns a success/failure status. Record is never
 * physically erased.
 *
 * Errors returned include 400 (invalid ID), 404 (no such record or already
 * deleted), and 403 (insufficient privileges). This operation is intended for
 * data compliance officers or super-admins only. For full record retrieval or
 * update after deletion, privileged admin override endpoints or compliance
 * restore tools must be used.
 *
 * @param props.id UUID of the search query log entry to soft-delete.
 * @path /searchQueryLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the search query log entry to soft-delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ISearchQueryLog.IDeleteResponse;

  export const METADATA = {
    method: "DELETE",
    path: "/searchQueryLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/searchQueryLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISearchQueryLog.IDeleteResponse =>
    typia.random<ISearchQueryLog.IDeleteResponse>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

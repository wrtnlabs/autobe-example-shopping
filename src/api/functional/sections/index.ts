import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ISection } from "../../structures/ISection";
import { IPageISection } from "../../structures/IPageISection";

/**
 * Create a new Section resource (sections table).
 *
 * Creates a Section resource (e.g., Home Banner or Flash Sale Area) within a
 * channel context. The payload must contain all required data per the sections
 * table (channel_id, code, name, order, etc.), validated for normalization and
 * channel uniqueness of the code. RBAC ensures only authorized users or
 * integrations may add Sections.
 *
 * Returns a full normalized Section record as stored in the database, including
 * all standard fields and creation metadata (created_at, updated_at). All
 * operations are logged for trace/audit purposes. Endpoint is part of the
 * channel/structure management suite along with list, get, update, and delete
 * APIs.
 *
 * @param props.body Payload for Section creation operation.
 * @path /sections
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Payload for Section creation operation. */
    body: ISection.ICreate;
  };
  export type Body = ISection.ICreate;
  export type Response = ISection;

  export const METADATA = {
    method: "POST",
    path: "/sections",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/sections";
  export const random = (g?: Partial<typia.IRandomGenerator>): ISection =>
    typia.random<ISection>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Search/List Section resources from sections table.
 *
 * Retrieves a paginated, filtered, and sorted list of Section resources. Used
 * by admins or integrators to manage storefront subdivisions (such as Home
 * Banner, Flash Sale areas). Query parameters enable filtering by channel,
 * code, display name, and order (sort). RBAC ensures permissioned access to the
 * specific channel or section context; audit logs can be produced for each
 * search event, per compliance. The API returns all fields defined in the
 * Section schema, including timestamps (created_at, updated_at, deleted_at).
 *
 * Used in conjunction with Section create, get, update, and delete endpoints
 * for store/channel structure administration. Pagination options ensure
 * scalability for large storefronts. Returns compliance and error information
 * for filtering, access, and state conditions.
 *
 * @param props.body Search/filter/pagination criteria for Section list
 *   operation.
 * @path /sections
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filter/pagination criteria for Section list operation. */
    body: ISection.IRequest;
  };
  export type Body = ISection.IRequest;
  export type Response = IPageISection;

  export const METADATA = {
    method: "PATCH",
    path: "/sections",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/sections";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageISection =>
    typia.random<IPageISection>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get Section resource by ID (sections table).
 *
 * This endpoint returns all Section details as defined in the Prisma sections
 * model, including its code, name, display order, configuration, and all
 * audit/compliance fields. Request is permission-checked using RBAC; only
 * authorized users may view the section.
 *
 * The operation produces errors on not-found, deleted, or unauthorized access
 * requests. Used together with Section list, create, update, and delete
 * endpoints for full channel/store structure management. Returns all normalized
 * record fields (including timestamps and soft delete marker). Audit logs may
 * be written to track view intent based on policy.
 *
 * @param props.id Unique ID (UUID) of Section for lookup.
 * @path /sections/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique ID (UUID) of Section for lookup. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ISection;

  export const METADATA = {
    method: "GET",
    path: "/sections/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/sections/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ISection =>
    typia.random<ISection>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update Section by ID (sections table).
 *
 * Updates an existing Section resource as identified by its ID. Payload
 * contains new/modified values for Section fields following the same
 * normalization logic enforced at creation. RBAC ensures only permitted users
 * may modify Sections in a given channel; audit logs created on modification.
 *
 * Endpoint ensures all fields are valid and the Section still meets unique
 * constraints (esp. channel_id+code). Returns the post-update Section record in
 * normalized form. Used together with Section list, get, create, and delete
 * endpoints for full structure administration.
 *
 * @param props.id Unique ID (UUID) of Section to update.
 * @param props.body Payload for Section update operation.
 * @path /sections/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique ID (UUID) of Section to update. */
    id: string & tags.Format<"uuid">;

    /** Payload for Section update operation. */
    body: ISection.IUpdate;
  };
  export type Body = ISection.IUpdate;
  export type Response = ISection;

  export const METADATA = {
    method: "PUT",
    path: "/sections/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/sections/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ISection =>
    typia.random<ISection>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete Section by ID (sections table).
 *
 * Soft-deletes a Section resource, marking deleted_at while leaving the record
 * available for audit, rollback, or compliance investigation. Operation is
 * protected by RBAC: only authorized actors may remove Section resources. Error
 * responses are returned for missing, already deleted, or inaccessible
 * resources.
 *
 * Works together with Section list, get, create, and update APIs to provide
 * complete structure lifecycle management. All soft-delete operations are
 * returned with updated Section state (including deletion timestamp) and are
 * logged for compliance.
 *
 * @param props.id Unique ID (UUID) of Section to delete.
 * @path /sections/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique ID (UUID) of Section to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ISection;

  export const METADATA = {
    method: "DELETE",
    path: "/sections/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/sections/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ISection =>
    typia.random<ISection>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

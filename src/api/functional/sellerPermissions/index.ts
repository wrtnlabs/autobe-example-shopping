import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ISellerPermission } from "../../structures/ISellerPermission";
import { IPageISellerPermission } from "../../structures/IPageISellerPermission";

/**
 * Create a new seller_permission in the seller_permissions table.
 *
 * This API allows admins to create and assign a permission (permission_code) to
 * a seller, as described by the seller_permissions Prisma schema table. The
 * endpoint receives a validated request body with all required
 * attributes—specifically, seller_id, granted_by_admin_id, permission_code, and
 * granted_at. Expires_at may be provided for temporary permissions.
 *
 * Enforcement of business rules includes: Preventing duplicate permission_code
 * assignments to the same seller, honoring the unique constraint. Validating
 * that the granting admin has the privilege to grant the requested permission.
 * Ensuring auditability by logging the creation event, as per compliance.
 *
 * If a permission assignment already exists for the seller and permission_code
 * combination, a suitable error (409 Conflict) is returned. Only users with
 * admin rights are allowed to use this endpoint, checked via RBAC.
 *
 * This endpoint ties directly into seller onboarding, RBAC assignment flows,
 * and administrative audit trails, as described in seller management system
 * requirements.
 *
 * @param props.body Information for creating a new seller_permission
 *   assignment, linking a seller, an admin (granter), and a permission_code.
 *   Required for onboarding/escalation.
 * @path /sellerPermissions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Information for creating a new seller_permission assignment, linking
     * a seller, an admin (granter), and a permission_code. Required for
     * onboarding/escalation.
     */
    body: ISellerPermission.ICreate;
  };
  export type Body = ISellerPermission.ICreate;
  export type Response = ISellerPermission;

  export const METADATA = {
    method: "POST",
    path: "/sellerPermissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/sellerPermissions";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISellerPermission => typia.random<ISellerPermission>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Paginate, filter, and search assignments from seller_permissions for
 * audit/management (admin-only operation).
 *
 * This endpoint returns a paginated, filterable list of seller_permissions from
 * the seller_permissions table. Filters may include seller_id, permission_code,
 * admin (grantor), granted_at range. Search is used for admin dashboards and
 * permission audits. RBAC gating ensures that only authorized users can fetch
 * or audit permission assignments; data may be masked or limited per context.
 * Pagination meta and result records are included in the response, and only
 * atomic seller_permission attributes (no PII/contextual RBAC state) are
 * returned. Access/changes are audit-logged.
 *
 * @param props.body Filters/search/pagination info for seller_permission table:
 *   seller_id, permission_code, admin, dates.
 * @path /sellerPermissions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filters/search/pagination info for seller_permission table:
     * seller_id, permission_code, admin, dates.
     */
    body: ISellerPermission.IRequest;
  };
  export type Body = ISellerPermission.IRequest;
  export type Response = IPageISellerPermission;

  export const METADATA = {
    method: "PATCH",
    path: "/sellerPermissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/sellerPermissions";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageISellerPermission => typia.random<IPageISellerPermission>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a single seller_permission (seller_permissions table) by ID.
 *
 * This API operation retrieves the details of a single seller_permission
 * entity, as defined in the seller_permissions Prisma schema model. The purpose
 * is to allow administrators or system reviewers to fetch the direct permission
 * assignment between a seller and a granted role/permission. Every column from
 * the table is included—such as id, seller_id, granted_by_admin_id,
 * permission_code, granted_at, expires_at—with relationships resolved for
 * contextual display (e.g., augmenting with seller nickname or granting admin
 * username in response, if needed).
 *
 * Security considerations include: Only users with appropriate admin privileges
 * or RBAC permissions may access sensitive permission records, especially those
 * assigned to high-privilege sellers. All accesses are logged for audit, and
 * soft deletion (deleted_at) is respected. If a seller_permission is not found
 * or is soft-deleted and the actor does not have permission to view deleted
 * records, a 404 is returned.
 *
 * Because seller_permissions are part of compliance and escalated access
 * reviews, additional API operations to list all permissions, assign/remove
 * permissions, or filter by roles/channel/context may be needed in the overall
 * API.
 *
 * Error handling includes proper 404 for not found, and 403 for insufficient
 * permissions. The API relates to onboarding, RBAC, and compliance admin flows,
 * where managing and tracking permissions is crucial.
 *
 * When using this endpoint, consumers should also be aware that detailed
 * permission configuration and role/permission explanations can be found via
 * related endpoints for admin_permissions and seller_profiles, tying the
 * results into the system's full RBAC matrix.
 *
 * @param props.id The unique identifier for the target seller_permission.
 * @path /sellerPermissions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** The unique identifier for the target seller_permission. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ISellerPermission;

  export const METADATA = {
    method: "GET",
    path: "/sellerPermissions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/sellerPermissions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISellerPermission => typia.random<ISellerPermission>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing seller_permission record by ID (seller_permissions table).
 *
 * This API endpoint enables updating selected fields of a seller_permission
 * record, as outlined in the seller_permissions Prisma schema. Attribute
 * updates might include changing the permission_code, extending or changing
 * expires_at, or correcting a granted_by_admin_id field (where system policy
 * permits). All edits are strictly audited for traceability, meeting compliance
 * and history requirements. Atomic updates only; no bulk or destructive
 * operations allowed. Soft-deleted records are not updatable except by
 * privileged users for restoration/reversal purposes.
 *
 * Part of the RBAC lifecycle: Used by system/admins to correct or adjust
 * permission assignments in response to changing requirements or escalation
 * reviews. Changes are logged, and system checks for permission to update
 * seller_roles are enforced at the API/middleware level.
 *
 * API consumers are reminded to use GET /sellerPermissions/{id} to obtain the
 * latest version prior to updating, to prevent race conditions.
 *
 * @param props.id The unique identifier for the seller_permission to update.
 * @param props.body Set of attributes to update for the seller_permission, such
 *   as permission_code or expires_at.
 * @path /sellerPermissions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The unique identifier for the seller_permission to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Set of attributes to update for the seller_permission, such as
     * permission_code or expires_at.
     */
    body: ISellerPermission.IUpdate;
  };
  export type Body = ISellerPermission.IUpdate;
  export type Response = ISellerPermission;

  export const METADATA = {
    method: "PUT",
    path: "/sellerPermissions/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/sellerPermissions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISellerPermission => typia.random<ISellerPermission>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete (revoke) a seller_permission by ID (seller_permissions table).
 *
 * This API performs a soft deletion on a single seller_permission record, as
 * defined in the seller_permissions table in the Prisma schema. The operation
 * sets deleted_at and revokes the assignment, without physically removing the
 * record. All deletions are audited for compliance. Only privileged RBAC admins
 * may use this endpoint.
 *
 * If the record does not exist or is already deleted, a 404 result may be
 * returned (or 204, based on implementation specifics).
 *
 * Revoking a permission in this way supports the requirement for reversible,
 * audit-trailed permission management, and is a core workflow for dynamic RBAC
 * and seller access control.
 *
 * @param props.id Unique identifier of the seller_permission to delete/revoke.
 * @path /sellerPermissions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the seller_permission to delete/revoke. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ISellerPermission;

  export const METADATA = {
    method: "DELETE",
    path: "/sellerPermissions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/sellerPermissions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISellerPermission => typia.random<ISellerPermission>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

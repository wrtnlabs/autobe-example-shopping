import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ISellerVerification } from "../../structures/ISellerVerification";
import { IPageISellerVerification } from "../../structures/IPageISellerVerification";

/**
 * Create (initiate) a new seller_verification row, setting startup status and
 * audit for onboarding; only by RBAC owner/admin.
 *
 * This API operation creates a new seller verification entry for a specified
 * seller, used for onboarding (e.g., KYC, license, tax, banking checks). Input
 * must include valid seller_id, verification type (e.g., KYC), and any optional
 * external references or notes. Upon success, the new verification status is
 * set (typically pending) and can be advanced using dedicated status/advance
 * endpoints elsewhere. Creation is fully validated for linkage and business
 * rules, and audit-trace is recorded. RBAC checks: only the seller or
 * authorized admin/staff can create. Errors returned for invalid or duplicate
 * creation, or forbidden actions.
 *
 * @param props.body Information for new seller verification/step (seller_id,
 *   type, and references)
 * @path /sellerVerifications
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Information for new seller verification/step (seller_id, type, and
     * references)
     */
    body: ISellerVerification.ICreate;
  };
  export type Body = ISellerVerification.ICreate;
  export type Response = ISellerVerification;

  export const METADATA = {
    method: "POST",
    path: "/sellerVerifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/sellerVerifications";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISellerVerification => typia.random<ISellerVerification>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List and search seller_verifications with filters and paging, RBAC enforced
 * (admins/sellers).
 *
 * This endpoint lists seller verification records from seller_verifications,
 * with support for filtering by seller_id, type (e.g. KYC, license), outcome
 * (pending/approved/rejected), request date, etc. Result is paginated and
 * sorted by criteria provided in the request body. RBAC governs which records
 * are includedâ€”sellers see their own, admins or reviewers see all or filtered
 * sets. Only permissible information (excluding PII, internal notes) is
 * returned per access policy. Returns a page object of seller verifications and
 * pagination/meta-info. Intended for management UIs and workflow review, as
 * well as self-service onboarding progress.
 *
 * @param props.body List/search filters for seller_verifications (seller_id,
 *   type, status) plus paging/sort.
 * @path /sellerVerifications
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * List/search filters for seller_verifications (seller_id, type,
     * status) plus paging/sort.
     */
    body: ISellerVerification.IRequest;
  };
  export type Body = ISellerVerification.IRequest;
  export type Response = IPageISellerVerification;

  export const METADATA = {
    method: "PATCH",
    path: "/sellerVerifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/sellerVerifications";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageISellerVerification => typia.random<IPageISellerVerification>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetch one seller_verification by ID, with RBAC and masking (sellers see
 * own/active, admins see all).
 *
 * This endpoint gets details of a seller verification workflow event,
 * identified by id from seller_verifications table. It provides atomic data
 * fields (type, outcome, request/completed times, references), enforcing
 * permission controls: only the seller or authorized admins/reviewers may
 * access. Linked seller, audit, or escalation can be included if matching
 * access rules. Errors for not found/no permission. Intended for workflow-step
 * UIs, onboarding status, or compliance review.
 *
 * @param props.id ID of the seller verification event (primary key)
 * @path /sellerVerifications/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** ID of the seller verification event (primary key) */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ISellerVerification;

  export const METADATA = {
    method: "GET",
    path: "/sellerVerifications/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/sellerVerifications/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISellerVerification => typia.random<ISellerVerification>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update one seller_verification row by ID: outcome, status, evidence,
 * reference (RBAC enforced).
 *
 * This endpoint allows update (full/partial, in-place) of a seller_verification
 * record by id. It processes any allowed attribute (typically outcome,
 * reference_id, completion time), subject to RBAC: admins/reviewers handle
 * status advancement, sellers may only update allowed evidence/reference fields
 * (as per business rule). Changes are rigorously validated for correct
 * transition/state. All update events are audit-logged, and attempts to update
 * forbidden fields or already-completed/verdicted rows are rejected (409/403
 * errors). External workflow trigger is handled separately.
 *
 * @param props.id Seller verification primary key ID for update
 * @param props.body Allowed update fields for seller_verification;
 *   outcome/status/reference only, no foreign updates.
 * @path /sellerVerifications/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Seller verification primary key ID for update */
    id: string & tags.Format<"uuid">;

    /**
     * Allowed update fields for seller_verification;
     * outcome/status/reference only, no foreign updates.
     */
    body: ISellerVerification.IUpdate;
  };
  export type Body = ISellerVerification.IUpdate;
  export type Response = ISellerVerification;

  export const METADATA = {
    method: "PUT",
    path: "/sellerVerifications/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/sellerVerifications/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISellerVerification => typia.random<ISellerVerification>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete/archive a seller_verification by id; RBAC enforcement and audit
 * log recorded.
 *
 * This API operation marks (soft-deletes, not physically removes) one
 * seller_verification row by id in the seller_verifications table. It sets the
 * deleted_at timestamp to record the archive and blocks subsequent access
 * except for compliance/audit view. RBAC and business logic ensure only
 * appropriate actors can execute the deletion. Full audit trail is enforced and
 * all attempts (success/failure) are logged. Related workflow status must be
 * handled separately if needed (e.g., re-initialize verification). Caution: No
 * cascade deletion here; other join/assignment records stay for compliance.
 *
 * @param props.id ID of the seller_verification to archive
 * @path /sellerVerifications/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** ID of the seller_verification to archive */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ISellerVerification.ISoftDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/sellerVerifications/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/sellerVerifications/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ISellerVerification.ISoftDeleteResult =>
    typia.random<ISellerVerification.ISoftDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

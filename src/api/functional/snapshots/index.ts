import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ISnapshot } from "../../structures/ISnapshot";
import { IPageISnapshot } from "../../structures/IPageISnapshot";

/**
 * Create a new entity snapshot (snapshots table).
 *
 * This endpoint is called whenever a major entity is changed (e.g., product
 * updated, order status changed), in order to record an immutable snapshot of
 * the previous or resulting state. Required by audit, rollback, and legal
 * compliance rules.
 *
 * Creation of snapshots should only be accessible to system-internal logic or
 * privileged actors. The request body must specify the entity type, id, change
 * type (create/update/delete), and optionally a reason. All snapshot creation
 * actions must be audit-logged with full timestamp and actor traceability.
 *
 * Related endpoints: PATCH for search/list, GET for retrieval, PUT for updating
 * annotations or correcting metadata.
 *
 * @param props.body Snapshot creation data including entity type, id, change
 *   type, and reason.
 * @path /snapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Snapshot creation data including entity type, id, change type, and
     * reason.
     */
    body: ISnapshot.ICreate;
  };
  export type Body = ISnapshot.ICreate;
  export type Response = ISnapshot;

  export const METADATA = {
    method: "POST",
    path: "/snapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/snapshots";
  export const random = (g?: Partial<typia.IRandomGenerator>): ISnapshot =>
    typia.random<ISnapshot>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Paginated and filtered list of snapshots (snapshots table).
 *
 * This endpoint retrieves a paginated and filtered list of snapshot records
 * representing changes and versions across entities (e.g., product, order,
 * category, etc.). It is key to the system's compliance and audit-trail
 * features, allowing users or administrators to find historical changes by
 * entity type, entity id, date/time, actor, reason, or change type.
 *
 * Access to this endpoint is typically restricted to admin or privileged users,
 * with strong audit logging for access to potentially sensitive history data.
 *
 * Typical related API operations include GET (retrieve specific snapshot by
 * id), POST (create snapshot for a change), and PUT (update a snapshot's
 * metadata, used for corrections/annotations).
 *
 * @param props.body Snapshot filter/search and pagination request body,
 *   including entity type, id, date, etc.
 * @path /snapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Snapshot filter/search and pagination request body, including entity
     * type, id, date, etc.
     */
    body: ISnapshot.IRequest;
  };
  export type Body = ISnapshot.IRequest;
  export type Response = IPageISnapshot;

  export const METADATA = {
    method: "PATCH",
    path: "/snapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/snapshots";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageISnapshot =>
    typia.random<IPageISnapshot>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve specific snapshot details by id (snapshots table).
 *
 * This endpoint allows retrieval of a single snapshot by its unique id. It
 * returns details such as entity type, entity id, change type, timestamp, and
 * reason. It is essential for audit trails, rollback procedures, or explaining
 * the history of a change to administrators or legal personnel.
 *
 * Access is typically restricted to users with audit or admin privileges. If
 * the snapshot is not found, a not-found error is returned.
 *
 * This endpoint pairs with PATCH (list/search earliest), POST (create new
 * snapshot), and PUT (update metadata/correction) for snapshot handling.
 *
 * @param props.id Target snapshot's ID
 * @path /snapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target snapshot's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ISnapshot;

  export const METADATA = {
    method: "GET",
    path: "/snapshots/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/snapshots/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ISnapshot =>
    typia.random<ISnapshot>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a snapshot's annotation or metadata by id (snapshots table).
 *
 * This endpoint permits updates to the reason or metadata of an existing
 * snapshot, as allowed by business or compliance rules (in general, snapshot
 * data is immutable except annotation fields). Only privileged/admin users may
 * perform this operation; all changes must be audit-logged.
 *
 * Attempting to change immutable or restricted fields results in an error. Use
 * cases include correction of mistake in the reason, or post-hoc annotation for
 * later explanation.
 *
 * Pair with PATCH (list) for search, GET (retrieve), and POST (create new
 * snapshot).
 *
 * @param props.id Target snapshot's ID
 * @param props.body Editable snapshot metadata (typically the change_reason or
 *   similar).
 * @path /snapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target snapshot's ID */
    id: string & tags.Format<"uuid">;

    /** Editable snapshot metadata (typically the change_reason or similar). */
    body: ISnapshot.IUpdate;
  };
  export type Body = ISnapshot.IUpdate;
  export type Response = ISnapshot;

  export const METADATA = {
    method: "PUT",
    path: "/snapshots/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/snapshots/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ISnapshot =>
    typia.random<ISnapshot>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft delete a snapshot (snapshots table, audit/compliance entity).
 *
 * This API operation deletes a specific snapshot entry by marking its
 * deleted_at column (soft deletion), thereby preserving audit history required
 * by business and compliance. Snapshot records document the
 * immutable/point-in-time versions of various entities from core tables (e.g.,
 * products, categories, boards). Deletion operations are restricted to users
 * with escalated permissions (admin, compliance officers), ensuring that only
 * those authorized for legal control can execute the endpoint. The path
 * parameter id is the UUID of the target snapshot. Business logic may include
 * verification that all references to the snapshot are either not in use or
 * appropriately redirected. After running this operation, audit logs must be
 * generated, and rollback can only be performed by a separate restore flow.
 * Error handling should address lost references or attempts to delete an
 * already-in-use or non-existent snapshot. Related APIs: GET /snapshots/{id}
 * for retrieval, PATCH /snapshots for listing/search, POST /snapshots for
 * creation.
 *
 * @param props.id Target snapshot's ID (UUID).
 * @path /snapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target snapshot's ID (UUID). */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/snapshots/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/snapshots/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

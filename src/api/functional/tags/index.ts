import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITags } from "../../structures/ITags";
import { IPageITags } from "../../structures/IPageITags";

/**
 * Create a new tag record (tags).
 *
 * Creates a new tag entry for products in the tagging system. Tag details
 * including code, name, and associated channel are required in the request
 * body, satisfying requirements for 3NF-normalized, plural tags.
 *
 * Request validation ensures uniqueness (per-channel-code), required fields,
 * and compliance with system quotas. Only users with sufficient permissions
 * (such as admins, product managers, or channel owners) may create new tags.
 * Soft-deletion, audit log, and i18n fields are handled per the schema, with
 * creation and updated timestamps automatically managed. If creation fails due
 * to validation or database error, an appropriate code and summary message are
 * returned.
 *
 * @param props.body New tag details for product categorization.
 * @path /tags
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** New tag details for product categorization. */
    body: ITags.ICreate;
  };
  export type Body = ITags.ICreate;
  export type Response = ITags;

  export const METADATA = {
    method: "POST",
    path: "/tags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/tags";
  export const random = (g?: Partial<typia.IRandomGenerator>): ITags =>
    typia.random<ITags>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search tags with filtering and pagination (tags).
 *
 * Retrieves a list of product tag records using flexible filtering and
 * pagination as documented in the 'tags' table. The endpoint supports searching
 * by tag code, name, channel, or timestamps. Both internal (admin) and
 * public-facing scenarios are supported, but access control may restrict
 * certain tags visibility to authorized roles.
 *
 * Request parameters allow specifying pagination (page, pageSize), full-text
 * search on tag code or name, ordering, and filtering by channel, active
 * status, or creation/update timelines. Results include total counts and data
 * arrays, following structured pagination. Business logic enforces soft-deleted
 * (deleted_at) tags are excluded from general results.
 *
 * Related endpoints for create, update, and delete are also available. Error
 * responses are returned for invalid queries, insufficient permissions, or
 * server errors. The operation helps power product categorization, search, and
 * dynamic merchandising for end-users and admins.
 *
 * @param props.body Search/filtering options for tag list operation.
 * @path /tags
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filtering options for tag list operation. */
    body: ITags.IRequest;
  };
  export type Body = ITags.IRequest;
  export type Response = IPageITags;

  export const METADATA = {
    method: "PATCH",
    path: "/tags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/tags";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageITags =>
    typia.random<IPageITags>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a tag by ID (tags).
 *
 * Retrieves all details of a specific tag, identified by its unique ID. The
 * returned data includes atomic fields such as tag code, name, channel
 * association, creation and updated timestamps, and any soft-deletion marker.
 * Access is subject to RBAC controls; only permitted users (admin and relevant
 * channel managers) can read details of all tags, while public APIs may limit
 * information to active/public tags only.
 *
 * This endpoint directly maps to the 'tags' table: it raises a not found error
 * if the tag does not exist or its deleted_at field is set. Soft-deleted tags
 * are not returned unless specifically allowed. Associated entities (such as
 * linked products/categories) may be retrieved via separate endpoints. The
 * operation guarantees all lookup actions are audit-logged for compliance and
 * analytics.
 *
 * @param props.id Target tag's ID
 * @path /tags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target tag's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ITags;

  export const METADATA = {
    method: "GET",
    path: "/tags/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/tags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ITags =>
    typia.random<ITags>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a tag by ID (tags).
 *
 * Updates an existing tag in the system, identified by its unique ID. Allows
 * changes to channel association, code, name, and related fields as described
 * in the 'tags' schema. Update operations are subject to audit logging for
 * accountability and regulatory compliance.
 *
 * Only authorized users (admin, product manager) can update tag data.
 * Uniqueness of tag code per channel is enforced; updates failing this
 * constraint are rejected with a suitable error. The operation updates the
 * relevant updated_at timestamp and respects soft deletion markersâ€”soft deleted
 * tags cannot be updated. Related endpoints allow tag creation, deletion, and
 * search; changes here are reflected in advanced product search indexes as
 * required.
 *
 * @param props.id Target tag's ID
 * @param props.body Updated tag details.
 * @path /tags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target tag's ID */
    id: string & tags.Format<"uuid">;

    /** Updated tag details. */
    body: ITags.IUpdate;
  };
  export type Body = ITags.IUpdate;
  export type Response = ITags;

  export const METADATA = {
    method: "PUT",
    path: "/tags/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/tags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ITags =>
    typia.random<ITags>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a tag by ID (tags).
 *
 * Logically deletes (soft-deletes) a tag by its unique ID, updating the
 * 'deleted_at' field in the tags table. Only authorized users (such as admins
 * or product managers) may perform this action, per RBAC. Soft-deleted tags are
 * omitted from list/search results and cannot be updated or used in future
 * product/tag assignments until restored.
 *
 * The operation returns the soft-deleted tag object. Attempts to delete a
 * non-existent or already soft-deleted record are met with suitable errors.
 * Related endpoints allow tag creation, update, and search. All delete actions
 * are audit-logged, and regulatory requirements for retention and auditability
 * are followed.
 *
 * @param props.id Target tag's ID
 * @path /tags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target tag's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ITags;

  export const METADATA = {
    method: "DELETE",
    path: "/tags/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/tags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ITags =>
    typia.random<ITags>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

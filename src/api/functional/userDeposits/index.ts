import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IUserDeposit } from "../../structures/IUserDeposit";
import { IPageIUserDeposit } from "../../structures/IPageIUserDeposit";

/**
 * Create a new user deposit record (user_deposits table, PromotionsBalances
 * domain).
 *
 * This operation creates a new user deposit event. A deposit event represents a
 * one-time addition or reversal of funds to a user's deposit balance, and is
 * modeled in the user_deposits schema (see Prisma for atomic event
 * representation). The body must specify user_id, amount, deposit_type (e.g.,
 * 'load', 'reversal', or 'adjustment'), status, and currency. Business logic:
 * Amount must be positive for 'load' and negative for 'reversal'. The deposit
 * event must be associated with a valid, active user only.
 *
 * On execution, an audit log is inserted referencing the event for compliance
 * tracking. Soft deletes and state transitions do not apply (those handled by
 * timestamp and audit). Refund, admin credit and regulatory reversal must each
 * be distinguishable via type field. Balance updates and downstream event
 * triggers (notification, refunds system) are handled asynchronously. Duplicate
 * detection/duplicate transaction logic should be applied to prevent accidental
 * repeat entries.
 *
 * If the referenced user is deleted or suspended, deposits are rejected as per
 * regulatory logic. On success, the response returns the full deposit row,
 * including timestamps and all audit fields. Error cases: 400 for validation
 * error (amount/type/currency), 404 if user does not exist, 403 if state does
 * not allow deposit event.
 *
 * @param props.body Deposit creation payload, see IUsersDeposit.ICreate.
 * @path /userDeposits
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Deposit creation payload, see IUsersDeposit.ICreate. */
    body: IUserDeposit.ICreate;
  };
  export type Body = IUserDeposit.ICreate;
  export type Response = IUserDeposit;

  export const METADATA = {
    method: "POST",
    path: "/userDeposits",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/userDeposits";
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserDeposit =>
    typia.random<IUserDeposit>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Returns a paginated, filtered list of user deposits from 'user_deposits'.
 *
 * Lists user deposit records in paginated, filtered response for analytics,
 * compliance audits, or self-service dashboards. Allowed filters include: user
 * id, deposit type (load, reversal, adjustment), currency, range queries
 * (amount, date), and status. Pagination meta and audit logging are returned.
 * Access is RBAC-controlled: only the balance owner, or privileged
 * admins/auditors, may list deposit history. Batch or bulk audit exports may be
 * routed to separate analytic endpoints for large export needs. Related
 * endpoints: user balance list, audit logs, and single deposit GET. Errors:
 * forbidden, not found, overbroad query (rate-limited for safety), and data
 * masking for GDPR/CCPA. Log entries record query intent, actor, and response
 * shape.
 *
 * @param props.body User deposit filtering, search, and pagination details.
 * @path /userDeposits
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** User deposit filtering, search, and pagination details. */
    body: IUserDeposit.IRequest;
  };
  export type Body = IUserDeposit.IRequest;
  export type Response = IPageIUserDeposit;

  export const METADATA = {
    method: "PATCH",
    path: "/userDeposits",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/userDeposits";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIUserDeposit => typia.random<IPageIUserDeposit>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a user deposit by ID from 'user_deposits'.
 *
 * Fetches an individual user deposit record by unique identifier, with all
 * details (user, deposit type, amount, currency, status, timestamps). Strict
 * RBAC checks limit access to authorized viewers; read attempts are logged for
 * GDPR, CCPA, and financial audits. Data masking/redaction is applied according
 * to access level. Designed for use in admin dashboards, user portal, and
 * compliance report flows. All API access is monitored/audited. Related
 * endpoints: update, delete, audit log. Typical errors: not found, forbidden,
 * data-masked record return in compliance contexts.
 *
 * @param props.id User deposit record unique identifier.
 * @path /userDeposits/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** User deposit record unique identifier. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUserDeposit;

  export const METADATA = {
    method: "GET",
    path: "/userDeposits/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/userDeposits/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserDeposit =>
    typia.random<IUserDeposit>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing user deposit record (user_deposits table).
 *
 * This operation updates a single user_deposit row. Relevant only for amending
 * pending or in-process deposit events, or attaching reconciliation data for
 * completed ones (for example, adding audit notes or toggling the status from
 * 'pending' to 'completed').
 *
 * User_deposit events are immutable once marked as completed; only 'pending' or
 * 'failed' can be edited directly. All updates are recorded in the
 * balance_audit_logs for full compliance, and update timestamps are strictly
 * updated. This operation is available to admin or system roles with suitable
 * RBAC permissions. Attempts to modify user_id, hard delete or non-mutable
 * fields will return 403.
 *
 * Validation includes checking requester's permission, ensuring correct status
 * transitions, and business logic for deposit_type. Expected errors: 400 (bad
 * request), 403 (forbidden operation), 404 (not found). Returns the updated
 * user_deposit entity.
 *
 * @param props.id Target user_deposits row's ID.
 * @param props.body Payload for updating a user deposit event, see
 *   IUserDeposit.IUpdate.
 * @path /userDeposits/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target user_deposits row's ID. */
    id: string & tags.Format<"uuid">;

    /** Payload for updating a user deposit event, see IUserDeposit.IUpdate. */
    body: IUserDeposit.IUpdate;
  };
  export type Body = IUserDeposit.IUpdate;
  export type Response = IUserDeposit;

  export const METADATA = {
    method: "PUT",
    path: "/userDeposits/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/userDeposits/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserDeposit =>
    typia.random<IUserDeposit>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft delete (logical remove) a user_deposit event for compliance
 * (user_deposits table).
 *
 * This operation manages soft deletion (logical deletion) of user deposit
 * events. It is used to mark a deposit event (such as an erroneous manual
 * credit or fraudulently created entry) as deleted, compliant with the
 * requirement for immutable deletion history. The target record is not removed,
 * but gets a deleted_at timestamp, preserving all other fields for
 * auditability.
 *
 * Permissions: Only admins with compliance or finance roles can perform this
 * action. The operation checks that the entry exists, is not already deleted or
 * marked permanent/completed, and generates a corresponding entry in the
 * balance_audit_logs schema for legal trace. No modification of user_id or
 * other fields is allowed. Response contains the now-soft-deleted deposit row,
 * including deletion timestamp.
 *
 * Error cases: 404 (entry not found), 403 (not permitted—wrong state or
 * permission).
 *
 * @param props.id Target user_deposits row's ID.
 * @path /userDeposits/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target user_deposits row's ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUserDeposit;

  export const METADATA = {
    method: "DELETE",
    path: "/userDeposits/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/userDeposits/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserDeposit =>
    typia.random<IUserDeposit>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

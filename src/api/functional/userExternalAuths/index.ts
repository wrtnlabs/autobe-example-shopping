import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IUserExternalAuth } from "../../structures/IUserExternalAuth";
import { IPageIUserExternalAuth } from "../../structures/IPageIUserExternalAuth";
import { IResult } from "../../structures/IResult";

/**
 * Create a new userExternalAuth mapping (external provider link) using data
 * from 'user_external_auths' table.
 *
 * Allows the creation of a userExternalAuth record, associating a user with an
 * external authentication provider. The operation takes a request body matching
 * the 'IUserExternalAuth.ICreate' schema, validating that the provider and
 * external_user_id are not already linked to another account. Successfully
 * creating the mapping enables SSO, OAuth, or federated login for the user
 * according to the business flow. Security checks ensure only privileged flows
 * can invoke this operation (e.g., user self-linking with proper verification,
 * admin linking, or system-provisioned integrations). The operation is part of
 * the lifecycle covering onboarding, account linking, and external access
 * provisioning, as referenced in 'User Architecture' and Prisma schema
 * comments. Errors are returned for duplicate mapping attempts or validation
 * failures.
 *
 * @param props.body Details for the userExternalAuth to be created (user_id,
 *   provider, external_user_id, etc.).
 * @path /userExternalAuths
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Details for the userExternalAuth to be created (user_id, provider,
     * external_user_id, etc.).
     */
    body: IUserExternalAuth.ICreate;
  };
  export type Body = IUserExternalAuth.ICreate;
  export type Response = IUserExternalAuth;

  export const METADATA = {
    method: "POST",
    path: "/userExternalAuths",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/userExternalAuths";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IUserExternalAuth => typia.random<IUserExternalAuth>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a paginated/searchable list of userExternalAuths (external login
 * mappings) from 'user_external_auths' table.
 *
 * This operation enables authorized staff (e.g., admins) to retrieve a
 * filtered, paginated list of external authentication mappings
 * (userExternalAuths) in the system. These records track how internal user
 * accounts are associated with external identities for SSO, OAuth, and
 * integrated platforms, as specified in the 'user_external_auths' table. Each
 * mapping captures the system user, provider code, and external provider user
 * ID, supporting unified authentication management and regulatory auditability.
 * Security is enforced via RBAC—access is limited to roles with user-access
 * management privileges. Many real-world flows require paging, sorting, and
 * full-text search (by provider, external_user_id, or date ranges), all
 * supported by this operation following Prisma schema comments. Pagination is
 * especially necessary for large systems with thousands of external mappings.
 * Errors (e.g., invalid filters, denied access) are surfaced with clear error
 * messages per system API standard. Typically used alongside
 * GET/POST/PUT/DELETE for userExternalAuths management.
 *
 * @param props.body Filter/search criteria and pagination options for
 *   userExternalAuths list retrieval.
 * @path /userExternalAuths
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filter/search criteria and pagination options for userExternalAuths
     * list retrieval.
     */
    body: IUserExternalAuth.IRequest;
  };
  export type Body = IUserExternalAuth.IRequest;
  export type Response = IPageIUserExternalAuth;

  export const METADATA = {
    method: "PATCH",
    path: "/userExternalAuths",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/userExternalAuths";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIUserExternalAuth => typia.random<IPageIUserExternalAuth>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get details for a specific userExternalAuth (external-auth mapping) using its
 * id (from 'user_external_auths' table).
 *
 * This operation returns the full detail of a single userExternalAuth mapping,
 * as defined in the 'user_external_auths' table. The endpoint is typically used
 * to fetch the complete association between a system user and an external
 * provider (such as Google, Apple, or a platform SSO). Per schema design, each
 * record uniquely describes the mapping between user_id and
 * provider/external_user_id, along with the linkage date. Security: access is
 * enforced by RBAC rules—either the mapped user themselves or an admin with
 * sufficient privileges may access. The operation is often paired with POST
 * (create), PUT (update), and DELETE (remove) userExternalAuths operations for
 * full lifecycle management. If the id provided does not correspond to any
 * existing mapping, a 404-not-found error is returned per system error handling
 * policy.
 *
 * @param props.id Unique identifier of the userExternalAuth mapping record to
 *   retrieve.
 * @path /userExternalAuths/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier of the userExternalAuth mapping record to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUserExternalAuth;

  export const METADATA = {
    method: "GET",
    path: "/userExternalAuths/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/userExternalAuths/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IUserExternalAuth => typia.random<IUserExternalAuth>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a userExternalAuth mapping (external provider link) by id
 * ('user_external_auths' table).
 *
 * This endpoint allows an authorized client (user or admin) to update the
 * details of an external authentication mapping. Typical updates include
 * changing the provider's linked external_user_id (e.g., user account migration
 * at provider), correcting provider metadata, or maintenance operations
 * triggered by external OAuth/SSO workflow events. According to Prisma schema
 * comments, only columns directly in user_external_auths can be updated (i.e.,
 * user_id, provider, external_user_id, etc.); system ensures updated values
 * preserve uniqueness and data integrity. All operations are audited under
 * compliance policies. The operation is paired with GET/POST/DELETE for full
 * resource lifecycle management. Errors are mapped to standard system response
 * codes (404 for not-found, 409 for uniqueness failures, 403 for unauthorized
 * attempts, etc.).
 *
 * @param props.id Unique identifier of the userExternalAuth mapping to update.
 * @param props.body Fields to update in the userExternalAuth mapping.
 * @path /userExternalAuths/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier of the userExternalAuth mapping to update. */
    id: string & tags.Format<"uuid">;

    /** Fields to update in the userExternalAuth mapping. */
    body: IUserExternalAuth.IUpdate;
  };
  export type Body = IUserExternalAuth.IUpdate;
  export type Response = IUserExternalAuth;

  export const METADATA = {
    method: "PUT",
    path: "/userExternalAuths/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/userExternalAuths/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IUserExternalAuth => typia.random<IUserExternalAuth>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a userExternalAuth mapping (unlink external provider) by id (from
 * 'user_external_auths' table).
 *
 * Removes a userExternalAuth record, breaking the link between a system user
 * account and their associated external authentication from a third-party
 * provider. Per Prisma schema and business requirements, deletion may be hard
 * or soft depending on audit/compliance policies (prefer soft for regulatory
 * clarity). Only authorized actors (user or admin with permission) may perform
 * this operation. All deletions are audit-logged for regulatory and
 * troubleshooting purposes. Errors handled using standard system error codes
 * (403/404, etc.). The operation is often paired with GET/PUT/POST lifecycle
 * operations for full management of external logins.
 *
 * @param props.id Unique ID for the userExternalAuth mapping to delete.
 * @path /userExternalAuths/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique ID for the userExternalAuth mapping to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IResult;

  export const METADATA = {
    method: "DELETE",
    path: "/userExternalAuths/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/userExternalAuths/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IResult =>
    typia.random<IResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

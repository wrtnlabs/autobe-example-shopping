import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IUserMileage } from "../../structures/IUserMileage";
import { IPageIUserMileage } from "../../structures/IPageIUserMileage";

/**
 * Create a new user mileage event (user_mileages table, PromotionsBalances
 * domain).
 *
 * This operation creates a new user mileage event. Mileage events reflect
 * points earned (on purchase, engagement, campaign, etc), redeemed, or expired
 * for a user. See user_mileages Prisma schema for 3NF atomic event handling.
 * Request body fields: user_id, amount, mileage_type ('earn', 'redeem',
 * 'bonus', 'expire'), status (pending, completed, expired), optional
 * description for detail/context. Amount sign and field validation rules apply:
 * 'earn'/'bonus' require positive amount, 'redeem'/'expire' negative. Business
 * process checks prevent duplicate or erroneous events; user must exist and
 * permissions are required.
 *
 * On success, balance is updated and an audit event is created (see
 * balance_audit_logs). No direct updates—if an adjustment is needed, a
 * compensating entry must be created instead. Returns the new row, with all
 * audit fields. On failure: 400 (validation error), 403 (not permitted), 404
 * (user not found).
 *
 * @param props.body Payload of mileage event to create; see
 *   IUserMileage.ICreate.
 * @path /userMileages
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Payload of mileage event to create; see IUserMileage.ICreate. */
    body: IUserMileage.ICreate;
  };
  export type Body = IUserMileage.ICreate;
  export type Response = IUserMileage;

  export const METADATA = {
    method: "POST",
    path: "/userMileages",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/userMileages";
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserMileage =>
    typia.random<IUserMileage>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search user mileage event records (user_mileages table, paginated &
 * filterable).
 *
 * This operation supports paginated, filtered listing/search of user mileage
 * event records. User mileage events are discrete
 * earn/redeem/redemption/expiration transactions (see user_mileages Prisma
 * schema for field list). The request body supports filtering (user_id,
 * mileage_type, status), free-text search (description), date ranges
 * (created_at), and ordering. Returns a paginated list of user_mileage rows
 * (audit trailing), along with pagination metadata (total count, current
 * page).
 *
 * This endpoint enables admins or users (with suitable RBAC permissions) to
 * view their or their customers' mileage histories for analytics and
 * compliance. Does not update or create any mileage records. Expected error
 * cases: 400 (invalid filter/sort), 401/403 for permission errors, 500 for
 * server error. Response follows the generic paginated result format
 * (IPageIUserMileage).
 *
 * @param props.body Paging, filter, and sort info; see IUserMileage.IRequest.
 * @path /userMileages
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Paging, filter, and sort info; see IUserMileage.IRequest. */
    body: IUserMileage.IRequest;
  };
  export type Body = IUserMileage.IRequest;
  export type Response = IPageIUserMileage;

  export const METADATA = {
    method: "PATCH",
    path: "/userMileages",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/userMileages";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIUserMileage => typia.random<IPageIUserMileage>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a single user mileage event (user_mileages table, by ID).
 *
 * This operation retrieves a specific user_mileage event by its ID, returning
 * detailed information per the user_mileages schema. User mileage records are
 * immutable events, and each has metadata for type, amount, status, and other
 * required fields. Used for detailed event inspection (by user, admin, or
 * compliance reviewers).
 *
 * Operation checks that the row exists, not already soft-deleted, and returns
 * all non-sensitive fields (always links to user via FK, never returns full
 * profile inline unless permitted by policy). Error cases: 404 (not found), 403
 * (access forbidden—incorrect permission), 410 (gone—if deleted). Response is
 * the full user_mileage event row. RBAC applies to restrict lookup by
 * role/ownership.
 *
 * @param props.id Target user_mileages row's ID.
 * @path /userMileages/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target user_mileages row's ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUserMileage;

  export const METADATA = {
    method: "GET",
    path: "/userMileages/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/userMileages/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserMileage =>
    typia.random<IUserMileage>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a user mileage event (user_mileages table, Metadata fields only, if
 * open).
 *
 * Performs update on a user_mileage record for administrative or system amends
 * to open events (usually only status, description, audit notes). Mileage
 * events cannot be rewritten for amount or type (immutable after
 * completion/expiry for audit compliance). Allowed transitions: status
 * 'pending'→'completed' or 'pending'→'expired', and description updates. Audit
 * log records the update, triggers appropriate notifications if configured.
 *
 * Rejects: requests for updating completed/expired/deleted events, or changes
 * to immutable fields (amount, user_id, mileage_type), returning 403 or 400.
 * Returns full row on success, including all audit and business fields. Used by
 * admin, system, or authorized user for reconciliation/reporting workflow.
 *
 * @param props.id Target user_mileages row's ID.
 * @param props.body Update payload for user mileage event; see
 *   IUserMileage.IUpdate.
 * @path /userMileages/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target user_mileages row's ID. */
    id: string & tags.Format<"uuid">;

    /** Update payload for user mileage event; see IUserMileage.IUpdate. */
    body: IUserMileage.IUpdate;
  };
  export type Body = IUserMileage.IUpdate;
  export type Response = IUserMileage;

  export const METADATA = {
    method: "PUT",
    path: "/userMileages/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/userMileages/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserMileage =>
    typia.random<IUserMileage>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft delete a user mileage event (user_mileages table, compliance log).
 *
 * This operation marks a user_mileage row as deleted via the deleted_at
 * timestamp (Prisma soft-delete support). Used for manually removing mistaken,
 * fraudulent, or otherwise rescinded mileage entries while preserving immutable
 * auditability. Does not allow direct deletion or hard removal for
 * legal/compliance. Only uncompleted/pending items can be deleted; completed or
 * expired ones are immutable. Records a corresponding balance_audit_logs entry
 * to support export/disclosure. RBAC applies for admin or permitted roles
 * only.
 *
 * On success: returns the soft-deleted record, with deleted_at populated. Fails
 * with 403 if role/status do not permit, or 404 if row does not exist/was
 * already deleted. Used for compliance, fraud/QA, or system clean-up
 * operations.
 *
 * @param props.id Target user_mileages row's ID.
 * @path /userMileages/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target user_mileages row's ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUserMileage;

  export const METADATA = {
    method: "DELETE",
    path: "/userMileages/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/userMileages/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserMileage =>
    typia.random<IUserMileage>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IUser } from "../../structures/IUser";
import { IPageUser } from "../../structures/IPageUser";

/**
 * Register new user account (users table, system-wide identity).
 *
 * Creates a user record (account identity) by accepting identity attributes in
 * request body: must include unique email and username, with password or
 * equivalent (unless SSO/external create logic is run). This endpoint handles
 * RBAC hooks for follow-up role assignment and onboarding workflow (e.g.,
 * seller/admin invitation, customer self-registration). On success, returns the
 * registered user record with ID. External logins, consents, and onboarding
 * triggers are typically invoked downstream and are out of this operation's
 * scope. All account creation is logged for compliance. Errors include
 * duplicate identity (username/email already exists), missing/invalid data, or
 * invalid RBAC context. This endpoint is related to PATCH /users (search), GET
 * /users/{id} (get one), PUT /users/{id} (update), and DELETE /users/{id}
 * (delete).
 *
 * @param props.body All required fields for user account creation (email,
 *   username, password/SSO).
 * @path /users
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * All required fields for user account creation (email, username,
     * password/SSO).
     */
    body: IUser.ICreate;
  };
  export type Body = IUser.ICreate;
  export type Response = IUser;

  export const METADATA = {
    method: "POST",
    path: "/users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/users";
  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>
    typia.random<IUser>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search users (users table, authentication/account base).
 *
 * This operation lists user account records from the users table, supporting
 * search, filter, and pagination in the request body. Can be scoped by fields
 * such as email, username, status (active/deleted), creation date, etc. Only
 * accessible to administrator roles; non-admins are denied. Implements
 * compliance/audit by supporting legal export and investigation. The endpoint
 * enforces RBAC and privacy logic. The response is a page of user objects,
 * optionally with redacted or masked fields (PII), depending on RBAC context.
 * Related endpoints include GET /users/{id} (retrieve one), POST /users (create
 * new), PUT /users/{id} (update), DELETE /users/{id} (soft delete).
 *
 * @param props.body Filtering/search/pagination criteria for user account
 *   search operation.
 * @path /users
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filtering/search/pagination criteria for user account search
     * operation.
     */
    body: IUser.IRequest;
  };
  export type Body = IUser.IRequest;
  export type Response = IPageUser;

  export const METADATA = {
    method: "PATCH",
    path: "/users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/users";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageUser =>
    typia.random<IPageUser>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get details for a single user account (users table, authentication entity).
 *
 * Returns the full account base record for the user specified by id (UUID).
 * Only admin or compliance-permitted roles may call this endpoint. Implements
 * privacy and access rules: PII or sensitive fields may be masked based on
 * context/RBAC. Standard errors: not found, unauthorized, or invalid ID. The
 * endpoint loads from the users table. Use with PATCH /users for
 * search/pagination, POST /users for creation, PUT /users/{id} for update,
 * DELETE /users/{id} for deletion. Audit logs are required for compliance when
 * this endpoint is used. This operation is a security-sensitive context and
 * must be thoroughly access-checked.
 *
 * @param props.id User account ID (UUID).
 * @path /users/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** User account ID (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUser;

  export const METADATA = {
    method: "GET",
    path: "/users/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/users/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>
    typia.random<IUser>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update user account data (users table, authentication entity).
 *
 * Updates the specified user account by ID (UUID) with the data in the request
 * body. Allows for changes to email, username, password (hash), or state
 * (active/soft-deleted). Triggers audit log and compliance hooks for each
 * change. Only system administrators or RBAC-privileged actors may call this
 * endpoint; unauthorized access is denied. The endpoint matches the ID path
 * param to the appropriate users table record and performs the update, checking
 * for field-level or RBAC-triggered restrictions (e.g., changing PII may
 * require escalation/confirmation). Errors are logged, and non-existent or
 * forbidden operations are returned as standard status messages. This operation
 * relates to PATCH /users (list), GET /users/{id} (get one), POST /users
 * (create), and DELETE /users/{id} (soft delete).
 *
 * @param props.id User account ID (UUID).
 * @param props.body Fields to update for the target user account.
 * @path /users/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** User account ID (UUID). */
    id: string & tags.Format<"uuid">;

    /** Fields to update for the target user account. */
    body: IUser.IUpdate;
  };
  export type Body = IUser.IUpdate;
  export type Response = IUser;

  export const METADATA = {
    method: "PUT",
    path: "/users/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/users/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>
    typia.random<IUser>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft delete a user account (users table, compliance/regulation).
 *
 * Soft deletes (deactivates, but does not destroy) a user account by setting
 * deleted_at in users table. Only available to admin/compliance, or per
 * self-service flows if permitted. All deletion actions are audited, and all
 * related RBAC/permission hooks must be triggered. The referenced ID is checked
 * for correct UUID, and not found/non-matching records are rejected. Downstream
 * impacts (access removal, session deactivation) are typically part of
 * post-action logic. Use with PATCH /users for list, GET /users/{id}, POST
 * /users (create), PUT /users/{id} (update). Context: account deactivation must
 * fulfill all audit, regulation, and privacy (right-to-erasure) requirements
 * depending on business logic.
 *
 * @param props.id User account ID (UUID).
 * @path /users/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** User account ID (UUID). */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/users/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/users/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

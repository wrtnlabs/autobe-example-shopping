import { tags } from "typia";

/**
 * Represents a single payment event tied to an order. All fields correspond
 * directly to atomic database fields and track per-event audit detail.
 *
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export type IAimallBackendPayment = {
  /** Primary key for the payment event (UUID). */
  id: string & tags.Format<"uuid">;

  /** The unique identifier of the order this payment event is associated with. */
  order_id: string & tags.Format<"uuid">;

  /**
   * Type of payment channel used for this payment (e.g., credit_card,
   * deposit, coupon, loyalty_points, virtual_account).
   */
  payment_method: string;

  /** Amount paid in this event, matches the currency field. */
  amount: number &
    tags.JsonSchemaPlugin<{
      format: "double";
    }>;

  /** Currency code (ISO 4217, e.g., KRW, USD). */
  currency: string;

  /**
   * External payment provider's confirmation or transaction string, nullable
   * for balance/coupon payments.
   */
  transaction_id?: string | null;

  /** Timestamp when the payment was processed and completed. */
  paid_at: string & tags.Format<"date-time">;
};
export namespace IAimallBackendPayment {
  /**
   * Advanced query, filter, and pagination DTO for searching payment records.
   * All filter parameters are optional except order_id, which is required.
   */
  export type IRequest = {
    /** Filter payments by parent order UUID. */
    order_id: string & tags.Format<"uuid">;

    /**
     * Filter by payment method type (e.g., credit_card, deposit, coupon,
     * points).
     */
    payment_method?: string;

    /** Filter payments by currency code (ISO). */
    currency?: string;

    /** Lower bound for payment amount (inclusive). */
    amount_min?: number &
      tags.JsonSchemaPlugin<{
        format: "double";
      }>;

    /** Upper bound for payment amount (inclusive). */
    amount_max?: number &
      tags.JsonSchemaPlugin<{
        format: "double";
      }>;

    /** Lower bound (inclusive) for payment timestamp. */
    paid_from?: string & tags.Format<"date-time">;

    /** Upper bound (inclusive) for payment timestamp. */
    paid_to?: string & tags.Format<"date-time">;

    /** Filter payments by transaction reference code. */
    transaction_id?: string;

    /** The page number for pagination (1-based). */
    page?: (number & tags.Type<"int32">) | null;

    /** Max number of records per page. */
    limit?: (number & tags.Type<"int32">) | null;
  };

  /**
   * DTO for creating a new payment event under an order. The client supplies
   * all necessary payment details. The server may inject the current
   * timestamp if paid_at is not supplied.
   */
  export type ICreate = {
    /**
     * Type of payment to be recorded ('credit_card', 'deposit', 'coupon',
     * 'loyalty_points', etc.).
     */
    payment_method: string;

    /** Transaction amount to be logged for this payment. */
    amount: number &
      tags.JsonSchemaPlugin<{
        format: "double";
      }>;

    /** Currency code for this payment event. */
    currency: string;

    /** External transaction reference or null for non-processor events. */
    transaction_id?: string | null;

    /**
     * Time the payment occurred (ISO 8601). If omitted or null, server will
     * use current timestamp.
     */
    paid_at?: string & tags.Format<"date-time">;
  };

  /**
   * DTO for updating certain mutable fields of a payment record. Only
   * updatable fields are included, omitting amount and currency for
   * audit/control.
   */
  export type IUpdate = {
    /**
     * If changing the payment channel/type is permitted, update this field.
     * Otherwise, omit or provide null.
     */
    payment_method?: string | null;

    /** May supply or correct the external payment reference here. */
    transaction_id?: string | null;

    /** Update the payment completion or confirmation time if allowed. */
    paid_at?: (string & tags.Format<"date-time">) | null;
  };
}

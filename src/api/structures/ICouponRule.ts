import { tags } from "typia";

/**
 * Atomic representation of a coupon rule from the coupon_rules table. 1:1
 * mapping of DB columns, including eligibility, category/channel restrictions,
 * activation windows, and audit fields.
 *
 * Required for auditability, analytics, and business rule enforcement. Full
 * field/constraint info comes from Prisma schema annotations.
 *
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export type ICouponRule = {
  /** Primary key, UUID. coupon_rules.id */
  id: string & tags.Format<"uuid">;

  /** Reference to Coupon (Prisma: coupon_rules.coupon_id). */
  coupon_id: string & tags.Format<"uuid">;

  /** Minimum order value for eligibility. Optional (Prisma: min_order_amount). */
  min_order_amount?:
    | (number &
        tags.JsonSchemaPlugin<{
          format: "double";
        }>)
    | null;

  /** Maximum order value for which rule applies (nullable, optional). */
  max_order_amount?:
    | (number &
        tags.JsonSchemaPlugin<{
          format: "double";
        }>)
    | null;

  /** Eligible user type: registered/guest/VIP. Prisma: eligible_user_type */
  eligible_user_type?: string;

  /** Channel restrictions as JSON/CSV string (per rule). */
  eligible_channels?: string;

  /** Excluded categories (JSON/CSV), for rule exclusion logic. */
  excluded_categories?: string;

  /** Activation start window for this rule. */
  start_at: string & tags.Format<"date-time">;

  /** End of rule eligibility. If omitted, rule is open-ended. */
  end_at?: (string & tags.Format<"date-time">) | null;

  /** Extensible business rule configuration (serialized JSON). */
  config_json?: string;

  /** Timestamp for audit/compliance. */
  created_at: string & tags.Format<"date-time">;
};
export namespace ICouponRule {
  /**
   * Request body for searching/filtering coupon rules. Implements all fields
   * from the coupon_rules Prisma entity, and supports full
   * admin/campaign/compliance search requirements.
   *
   * Filter by coupon, user eligibility, activation window, sorting, and
   * paging. Full compliance with admin needs for analytics, export, and
   * entitlement review.
   */
  export type IRequest = {
    /** If specified, only return rules for this coupon. */
    coupon_id?: string & tags.Format<"uuid">;

    /**
     * Filter by user type eligibility, such as 'registered', 'guest',
     * 'VIP'.
     */
    eligible_user_type?: string;

    /**
     * Return rules with activation window starting after this ISO8601
     * timestamp.
     */
    date_from?: string & tags.Format<"date-time">;

    /** Return rules with activation ending before this timestamp. */
    date_to?: string & tags.Format<"date-time">;

    /** Field to sort by (start_at, end_at, rule id, etc.). */
    sortBy?: string;

    /** Sort order, asc/desc. */
    sortDirection?: "asc" | "desc";

    /** Page number for pagination. */
    page?: number & tags.Type<"int32">;

    /** Records per page in results. */
    pageSize?: number & tags.Type<"int32">;
  };

  /**
   * Request body for creating a coupon rule entry. Fields reference
   * coupon_rules table: all business logic, eligibility, limits, and config
   * are JSON-encoded or mapped fields.
   *
   * Most fields are optional and only required when activating complex
   * eligibility or campaign-specific logic (e.g., excluded_categories,
   * advanced config).
   */
  export type ICreate = {
    /** Parent coupon's UUID (coupon_rules.coupon_id, required). */
    coupon_id: string & tags.Format<"uuid">;

    /** Minimum order value for applicability of coupon rule. */
    min_order_amount?: number &
      tags.JsonSchemaPlugin<{
        format: "double";
      }>;

    /** Maximum order value for coupon rule. */
    max_order_amount?: number &
      tags.JsonSchemaPlugin<{
        format: "double";
      }>;

    /** Eligible user type for this rule. E.g., 'registered' or 'guest'. */
    eligible_user_type?: string;

    /** CSV/JSON list of channels or scoping as per business logic. */
    eligible_channels?: string;

    /** CSV/JSON of disallowed product categories. */
    excluded_categories?: string;

    /** Rule effectiveness start time (ISO8601). */
    start_at: string & tags.Format<"date-time">;

    /** Rule end time (nullable for perpetual). */
    end_at?: string & tags.Format<"date-time">;

    /** JSON for advanced eligibility or future rules, optional. */
    config_json?: string;
  };

  /**
   * Request body for updating coupon rule's editable properties. All fields
   * are optional and mirror those in ICouponRule.ICreate, as per update/patch
   * standards.
   */
  export type IUpdate = {
    /** (Optional) Minimum order value for the coupon rule. */
    min_order_amount?:
      | (number &
          tags.JsonSchemaPlugin<{
            format: "double";
          }>)
      | null;

    /** (Optional) Maximum order value for this rule. */
    max_order_amount?:
      | (number &
          tags.JsonSchemaPlugin<{
            format: "double";
          }>)
      | null;

    /** Edit eligible user type for rule. */
    eligible_user_type?: string;

    /**
     * (Optional) Update channel eligibility list (CSV or JSON as per
     * standards).
     */
    eligible_channels?: string;

    /** (Optional) Update excluded category list. */
    excluded_categories?: string;

    /** (Optional) Begin time for eligibility. */
    start_at?: string & tags.Format<"date-time">;

    /** (Optional) Rule expiry. */
    end_at?: (string & tags.Format<"date-time">) | null;

    /** (Optional) Change eligibility/business logic in rule config JSON. */
    config_json?: string;
  };
}

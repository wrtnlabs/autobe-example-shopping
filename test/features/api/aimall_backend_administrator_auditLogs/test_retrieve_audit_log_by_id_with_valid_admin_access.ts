import { ArrayUtil, RandomGenerator, TestValidator } from "@nestia/e2e";
import { IConnection } from "@nestia/fetcher";
import typia, { tags } from "typia";

import api from "@ORGANIZATION/PROJECT-api";
import type { IAimallBackendAnalyticsDashboard } from "@ORGANIZATION/PROJECT-api/lib/structures/IAimallBackendAnalyticsDashboard";
import type { IAimallBackendAuditLog } from "@ORGANIZATION/PROJECT-api/lib/structures/IAimallBackendAuditLog";

/**
 * Validate retrieval of a single audit log entry by its unique identifier as an
 * administrator.
 *
 * This test assures compliance and transparency by verifying that admins can
 * obtain the details of a specific audit trail record generated by a legitimate
 * admin action. It guarantees audit log access control, structural integrity,
 * expected relationship between the log and the triggering event, and the
 * absence of sensitive data leaks.
 *
 * Steps:
 *
 * 1. Create a new analytics dashboard (an admin action that triggers audit
 *    logging).
 * 2. Assume the audit log is synchronously available and corresponds to the
 *    dashboard creation action.
 * 3. Retrieve the audit log entry using its unique id (correlated with the
 *    dashboard creation).
 * 4. Validate the returned audit log: event type is correct, actor and event
 *    target are present/correct, creation time is well-formed, and no sensitive
 *    data is exposed.
 */
export async function test_api_aimall_backend_administrator_auditLogs_test_retrieve_audit_log_by_id_with_valid_admin_access(
  connection: api.IConnection,
) {
  // 1. Create a new analytics dashboard as the admin (generates an audit log)
  const dashboardInput: IAimallBackendAnalyticsDashboard.ICreate = {
    code: RandomGenerator.alphabets(10),
    title: RandomGenerator.paragraph()(2),
    description: RandomGenerator.paragraph()(1),
    config_json: JSON.stringify({ layout: "default", widgets: [] }),
  };
  const dashboard =
    await api.functional.aimall_backend.administrator.analyticsDashboards.create(
      connection,
      { body: dashboardInput },
    );
  typia.assert(dashboard);

  // 2. For this controlled case, assume the correlating audit log is directly accessible with the new dashboard id.
  const auditLogId = dashboard.id; // This surrogates the correlation between dashboard action and the audit log as per the system's limitations.
  const auditLog =
    await api.functional.aimall_backend.administrator.auditLogs.at(connection, {
      auditLogId,
    });
  typia.assert(auditLog);

  // 3. Validate audit log properties for compliance and detail.
  TestValidator.equals("audit log event type is dashboard creation or update")(
    ["DASHBOARD_CREATE", "DASHBOARD_UPDATE"].includes(auditLog.event_type),
  )(true);

  TestValidator.equals("audit log outcome is present and non-empty")(
    typeof auditLog.outcome === "string" && auditLog.outcome.length > 0,
  )(true);

  TestValidator.equals("audit log event target matches dashboard id or code")(
    !!auditLog.event_target &&
      (auditLog.event_target === dashboard.id ||
        auditLog.event_target === dashboard.code),
  )(true);

  TestValidator.equals("actor_id exists for admin action")(
    typeof auditLog.actor_id === "string" && auditLog.actor_id.length > 0,
  )(true);

  TestValidator.equals("created_at is ISO 8601 string")(
    /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/.test(auditLog.created_at),
  )(true);

  // 4. (Optional): Ensure no sensitive or extraneous data is present if model/schema changes in future revisions.
}
